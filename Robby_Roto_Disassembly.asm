; Reverse Source of the file "Robby Roto 0000.bin"
; Public Domain 1999 by designer Jamie Faye Fenton
;
; CPU Type: Z80 for BALLY Commercial Arcade Video Game
;
; Created with dZ80 2.0 totally from scratch by R.C.D.
; on Saturday, 24 of August 2013 at 12:53 AM and ...
;
; Assembles correctly with ZMAC -i -m ROBBY ROTO.asm
; on Thursday, 3 of October 2013 by Richard C Degler
;
; Revisited on Saturday, 9 of June 2018 by R. C. D.
; - finihed labeling graphics and animation tables
; - identified in-game Color and Sound port outputs
; - commented Self-Test code and most of High Scores.
;                                                         #   #     #     #
; Restarted on or about 10/13/2018 by Richard C Degler    #   #     #     #
; when TERSE Forth source code found in ROTO.4th.txt !!   # # #   # # #   # # #
; Added "CVGLIB.H" and moved Game Play down below END         #     #     #   #
;                                                             #     #     #   #

; !! Actual MIXed case COMMENTs from Jay (now Jamie) Fenton's SOURCE CODE !!
; bitsavers.org/pdf/nuttingAssoc/Jay Fenton source code/Robby Roto/ROTO.txt !!
; on 8.5 inch floppies (77 tracks of 4 sectors ?? with NO directory system ??)
; 1024 Bytes as { BLOCK 0### } in 16 64-byte Lines with ASCII on the Left side
; ( --> often ends it) separated by a pipe | from double-digit HEX on the Right.
;
; note: some of the 308 blocks were in (8080A-based) Z-80 opcodes (others as ??)
; re-formatted to one instruction per line, with DECIMAL HEX and BIN Number-base
; and .ABS .REL <ASSEMBLE ASSEMBLE> ;s <STK or <STKH STK> directives as well as:
; DATA name TABLE name BTABLE name F= name and LABEL name (ALL without commas.)
;
; Flow control: XC? (NOT) IFTRUE OTHERWISE IFEND or (commas!) CY~, IF, ELSE, THEN,
; loop control: count DO, LOOP, and BEGIN, 0<>, END, plus BEGIN, 0=, WHILE, REPEAT,
; and stack-based Reverse Polish Notation 8080A _source_ CODE (comma delimited !!)
; between SUBR name ends in RET, and/or CODE name up to NEXT (makes JP  (IY) !!1!).
;
; TERSE Forth also has abbreviations: value Array= name and value ByteArray= name
; as well as these single words or bytes: Variable= name also ByteVariable= name
; value Constant= name and number StartingConstant= name plus NextConstant= name
; followed by 1+ if a word, or preceeded by 1- if a word as PreviousConstant= name
; which can be used as offets into blocks reserved by: length BytesReserved= name
; (optional M$) with totals in RAMLEN C= block(s)length and VARHERE C= blockstart.
;
; Finally, TerseCODE was assembled from TerseSOURCE code using these directives:
; test IF ELSE THEN (NO commas) and value number CASE which ends at a CASE or THEN
; also BEGIN 0<> END or BEGIN 0= WHILE REPEAT as above, ALL from labels and -JUMPS
; but the (internal) end start DO ... LOOP differs as actual TerseDO and TerseLOOP
; words are generated and the loop COUNTers can be read by I J and K instructions.
;
; More TerseMANUAL can be found in the "Terse_Standard_Glossary.pdf" located at :
; (NOT ftp://) http://bitsavers.org/pdf/nuttingAssoc/Jay Fenton source code/TERSE/
; see also: the tutorial at LAB23: FLSHT does "FLaSHer Task" (not even used !!)
;

        NOLIST
        INCLUDE CVGLIB.H

; Variable section
; see "Robby Roto 8000.asm" source below for these Game Play locations:
L88A3   EQU     $88A3           ; valid call into X5 ROM to NEWVECT in Upper ROMs
LDBF0   EQU     $DBF0           ; TerseRoutine if Not in Service mode in X10
; end of ROBBY ROTO EQUates
;

; note: 4K ROMs x1 through x4 from $0000 - $3FFF (also writes to 16K MAGIC pseudo-RAM)
; then 16K of real Screen RAM from $4000 - $7FFF (part number MK4096N-15) or 4027 ??
; six 4K ROMs x5 through x10, from $8000 - $DFFF (see "Robby Roto 8000.asm" below)
; write protected 1.0K N.V. RAM at $E000 - $E3FF Low & High (x21 Low-Power 8416-20)
; non-write protected 1.0K RAM from $E400 - $E7FF (Top half of x21 2K times 8 bits)
; non battery-back-up 6.0K RAM from $E800 - $FFFF (x22-x24 3 Normal-Power 8416-20s)
;

        LIST
        ORG     $0000           ; Test and Text Routines ROM x1 through x4

L0000:  NOP                     ; wait for things to settle down
        NOP
        DI                      ; Disable Interrupts
L0003:  JP      L0027                   ; not JR ??

L0006:  DB      $31,$00

; RST $08 ReSTart handler starts "begin ASSEMBLED TerseCODE ..." (was : in source !!)
; BC->(IX-2), (SP)->BC does "Push BC to Terse stack, Pop BC from System stack"
RST08:  DEC     IX              ; save Terse Program Counter for later
        LD      (IX+$00),B
        DEC     IX
        LD      (IX+$00),C
        POP     BC              ; get new TersePC from System stack
        JP      (IY)            ; indexed RETurn

; !! none of these or below are real RST38:'s !!
        RST     $38             ; do "??"
        RST     $38             ; do "??"
        RST     $38             ; do "??"

; RST $18 ReSTart handler does "Pop HL from System stack, Push (HL),0 to DE to System stack"
; (SP)->HL, $00(HL)->DE->(SP) ... better known as "Terse BYTE Pushers"
RST18:  POP     HL
        LD      E,(HL)
        LD      D,$00
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; L000F:
        NOP                     ; No OPeration

; RST $20 ReSTart handler does "Pop HL from System stack, Push (HL),(HL+1) to DE to System stack"
; (SP)->HL, (HL)->DE->(SP) ... better known as "Terse WORD Pushers"
RST20:  POP     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; start Robby Roto here
L0027:  NOP
; RST $28 ReSTart handler does "re-start Robby Roto here"
RST28:  NOP                     ; wait for things to settle down some more
        XOR     A
        LD      C,$18           ; clear first 24 outports, &(23) down to &(0)
; loop to clear outports
L002C:  DEC     C
        OUT     (C),A
        JR      NZ,L002C                ; (-$05) next outport
        INC     A               ; ?? is this a valid NOP then RST $30 entry ??
        OUT     (CONCM),A       ; set Commercial Mode, aka HiRes
        LD      HL,$FEFF        ; point to Top of Memory Map - $0100 (for COCKTAIL mode)
L0037:  LD      (HL),A          ; 00000001B for Binary test pattern
        CP      (HL)            ; !! none of those are real RST38:'s to here !!
        JR      NZ,L0037                ; (-$04) if No Static RAM ??
        LD      (HL),$00        ; 00000000B for Clear byte
        LD      B,$00           ; 256 passes
; Why ??
L003F:  LD      IX,$FF80
        LD      SP,$0000        ; 0 for ?? Bottom of MEMORY ??
        DJNZ    L003F                   ; (-$09) loop Why ??
        LD      A,$08
        LD      BC,$0015        ; =&(21) "read" SW5 with B = 0 thru 14 step 2
; clear "Special" CONTROL Input $15 Latches 0 through 7 (all Lamps Off)
L004D:  IN      L,(C)
        INC     B
        INC     B
        DEC     A
        JR      NZ,L004D                ; (-$07) for 8 IN writes
; check Control port
        IN      A,(SW0)         ; inport =&(16) Control Port
        BIT     SERVICE,A       ; Active Low for Service mode ?
        JR      Z,L006B                 ; (+$11) if it is, else
        JP      L00A2           ; to Skip over normally

; on CheckSum not Zero for x1 at initalization)
L005D:  LD      A,$07           ; let's strobe White stripes
L005F:  LD      C,$00           ; OUTport COL0R and data to write
; Lock up FOREVER
L0061:  OUT     (C),A
        OUT     (C),C           ; turn COL0R back to Black
        JR      L0061                   ; (-$06) lock up with A = COL0R

; on Bad Write/Read of Static RAM x24
L0067:  LD      A,$53           ; let's strobe Dark Red stripes
        JR      L005F                   ; (-$0c) to Lock up with A = 83

; in Service mode, so Test this ROM and Top 1K of Static RAM
L006B:  LD      HL,L0000        ; for Bottom of Robby Roto X1 ROM
L006E:  LD      BC,$1000        ; for 4096 bytes
        XOR     A
L0072:  ADD     A,(HL)          ; compute CheckSum byte
        CPI
        JP      PE,L0072        ; JumP if No Overflow of BC down-counting
        INC     A               ; roll $FF over to $00 if Correct Sum
        EX      AF,AF'
        LD      A,H
        SUB     $11             ; is past ROM x10 ?
        JR      C,L0084                 ; (+$05) safely if first pass
        EX      AF,AF'
        POP     BC              ; restore Terse Program Counter (TPC)
        PUSH    AF              ; save CheckSum and Zero Flag
        JP      (IY)            ; indexed RETurn

; No problems, continue safely
L0084:  EX      AF,AF'          ; hopefully Zero Flag was set, else ...
        JR      NZ,L005D                ; (-$2a) to CheckSum error
        LD      DE,$0001        ; 1 for ??
        LD      A,$55           ; 01010101B for Test pattern in Color 1
        LD      B,$02
; outer loop
L008E:  LD      HL,$FF00        ; start at 65280 ?? in Static RAM ??
; inner loop
L0091:  LD      (HL),A
        CP      (HL)
        JR      NZ,L0067                ; (-$2e) if Bad Write/Read error
        ADC     HL,DE           ; count up 65280 to 65535 (by 1 in DE)
        JR      NZ,L0091                ; (-$08) until rolled over to 0
        LD      A,$AA           ; 10101010B for Test pattern in Color 2
        DJNZ    L008E                   ; (-$0f) for another pass
        LD      BC,L0E90        ; point to "Service Mode table"
        JR      L00A5                   ; (+$03) made it through Service mode !!

; Service switch was Off
L00A2:  LD      BC,LDBF0        ; point to TerseRoutine to Start ROBBY ROTO
; then fall into ...
;******************************************************************************************
; !! Start of TERSE Forth ENGINE code !!
;
; Terse Efficient Recursive Stack Engine     #   #     #     #         My AmbiGraphic
; or ?? What's the difference between ??     #   #     #     #         spiral symetric
; Terse Efficient Reentrant Stack Engine     # # #   # # #   # # #     Left and Right
; yes, the name itself is also recursive         #     #     #   #     OMNI magazine's
; Writer Al McNeil came up with the name         #     #     #   #     NOT the LOGO !!
;
; ?? does "set Index Y as RETurn point, JumP to (BC)" - aka FORTH Dispatcher ???
;
;*****************************************************************************
; Engine comments borrowed from Commander Dave
; aka David E. Turner <dturner1003@gmail.com>
;
; TERSE REGISTER USE: (best I understand it)
;
; BC = Interpreter Pointer (IP)
; SP = Parmeter Stack Pointer (PSP)
; IX = Return Stack Pointer (RSP)
; IY = Dispatcher - for ASSEMBLED TERSE Forth words !!
;*****************************************************************************
; ... Service switch was On entry point
L00A5:  LD      IY,L00A9        ; set Indexed RETurn to next instruction
; AUTOMATICALLY does (BC)->HL better known as "Continue to NEXT TersePC WORD"
L00A9:  LD      A,(BC)          ; byte 1 into L
        INC     BC
        LD      L,A
        LD      A,(BC)          ; byte 2 into H
        INC     BC
        LD      H,A
        JP      (HL)            ; JumP there

; terseCALLed from L03F2 and more does (IX)->BC  seems to do "Stop Terse CALLs"
; aka "Pop BC from Terse stack" !! listed here as "... TerseRETurn" !!
L00B0:  LD      C,(IX+$00)
        INC     IX
        LD      B,(IX+$00)
        INC     IX
        JP      (IY)            ; indexed RETurn - Terse instruction complete ???

; pushWORD takes name from WORD ?? does "Push (BC) word to System stack"
; note: Sucks 1 Word following TerseCALL
L00BC:  LD      A,(BC)
        INC     BC
        LD      L,A
        LD      A,(BC)
        INC     BC
        LD      H,A
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; pushBYTE takes name from BYTE ?? does "Push 0,(BC) byte to System stack"
; note: Sucks 1 Byte following TerseCALL
L00C5:  LD      A,(BC)          ; read Byte for ??
        INC     BC
        LD      L,A
        LD      H,$00
        PUSH    HL
        JP      (IY)            ; indexed RETurn

;********************************************************************
; ----> ???   Get next IP address and push it on the user stack twice
;********************************************************************
; Note - Not included ???
;
; L007E;  ld      a,(bc)
;         inc     bc
;         ld      l,a
;         ld      a,(bc)
;         inc     bc
;         ld      h,a
;         push    hl
;         jp      L006D

; TERSE Forth nameP does "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
; note: Sucks 1 Word following TerseCALL and add offset from user stack
L00CD:  POP     HL              ; "restore HL"
L00CE:  LD      A,(BC)          ; "read (BC) word to DE"
        INC     BC
        LD      E,A
        LD      A,(BC)
        INC     BC
        LD      D,A
        ADD     HL,DE           ; "ADD DE to HL"
        PUSH    HL              ; and "store HL"
        JP      (IY)            ; indexed RETurn

; ?? does "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
; note: Sucks 1 Word following TerseCALL
L00D8:  POP     HL
        ADD     HL,HL           ; times 2
        JP      L00CE                   ; not JR ?? and add offset from user stack

; TERSE Forth 0 terseCALLed from L0569 does "Push word 0 to System stack" (for FALSE)
L00DD:  LD      HL,$0000        ; 0 is a CONSTANT
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth 1 does "Push word 1 to System stack" (for TRUE)
L00E3:  LD      HL,$0001        ; 1 is a CONSTANT
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth DUP does "DUPlicate Top of System stack"
L00E9:  POP     HL
        PUSH    HL              ; do "Push HL twice"
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth 2DUP does "duplicate top 2 Words of System stack"
L00EE:  POP     HL
        POP     DE
        PUSH    DE
        PUSH    HL
        PUSH    DE
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth DROP does "Pop HL from System stack"
L00F6:  POP     HL
        JP      (IY)            ; indexed RETurn

; 2DROP
; aka "Drop two pairs of values (e.g.) double-precision numbers"
; Note - Not included ???
;

; TERSE Forth R> not used ?? would do "Pop HL from Terse stack, Push to System stack"
; aka "Pop the value from the return stack and push it onto the user stack. ( See >R )"
L00F9:  LD      L,(IX+$00)
        INC     IX
        LD      H,(IX+$00)
        INC     IX
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth >R not used ?? would do "Pop HL from System stack, Push to Terse stack"
; aka "Push m onto top of the return stack. ( See R> )"
L0106:  POP     HL
        DEC     IX
        LD      (IX+$00),H
        DEC     IX
        LD      (IX+$00),L
        JP      (IY)            ; indexed RETurn

; TERSE Forth SWAP from L03F2 does "ex hl,de on System stack"
L0113:  POP     HL
        POP     DE
        PUSH    HL
        PUSH    DE
        JP      (IY)            ; indexed RETurn

;******************************************************************************************
; ----> 2SWAP   Swap two pairs of values (e.g.) double-precision numbers)
;******************************************************************************************
; Note - Not included ???
;
;         pop     hl
;         pop     de
;         exx
;         pop     hl
;         pop     de
;         exx
;         push    de
;         push    hl
;         exx
;         push    de
;         push    hl
;         exx
;         jp      (iy)

;********************************************************************
; ----> SP@     Put stack address on the stack ???
;********************************************************************
; Note - Not included ???
;
;         ld      hl,$0000
;         add     hl,sp
;         push    hl
;         jp      (iy)
;

; TERSE Forth @ does "Pop HL from System stack, Push (HL) word to System stack"
; aka "leave contents q of memory location p."
L0119:  POP     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; TERSE Forth B@ does "Pop HL from System stack, Push 0,(HL) byte to System stack"
; aka "Get lower byte of address on stack and push to stack"
L0120:  POP     HL
        LD      E,(HL)
        LD      D,$00
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; TERSE Forth ! does "Pop HL, Pop DE, word DE->(HL)"
; aka "Store m at address p  [e.g.]  (p) <-- m "
L0127:  POP     HL
        POP     DE
L0129:  LD      (HL),E          ; "DE->(HL)" entry point
        INC     HL
        LD      (HL),D
        JP      (IY)            ; indexed RETurn

; TERSE Forth B! does "Pop HL, Pop DE, Only byte E->(HL)"
; aka "Store integer i to value at address p  [e.g.] (p) <-- i "
L012E:  POP     HL
        POP     DE
        LD      (HL),E
        JP      (IY)            ; indexed RETurn

; TERSE Forth ZERO does "Pop HL, word 00->(HL)"
; aka Set the word at a memory location to zero.
L0133:  POP     HL
        LD      (HL),$00
        INC     HL
        LD      (HL),$00
        JP      (IY)            ; indexed RETurn

; TERSE Forth + does "Pop DE, Pop HL, Push HL + DE"
; aka "ADD word (SP) to (SP+2), Push SUM" for "16 bit integer addition  q=m+n "
L013B:  POP     DE
        POP     HL
        ADD     HL,DE
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth - does "Pop DE, Pop HL, Push HL - DE"
; aka "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
L0141:  POP     DE
        POP     HL
L0143:  XOR     A
        SBC     HL,DE
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth MINUS does "Pop DE, Push 00 - DE" for TWO's complement Top of System stack
L0149:  POP     DE
L014A:  LD      HL,$0000
        JP      L0143                   ; not JR ?? to "Push HL - DE"

; TERSE Forth COM would do "Pop DE + 1, Push 00 - DE" for ONE's COMplement Top of System stack ??
; L0150: not used ?? why not just use CPL ??
        POP     DE
        INC     DE
        JP      L014A                   ; not JR ?? to "00->HL, Push HL - DE"

; TERSE Forth 1- does "DECrement Top of System stack"
L0155:  POP     HL
        DEC     HL
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth 1+ does "INCrement Top of System stack"
L015A:  POP     HL
        INC     HL
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth 2+ does "ADD 2 to Top of System stack"
L015F:  POP     HL
        INC     HL
        INC     HL
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; L0165: not used ?? TERSE Forth 2- would do "SUBtract 2 from Top of System stack"
        POP     HL
        DEC     HL
        DEC     HL
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth 2* does "Double Top of System stack"
L016B:  POP     HL
        ADD     HL,HL           ; times 2
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth 2/MOD does "DIVide by 2 Top of System stack"
L0170:  POP     HL
        SRA     H
        RR      L
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth ABS does "ABSolute value of Top of System stack"
L0178:  POP     HL
        BIT     7,H             ; test SIGN bit ?
        JP      P,L0185                 ; skip if Positive
        EX      DE,HL           ; NEGATE if Negative
        LD      HL,$0000
        XOR     A
        SBC     HL,DE
L0185:  PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth ?? does "INC Top of System stack, then make a BYTE ABSolute"
; aka "INCrement Top of System stack, then Push Old MASKed with 127"
; note: NOT the new BABS routine
L0188:  POP     HL
        LD      A,(HL)
        INC     HL
        PUSH    HL              ; ??
        LD      L,A
        RES     7,L             ; for POSITIVE Byte
        LD      H,$00
        PUSH    HL
        JP      (IY)            ; indexed RETurn

;********************************************************************
; ----> 1-!        Subtract 1 from the contents of memory location.
;********************************************************************
;         pop     hl
;         dec     (hl)
;         jp      (iy)
;

;********************************************************************
; ----> 1+!        Add 1 to the contents of memory location.
;********************************************************************
;         pop     hl
;         inc     (hl)
;         jp      (iy)
;

; TERSE Forth = does "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
L0194:  POP     DE
L0195:  POP     HL              ; entry with DE = 0
        XOR     A
        SBC     HL,DE
        LD      HL,$0000        ; FALSE ??
        JR      NZ,L019F                ; (+$01)
        INC     HL              ; or TRUE ??
L019F:  PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth <> does "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
L01A2:  POP     DE
L01A3:  POP     HL              ; entry with DE = 0
        XOR     A
        SBC     HL,DE
        LD      HL,$0000        ; FALSE ??
        JR      Z,L01AD                 ; (+$01)
        INC     HL              ; or TRUE ??
L01AD:  PUSH    HL
        JP      (IY)            ; indexed RETurn

; ?? TERSE Forth <= does "Pop DE, Pop HL, Push T for LESS OR EQUAL or F for Greater Than"
L01B0:  POP     DE
        POP     HL
        XOR     A
        SBC     HL,DE
        LD      HL,$0000        ; FALSE ??
        JR      C,L01BB                 ; (+$01)
        INC     HL              ; or TRUE ??
L01BB:  PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth < does "Pop DE, Pop HL, Push T for LESS Than or F for Greater or Equal
; from L03F2 does "TEST (SP) LESS Than (SP+2) return in (SP)"
L01BE:  POP     DE
L01BF:  POP     HL
L01C0:  XOR     A
        SBC     HL,DE
        LD      DE,$0000        ; 0 for False
        PUSH    AF              ; check out Flags
        POP     HL
        LD      A,L
        AND     $84             ; #10000100 mask for Sign and Parity/Overflow
        JP      PE,L01CF
        INC     DE              ; 1 for True
L01CF:  PUSH    DE
        JP      (IY)            ; indexed RETurn

; ?? TERSE Forth >= does "TEST (SP) Less or Equal (SP+2) return in (SP)" ??
L01D2:  POP     DE
L01D3:  POP     HL
L01D4:  XOR     A
        SBC     HL,DE
        LD      DE,$0000        ; 0 for False
        PUSH    AF              ; check out Flags
        POP     HL
        LD      A,L
        AND     $84             ; #10000100 mask for Sign and Parity/Overflow
        JP      PO,L01E3
        INC     DE              ; 1 for True
L01E3:  PUSH    DE
        JP      (IY)            ; indexed RETurn

; ?? does"TEST (SP+2) GREATER Than (SP) return in (SP)"
L01E6:  POP     HL
L01E7:  POP     DE
        JP      L01C0                   ; not JR ??

; ?? does "TEST (SP+2) Less or Equal (SP) return in (SP)"
L01EB:  POP     HL
L01EC:  POP     DE
        JP      L01D4                   ; not JR ??

; TERSE Forth 0= does "Pop HL, Push T on ZERO or F on Not Zero"
L01F0:  LD      DE,$0000
        JP      L0195                   ; not JR ??

; TERSE Forth 0<> does "Pop HL, Push F on Zero or T on Not ZERO"
L01F6:  LD      DE,$0000
        JP      L01A3                   ; not JR ??

; ?? TERSE Forth 0< ?? does "TEST (SP) Less Than ZERO return in (SP)"
L01FC:  LD      DE,$0000
        JP      L01BF                   ; not JR ??

; ?? L0202: TERSE Forth 0<> ?? not used ?? does "TEST (SP) Less or Equal ZERO return in (SP)"
        LD      DE,$0000
        JP      L01D3                   ; not JR ??

; ?? does "TEST ZERO Less Than (SP) return in (SP)"
L0208:  LD      HL,$0000
        JP      L01E7                   ; not JR ??

; ?? does "TEST ZERO Less or Equal (SP) return in (SP)"
L020E:  LD      HL,$0000
        JP      L01EC                   ; not JR ??

; TERSE Forth NOT does JumP to TERSE Forth 0= "TEST (SP) Equal ZERO return in (SP)"
L0214:  JP      L01F0                   ; not JR ??

; TERSE Forth -DUP does "DUPlicate Top of System stack IF Not Zero"
L0217:  POP     HL
        PUSH    HL
        LD      A,L
        OR      H
        JR      Z,L021E                 ; (+$01)
        PUSH    HL
L021E:  JP      (IY)            ; indexed RETurn

; TERSE Forth AND does "Pop DE, Pop HL, Push HL AND DE word"
L0220:  POP     DE
        POP     HL
        LD      A,L
        AND     E
        LD      L,A
        LD      A,H
        AND     D
        LD      H,A
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth OR does "Pop DE, Pop HL, Push HL OR DE word"
L022B:  POP     DE
        POP     HL
        LD      A,L
        OR      E
        LD      L,A
        LD      A,H
        OR      D
        LD      H,A
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth XOR does "Pop DE, Pop HL, Push HL XOR DE word"
L0236:  POP     DE
        POP     HL
        LD      A,L
        XOR     E
        LD      L,A
        LD      A,H
        XOR     D
        LD      H,A
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth BMOVE does "Copy (SP) BYTES from (SP+4) source to (SP+2)"
; aka "Pop BC, Pop DE, Pop HL, LDIR IF BC Not Zero" OVERLAPPING CAN OCCUR !!
L0241:  EXX
        POP     BC              ; Byte Count
        POP     DE              ; DEstination
        POP     HL              ; High & Low of source
        LD      A,B
        OR      C
        JR      Z,L024B                 ; (+$02)
        LDIR                    ; Load, Increment, Repeat
L024B:  EXX
        JP      (IY)            ; indexed RETurn

;********************************************************************
; Terse note: !! start of ASSEMBLED "end start DO ... LOOP" code !!
; see: Z-80 "count DO/LOOP" aka "LD  B,count | label ... DJNZ label"
;********************************************************************
;
; TERSE Forth DO does "TerseDO Loop begin" (SP) = START, (SP+2) = END limit
; Pop HL for START Count, Pop DE for END Value, keep old BC then PUSH All 3 to TERSE Stack
L024E:  LD      DE,$FFFA        ; -6 for Loop Quantum
        ADD     IX,DE           ; IndeX was old TERSE Stack Pointer
        POP     HL
        POP     DE
        LD      (IX+$00),L      ; store START value to TERSE Stack (also Loop COUNTer !!)
        LD      (IX+$01),H
        LD      (IX+$02),E      ; store END value to TERSE Stack (check for Limit)
        LD      (IX+$03),D
        LD      (IX+$04),C      ; store TOP of LOOP (Program Counter) to TERSE Stack
        LD      (IX+$05),B
        JP      (IY)            ; indexed RETurn

; TERSE Forth LOOP does "TerseLOOP back to TerseDO or continue" with BC = next location
; note: INCrements COUNTer, checks against END Limit, LOOPs Back if Not OVERflow
L0269:  LD      L,(IX+$00)      ; Loop COUNTer on TERSE Stack
        LD      H,(IX+$01)
        INC     HL
        LD      (IX+$00),L      ; Loop COUNTer on TERSE Stack again
        LD      (IX+$01),H
        LD      E,(IX+$02)      ; read END Value
        LD      D,(IX+$03)
        XOR     A
        SBC     HL,DE
        PUSH    AF              ; check out Flags
        POP     HL
        LD      A,L
        AND     $84             ; 10000100B mask for Sign and Parity/Overflow
        JP      PO,L028F
        LD      DE,$0006        ; past END Limit, so done with TERSE Stack
        ADD     IX,DE           ; +6 for Loop Quantum
        JP      L0295                   ; not JR ?? and continue after Next

; read back TOP of LOOP TersePC address from TerseSTACK and Keep LOOPing
L028F:  LD      C,(IX+$04)      ; offset +4 for (inner) LOOP on TERSE Stack
        LD      B,(IX+$05)
L0295:  JP      (IY)            ; indexed RETurn

; TERSE Forth I does "Push TERSE Loop COUNTer onto System Stack"
L0297:  LD      L,(IX+$00)      ; Loop COUNTer on TERSE Stack
        LD      H,(IX+$01)
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth J does "Push Previous TERSE Loop COUNTer onto System Stack"
L02A0:  LD      L,(IX+$06)      ; +6 for 1 Loop Quantum
        LD      H,(IX+$07)
        PUSH    HL
        JP      (IY)            ; indexed RETurn

;******************************************************************************************
; TERSE Forth K would do "Push Second Previous TERSE Loop COUNTer onto System Stack"
;******************************************************************************************
; NOT included !!
;         ld      l,(ix+$0c)    ; +12 for 2 Loop Quantums
;         ld      h,(ix+$0d)
;         push    hl
;         jp      (iy)

; L02A9: not used ?? would do "ADD TERSE Loop COUNTer I to Top of System stack word"
        LD      L,(IX+$00)
        LD      H,(IX+$01)
        POP     DE
        ADD     HL,DE
        PUSH    HL
        JP      (IY)            ; indexed RETurn

;******************************************************************************************
; would do "ADD TERSE Loop COUNTer J to Top of System stack word"
;******************************************************************************************
; NOT included
;         ld      l,(ix+$06)    ; +6 for 1 Loop Quantum
;         ld      h,(ix+$07)
;         pop     de
;         add     hl,de
;         push    hl
;         jp      (iy)

;******************************************************************************************
; would do "ADD TERSE Loop COUNTer K to Top of System stack word"
;******************************************************************************************
; NOT included
;         ld      l,(ix+$0c)    ; +12 for 2 Loop Quantums
;         ld      h,(ix+$0d)
;         pop     de
;         add     hl,de
;         push    hl
;         jp      (iy)
;

; ?? does "Push a copy of Second from Top word of System stack"
L02B4:  POP     HL
        POP     DE
        PUSH    DE
        PUSH    HL
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; ?? does "Pop HL, Pop DE, ADD DE to (HL) word"
L02BB:  POP     HL
        POP     DE
L02BD:  LD      A,(HL)
        ADD     A,E
        LD      (HL),A
        INC     HL
        LD      A,(HL)
        ADC     A,D
        LD      (HL),A
        JP      (IY)            ; indexed RETurn

; ?? does "Pop HL, INCrement (HL) word"
L02C6:  LD      DE,$0001        ; +1 for INCrement
        POP     HL
        JP      L02BD                   ; not JR ??

; L02CD: not used ?? does "Pop HL, DECrement (HL) word"
        LD      DE,$FFFF        ; -1 for DECrement
        POP     HL
        JP      L02BD                   ; not JR ??

; TERSE Forth SWAB does "SWAp Bytes in Top word of System stack"
L02D4:  POP     HL
        LD      E,L
        LD      L,H
        LD      H,E
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth OUTP does "Pop BC, Pop HL, OUTport (C),L byte"
; used by Show HIGH SCORES screen and others
L02DB:  EXX
        POP     BC
        POP     HL
        OUT     (C),L
        EXX
        JP      (IY)            ; indexed RETurn

;******************************************************************************************
; Read port given in C into register L. Save result on stack.
; Note: Register B is put on upper half of data bus during read
;
; ----> ???
; The difference is that this gets the port off the parm stack
;******************************************************************************************
; TERSE Forth INP does "Pop BC, INPort L,(C) byte, Push 0,L word"
L02E3:  EXX
        POP     BC
        IN      L,(C)
        LD      H,$00
        PUSH    HL
        EXX
        JP      (IY)            ; indexed RETurn

; TERSE Forth ROT does "Pop DE, Pop HL, EX (SP),HL then Push DE, Push (Old SP) to New System stack"
L02ED:  POP     DE
        POP     HL
        EX      (SP),HL         ; third on System stack was (SP+4)
        PUSH    DE
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; ?? does "Pop HL, (HL*2 + SP - 2)->DE, Push DE to System stack"
L02F4:  POP     HL
        DEC     HL              ; minus 1
        ADD     HL,HL           ; times 2
        ADD     HL,SP
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; TERSE Forth 2DROP does "Pop HL, Pop HL" to clean up System Stack
; aka "Drop two pairs of values (e.g.) double-precision numbers"
L02FE:  POP     HL
        POP     HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth * does "Pop DE, Pop BC, MULTiply them, Push HL"
; aka "word (SP+2) MULTiply (SP), push PRODUCT"
L0302:  EXX
        POP     DE
        POP     BC
        LD      HL,$0000        ; clear Total
L0308:  SRL     B               ; test BC bit 0 ?
        RR      C
        JR      NC,L030F                ; (+$01) No ADD if bit 0 was clear
        ADD     HL,DE
L030F:  LD      A,B
        OR      C
        JR      Z,L031A                 ; (+$07) to exit if BC = 0
        SLA     E               ; DE times 2
        RL      D
        JP      L0308                   ; not JR ?? to test next bit

; exit MULTiply if done
L031A:  PUSH    HL              ; save Total
        EXX
        JP      (IY)            ; indexed RETurn

; TERSE Forth /MOD does "Pop BC, Pop HL, DIVIDE them, Push HL, Push DE"
; aka "word (SP+2) DIVided by (SP), Push REMAINDER, Push QUOTIENT"
L031E:  EXX
        POP     BC
        POP     HL
        LD      A,B
        XOR     H
        PUSH    AF
        XOR     H
        BIT     7,A             ; test SIGN bit ?
        JR      Z,L0330                 ; (+$07) if BC Positive
        LD      A,B             ; Two's Complement ?? BC if Negative
        CPL
        LD      B,A
        LD      A,C
        CPL
        LD      C,A
        INC     BC
L0330:  BIT     7,H             ; test SIGN bit ?
        JR      Z,L033B                 ; (+$07) if HL Positive
        LD      A,H             ; Two's Complement ?? HL if Negative
        CPL
        LD      H,A
        LD      A,L
        CPL
        LD      L,A
        INC     HL
L033B:  LD      A,$01           ; 1 for ??
        LD      DE,$0000        ; 0 for ??
; loop until ??
L0340:  BIT     7,B             ; test SIGN bit of WORD ?
        JR      NZ,L034C                ; (+$08)
        SLA     C               ; WORD times 2
        RL      B
        INC     A               ; track POWER OF TWO ??
        JP      L0340                   ; not JR ??

; ?? loop ??
L034C:  OR      A               ; clear Carry flag
        SBC     HL,BC
        JR      NC,L0353                ; (+$02) if Good
        ADD     HL,BC           ; else undo Bad SUBtract
        DEC     DE              ; to -1 temporarily
L0353:  INC     DE
        DEC     A               ; count down POWER OF TWO ??
        JR      Z,L0362                 ; (+$0b) to exit if A = 0
        SLA     E
        RL      D
        SRL     B
        RR      C
        JP      L034C                   ; not JR ?? to loop

; exit DIVIDE when done
L0362:  POP     AF
        BIT     7,A             ; BC XOR HL was Negative (different Signs)
        JR      Z,L0375                 ; (+$0e)
        LD      A,H             ; Two's Complement ?? HL
        CPL
        LD      H,A
        LD      A,L
        CPL
        LD      L,A
        INC     HL
        LD      A,D             ; Two's Complement ?? DE
        CPL
        LD      D,A
        LD      A,E
        CPL
        LD      E,A
        INC     DE
L0375:  PUSH    HL              ; save REMAINDER
        PUSH    DE              ; save RESULT
        EXX
        JP      (IY)            ; indexed RETurn

; ?? does "Pop HL, ADD as OFFSET to TERSE Loop COUNT, check END limit"
; may be called LOOP+ ?? with offsets of -1 and 4320 ??
L037A:  POP     HL
        LD      A,H
        LD      E,(IX+$00)      ; read COUNTer
        LD      D,(IX+$01)
        ADD     HL,DE           ; ADD in OFFSET
        LD      (IX+$00),L      ; write new COUNTer
        LD      (IX+$01),H
        LD      E,(IX+$02)      ; read END Value
        LD      D,(IX+$03)
        OR      A
        SBC     HL,DE
        PUSH    AF              ; check Flags
        POP     HL
        BIT     7,A             ; first, test Sign of OFFSET
        LD      A,L
        JP      Z,L03B0
; if Negative Offset
        AND     $84             ; #10000100 mask for Sign and Parity/Overflow
        JP      PE,L03A7
        LD      DE,$0006        ; +6 for Loop Quantum
        ADD     IX,DE
        JP      L03AD                   ; not JR ?? to JumP to indexed RETurn

; ?? does "TerseJUMP to Start of TerseDO Loop ??"
; read back TOP of DO location and Keep LOOPing
L03A7:  LD      C,(IX+$04)      ; read TOP of LOOP address
        LD      B,(IX+$05)
L03AD:  JP      L03C3                   ; not JR ?? to indexed RETurn

; if Positive Offset
L03B0:  AND     $84             ; #10000100 mask for Sign and Parity/Overflow
        JP      PO,L03BD
        LD      DE,$0006        ; +6 for Loop Quantum
        ADD     IX,DE
        JP      L03C3                   ; not JR ?? to indexed RETurn

; read back TOP of LOOP location and Keep LOOPing
L03BD:  LD      C,(IX+$04)      ; read TOP of LOOP address
        LD      B,(IX+$05)
L03C3:  JP      (IY)            ; indexed RETurn

; TerseJUMP into ASSEMBLED Terse does (BC)->BC aka "Terse JUMP to ??"
; note: sucks 1 Word and trashes A & E
L03C5:  LD      A,(BC)
        LD      E,A
        INC     BC
        LD      A,(BC)
        LD      B,A
        LD      C,E
        JP      (IY)            ; indexed RETurn with New BC pointer

; TERSE Forth IF does CONDITIONAL TerseJUMP "only IF Top of System stack is Zero"
; to matching ELSE (if NOT taken does its thing, then TerseJUMPS past ELSE) to THEN
; note: but IF also makes up ALL of TERSE Forth LOOP, END, WHILE, and CASE codes !!
L03CD:  POP     HL              ; check System Stack
        LD      A,H
        OR      L
        JR      Z,L03D6                 ; (+$04) IF "FALSE" do JumP to TerseJUMP
        INC     BC              ; or eat JUMP Address on "TRUE"
        INC     BC
        JP      (IY)            ; indexed RETurn

; when Zero found THEN "JumP to TerseJUMP"
L03D6:  JP      L03C5                   ; not JR ?? to TerseJUMP

; ?? does "Change TERSE Loop END Value to current COUNTer" ??
; ?? aka (Fake a BREAK out of TerseDO Loop) ??  but NOT a BREAK !!
L03D9:  LD      A,(IX+$00)      ; read COUNTer Byte
        LD      (IX+$02),A      ; write END Byte
        LD      A,(IX+$01)      ; then other Byte
        LD      (IX+$03),A
        JP      (IY)            ; indexed RETurn

; TERSE Forth A" does SKIP RELative by next Byte (counts over) embeded Text String"
; "Push BC, 0->H,(BC)->L + BC" (ASSEMBLER counted LENGTH of "in-line Text String")
L03E7:  PUSH    BC
        LD      A,(BC)
        INC     BC
        LD      L,A
        LD      H,$00
        ADD     HL,BC
        LD      B,H
        LD      C,L
        JP      (IY)            ; indexed RETurn

;
;*****************************************************************************
;
; First of TerseCALLed routines (only CALLED from within OTHER TerseROUTINEs)
;
; ALWAYS start with:  RST  $08  ; begin ASSEMBLED TerseCODE ...
; and end with:  DW  L00B0  ; ... TerseRETurn
;*****************************************************************************
; read as STACK-based R.P.L. read from Left to Right !!
; depending on the TerseROUTINE, a Byte or Word will be read in
;
; TERSE Forth MAX does "keep only MAXimum of Top 2 on SystemStack" with branching !!
; note: Conditional- and/or TerseJUMPs have their destination LABELs next to them
; (the -JUMP to LABELs show up better than before when they were underneath :-)
L03F2:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00EE           ; 2DUP do "duplicate top 2 Words of System stack"
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; IF False to THEN
        DW      L03CD,L03FD     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ; or if True continue
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ; THEN from L03F2
L03FD:  DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; L0401: TERSE Forth MOVE (not used ??) "does COPY WORDS" ??
        RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L016B           ; 2* do "Double Top of System stack"
        ;
        DW      L0241           ; BMOVE do "Pop BC, Pop DE, Pop HL, LDIR IF BC Not Zero"
        ;
        DW      L00B0           ; ... TerseRETurn

; TERSE Forth MIN does "keep only MINimum of Top 2 on SystemStack"
L0408:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00EE           ; 2DUP do "duplicate top 2 Words of System stack"
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ; IF False to THEN
        DW      L03CD,L0413     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ; if True do this
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ; THEN at the label
L0413:  DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; TERSE Forth MOD does "MODulo divide (SP+2) by (SP), Push REMAIDER and discard QUOTIENT"
L0417:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L031E           ; /MOD do "word (SP+2) DIVided by (SP), Push REMAINDER, Push QUOTIENT"
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; TERSE Forth / does "DIVide (SP+2) by (SP), Push QUOTIENT and discard REMAIDER"
L041E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L031E           ; /MOD do "word (SP+2) DIVided by (SP), Push REMAINDER, Push QUOTIENT"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; TERSE Forth CASE does "Pop HL, Pop DE, IF Not Equal TerseJUMP, Push DE for ??"
; note: POP 2 Words and Suck 1 Word after, IF <> then PUSHes 1 Word and TerseJUMPS to 1 Word after
L0427:  POP     HL              ; This CASE
        POP     DE              ; Prior ??
        OR      A               ; (to Clear CarrY flag)
        SBC     HL,DE           ; equal ?
        JR      NZ,L0432                ; (+$04) no
        INC     BC              ; eat a Word
        INC     BC
        JP      (IY)            ; indexed RETurn

; not equal, so (BC)->BC, Push DE for ??
L0432:  LD      A,(BC)          ; read next Word ...
        LD      L,A
        INC     BC
        LD      A,(BC)
        LD      B,A
        LD      C,L             ; ... for NEW TerseProgran Counter
        PUSH    DE              ; and re-store Prior ??
        JP      (IY)            ; indexed RETurn to NEW PC

; L043B: not used ?? would do "Pop HL, Pop DE, ADD 0,E to (HL)"
        POP     HL
        POP     DE
; ?? entry point
L043D:  LD      A,(HL)
        ADD     A,E
        LD      (HL),A
        JP      (IY)            ; indexed RETurn

; TERSE Forth 1+B! does "Pop HL, ADD 1 to (HL)"
L0442:  LD      E,$01
        POP     HL
        JP      L043D                   ; not JR ??

; TERSE Forth 1-B! does "Pop HL, SUBtract 1 from (HL)"
L0448:  LD      E,$FF
        POP     HL
        JP      L043D                   ; not JR ??

; L044E: not used ?? would do "Pop DE, Pop HL, store E byte into (HL)"
        POP     DE
        POP     HL
        LD      (HL),E
        JP      (IY)            ; indexed RETurn

; TERSE Forth BONE does "Pop HL, store 1 into (HL)"
L0453:  POP     HL
        LD      (HL),$01        ; for TRUE ??
        JP      (IY)            ; indexed RETurn

; TERSE Forth BZERO does "Pop HL, store 0 into (HL)"
L0458:  POP     HL
        LD      (HL),$00        ; for FALSE ??
        JP      (IY)            ; indexed RETurn

; L045D: would do "Pop DE, Pop HL, store DE word into (HL)"
        POP     DE
        POP     HL
        JP      L0129                   ; to "DE->(HL)"

; jumped to with DE = -2 or -4 for ??
L0462:  LD      HL,($FF00)      ; push old Saved SP to what ??
        PUSH    HL
        LD      ($FF00),SP      ; save SP in ??
        LD      HL,($FF00)
        ADD     HL,DE           ; then SUBtract 2 or 4
        LD      SP,HL
        JP      (IY)            ; indexed RETurn

; ?? does "Push old Saved SP, Save SP as new"
L0471:  LD      HL,($FF00)
        PUSH    HL
        LD      ($FF00),SP
        JP      (IY)            ; indexed RETurn

; ?? does "Push old Saved SP, save SP as new, then SUBtract 2"
L047B:  LD      DE,$FFFE        ; -2 for ??
        JR      L0462                   ; (-$1e)

; ?? does "Push old Saved SP, save SP as new, then SUBtract 4"
L0480:  LD      DE,$FFFC        ; -4 for ??
        JR      L0462                   ; (-$23)

; jumped to with DE = 0, 2, 4 or 6 for ??
L0485:  LD      SP,($FF00)
        POP     HL
        LD      ($FF00),HL
        EX      DE,HL
        ADD     HL,SP
        LD      SP,HL
        JP      (IY)            ; indexed RETurn

; ?? does "restore Saved SP, Pop and save old SP"
L0492:  LD      DE,$0000        ; 0 for ??
        JR      L0485                   ; (-$12)

; ?? does "restore Saved SP, Pop and save old SP, then ADD 2"
L0497:  LD      DE,$0002        ; 2 for ??
        JR      L0485                   ; (-$17)

; ?? does "restore Saved SP, Pop and save old SP, then ADD 4"
L049C:  LD      DE,$0004        ; 4 for ??
        JR      L0485                   ; (-$1c)

; L04A1: not used ?? would do "restore Saved SP, Pop and save old SP, then ADD 6"
        LD      DE,$0006        ; 6 for ??
        JR      L0485                   ; (-$21)

; jumped to with DE = -4, -2, 2, 4 or 6 for ??
L04A6:  LD      HL,($FF00)
        ADD     HL,DE
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; ?? does "read Saved SP, ADD 2 then Push for ??"
L04AD:  LD      DE,$0002        ; 2 for ??
        JP      L04A6                   ; not JR ??

; ?? does "read Saved SP, ADD 4 then Push for ??"
L04B3:  LD      DE,$0004        ; 4 for ??
        JP      L04A6                   ; not JR ??

; ?? does "read Saved SP, ADD 6 then Push for ??"
L04B9:  LD      DE,$0006        ; 6 for ??
        JR      L04A6                   ; (-$18)

; ?? does "read Saved SP, SUBtract 2 then Push for ??"
L04BE:  LD      DE,$FFFE        ; -2 for ??
        JR      L04A6                   ; (-$1d)

; ?? does "read Saved SP, SUBtract 4 then Push for ??"
L04C3:  LD      DE,$FFFC        ; -4 for ??
        JR      L04A6                   ; (-$22)

; jumped to with DE = -4, -2, 2, 4 or 6 for ??
L04C8:  LD      HL,($FF00)
        ADD     HL,DE
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; ?? does "read Saved SP, SUBtract 2 then Push (HL) for ??"
L04D2:  LD      DE,$FFFE        ; -2 for ??
        JR      L04C8                   ; (-$0f)

; ?? does "read Saved SP, SUBtract 4 then Push (HL) for ??"
L04D7:  LD      DE,$FFFC        ; -4 for ??
        JR      L04C8                   ; (-$14)

; ?? does "read Saved SP, ADD 2 then Push (HL) for ??"
L04DC:  LD      DE,$0002        ; 2 for ??
        JP      L04C8                   ; not JR ??

; ?? does "read Saved SP, ADD 4 then Push (HL) for ??"
L04E2:  LD      DE,$0004        ; 4 for ??
        JP      L04C8                   ; not JR ??

; ?? does "read Saved SP, ADD 6 then Push (HL) for ??"
L04E8:  LD      DE,$0006        ; 6 for ??
        JR      L04C8                   ; (-$25)

;
;**********************************************************
; !! BYTE Pushers !! used to put COMMON numbers on System stack,
; and WORD Pushers - all PUSH data onto Top of System stack then RETurn
; note: has the only valid RST $18's and/or RST $20's in here ??
L04ED:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $02             ; 2 for ??

L04EF:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $03             ; 3 for ??

L04F1:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $04             ; 4 for ??

L04F3:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $05             ; 5 for ??

L04F5:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $06             ; 6 for ??

L04F7:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $07             ; 7 for ??

L04F9:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $08             ; 8 for ??

L04FB:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $09             ; 9 for ??

L04FD:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $0A             ; 10 for ??

L04FF:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $0B             ; 11 for ??

L0501:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $0C             ; 12 for ??

L0503:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $0D             ; 13 for ??

L0505:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $0E             ; 14 for ??

L0507:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $0F             ; 15 for ??

; switch to various BYTE pushers
L0509:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $60             ; 96 for ??

L050B:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $23             ; 35 for ??

L050D:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $29             ; 41 for ??

L050F:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $21             ; 33 for ??

L0511:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $10             ; 16 for ??

L0513:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $7E             ; 126 for ??

L0515:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $31             ; 49 for ??

L0517:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $2E             ; 46 for ??

L0519:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $30             ; 48 for ??

L051B:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $40             ; 64 for ??

L051D:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $FF             ; 255 (or -1) for ??

L051F:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $20             ; 32 for ??

L0521:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $11             ; 17 for ??

L0523:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $12             ; 18 for ??

L0525:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $13             ; 19 for ??

L0527:  RST     $18             ; do "(SP)->HL, $00(HL)->DE->(SP)"
        DB      $55             ; 85 for 01010101B 4-pixels of Color 1

; switch to various WORD Pushers
L0529:  RST     $20             ; do "(SP)->HL, (HL)->DE->(SP)" !!
        DW      $FFFF           ; -1 for ?? (NOT used for MMSV !!)

L052C:  RST     $20             ; do "(SP)->HL, (HL)->DE->(SP)" !!
        DW      $FFFE           ; -2 for ??

L052F:  RST     $20             ; do "(SP)->HL, (HL)->DE->(SP)" !!
        DW      $FFFD           ; -3 for ??

L0532:  RST     $20             ; do "(SP)->HL, (HL)->DE->(SP)" !!
        DW      $FFFC           ; -4 (NOT used ??)

; and lastly for NORMEM, size of NORMEM, or ??
L0535:  RST     $20             ; do "(SP)->HL, (HL)->DE->(SP)" !!
        DW      $4000           ; 16384 for NORMEM
 ; end of WORD Pushers until L0BE1: and L2E11:

;**********************************************************
; turn Interrupts Off / On from Terse Forth code

; TERSE Forth DI (from several places) does "Disable Interrupt"
L0538:  DI
        JP      (IY)            ; indexed RETurn

; TERSE Forth EI (thrice ??) does "Enable Interrupt"
L053B:  EI
        JP      (IY)            ; indexed RETurn

; "Two's COMPLEMENT of HL" subroutine (from CALL)
L053E:  PUSH    AF
        LD      A,H
        CPL
        LD      H,A
        LD      A,L
        CPL
        LD      L,A
        INC     HL
        POP     AF
        RET

; "Two's COMPLEMENT of DE" subroutine
L0548:  PUSH    AF
        LD      A,D
        CPL
        LD      D,A
        LD      A,E
        CPL
        LD      E,A
        INC     DE
        POP     AF
        RET

; L0552: not used ?? "Two's COMPLEMENT of BC" subroutine
        PUSH    AF
        LD      A,B
        CPL
        LD      B,A
        LD      A,C
        CPL
        LD      C,A
        INC     BC
        POP     AF
        RET

; TERSE Forth FILL (from L0569) does "FILL byte (SP+4) from (SP+2) while (SP)"
L055C:  EXX
        POP     BC              ; strip top 3 words from system Stack
        POP     HL
        POP     DE
L0560:  LD      (HL),E          ; save, then Loop until done
        CPI                     ; (COMPARE AND INCREMENT) A-(HL),HL=HL+1,BC=BC-1
        JP      PE,L0560        ; until BC Underflows ?? (ignore FIND !!)
        EXX
        JP      (IY)            ; indexed RETurn with Z flag = 0 if found ??

; ?? does "TerseFILL byte 0 from NORMEM while Size of NORMEM"
L0569:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L0535           ; 16384 (hex $4000) "WORD Pusher" for NORMEM
        ;
        DW      L0535           ; 16384 (hex $4000) "WORD Pusher" for Size of NORMEM
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L00B0           ; ... TerseRETurn with system Stack unchanged ??

; L0574: not used ?? does ??
        POP     HL
        LD      A,L
        RRCA
        RRCA
        RRCA
        RRCA
        LD      L,A
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth invert? dues "read CABINet mode and if Not 0 set MRFLOP and MRFLIP in C"
L057E:  LD      A,($FEFF)       ; bit 0 = 1 for P2 in COCKTAIL mode ONLY !!
        OR      A
        RET     Z
        LD      A,C
        XOR     $C0             ; toggle MRFLOP and MRFLIP (or CMFLOP and CMFLIP !!)
        LD      C,A
        RET

; TERSE Forth invertxy? dues "read CABINet mode and if Not 0 do INVERT Full-Scale X and Y locations"
L0588:  LD      A,($FEFF)       ; bit 0 = 1 for P2 in COCKTAIL mode ONLY !!
        OR      A
        RET     Z
        PUSH    HL
        LD      HL,$5000        ; 20480 MINUS DE = X offset
        OR      A
        SBC     HL,DE
        EX      (SP),HL         ; SWAP !!
        EX      DE,HL
        LD      HL,$3300        ; 13056 MINUS HL = Y offset
        OR      A
        SBC     HL,DE           ; HL = 13056 to 0 for Y
        POP     DE              ; DE = 20480 to 0 for X
        RET

; ?? does SCALE DOWN Full-Scale X and Y locations from L06FA: with DE = ($FF16) and HL = ($FF14)
L059E:  CALL    L057E           ; invert? du "read CABINet mode and if Not 0 set MRFLOP and MRFLIP"
        CALL    L0588           ; invertxy? du "read CABINet mode and if Not 0 do Full-Scale INVERT"
        SLA     L               ; times 4 for ??
        RL      H
        SLA     L
        RL      H
        LD      A,H
        LD      H,$00
        LD      L,A
        ADD     HL,HL           ; times 80 for BPLINE
        ADD     HL,HL
        ADD     HL,HL
        ADD     HL,HL
        PUSH    DE
        LD      E,L
        LD      D,H
        ADD     HL,HL
        ADD     HL,HL
        ADD     HL,DE
        EX      DE,HL           ; return TOP Line in DE
        POP     HL              ; restore X location times 8,
        LD      A,L             ; quick-divide by 16
        LD      L,H
        LD      H,$00
        ADD     HL,DE           ; return Word ABSOLUTE Address in HL
        RLCA                    ; Circulate Top 2 bits of ??, then
        RLCA
        AND     $03             ; Mask only SHIFT bits ??
        RET                     ; retURN A = MAGIC to use

; ?? does DRAW a CHARacter with MAGIC given (multi-part) routine
L05C6:  LD      A,B
        AND     00001111B       ; mask with $0F for Color ?? on Color ??
        OUT     (XPAND),A       ; &(25)=?? for eXPANDer pixel definition port
        CALL    L057E           ; invert? du "read CABINet mode and if Not 0 set MRFLOP and MRFLIP"
        LD      A,C
        OUT     (MAGIC),A       ; &(12)=?? for MAGIC register
        PUSH    IX
        POP     BC
        BIT     MRFLIP,A             ; is MAGIC FLIP bit 7 set ?
        JR      NZ,L060E                ; (+$36) if TRUE
        BIT     MRFLOP,A             ; is MAGIC FLOP bit 6 set ?
        JR      Z,L05F5                 ; (+$19) if FALSE
L05DC:  PUSH    DE              ; just FLOP Left/Right
        PUSH    HL              ; store XY for Screen location
L05DE:  LD      A,(BC)          ; loop here for one ROW
        LD      (HL),A          ; eXPAND right-to-left bytes
        DEC     HL
        LD      (HL),A
        DEC     HL
        INC     BC
        DEC     E               ; for Image WIDTH in bytes
        JR      NZ,L05DE                ; (-$09)
        LD      (HL),E          ; write 2 ZEROS in case of any SHIFT
        DEC     HL
        LD      (HL),E
        POP     HL
        LD      DE,$0050        ; old XY + 80 for next ROW down
        ADD     HL,DE
        POP     DE              ; restore Image BYTES/ROWS remaining
        DEC     D
        JR      NZ,L05DC                ; (-$17) loop
        JR      L060C                   ; (+$17) to exit

; if neither just draw Image normal
L05F5:  PUSH    DE              ; loop here for all ROWs
        PUSH    HL              ; store XY for Screen location
L05F7:  LD      A,(BC)          ; loop here for one ROW
        LD      (HL),A          ; eXPAND left-to-right bytes
        INC     HL
        LD      (HL),A
        INC     HL
        INC     BC
        DEC     E               ; for Image WIDTH in bytes
        JR      NZ,L05F7                ; (-$09)
        LD      (HL),E          ; write 2 ZEROS in case of any SHIFT
        INC     HL
        LD      (HL),E
        POP     HL
        LD      DE,$0050        ; old XY + 80 for next ROW down
        ADD     HL,DE
        POP     DE              ; restore Image BYTES/ROWS remaining
        DEC     D
        JR      NZ,L05F5                ; (-$17) loop
L060C:  JR      L0648                   ; (+$3a) to exit

; if MRFLIP bit set (do in software !!)
; note: these two draw an Image up-side-down on Screen !!
L060E:  BIT     MRFLOP,A             ; is MAGIC FLOP bit 6 set ?
        JR      Z,L062E                 ; (+$1c) if TRUE
L0612:  PUSH    DE              ; else just FLIP image here
        PUSH    HL              ; store XY for Screen location
L0614:  LD      A,(BC)          ; loop here for one ROW
        LD      (HL),A          ; eXPAND right-to-left bytes
        DEC     HL
        LD      (HL),A
        DEC     HL
        INC     BC
        DEC     E               ; for Image WIDTH in bytes
        JR      NZ,L0614                ; (-$09)
        LD      (HL),E          ; write 2 ZEROS in case of any SHIFT
        DEC     HL
        LD      (HL),E
        POP     HL
        LD      DE,$0050        ; old XY - 80 for next ROW up
        SCF
        CCF
        SBC     HL,DE
        POP     DE              ; restore Image BYTES/ROWS remaining
L0629:  DEC     D
        JR      NZ,L0612                ; (-$1a) loop
        JR      L0648                   ; (+$1a) to exit

; if both MRFLOP and MRFLIP bits set
L062E:  PUSH    DE              ; then FLOP and FLIP image here
        PUSH    HL              ; store XY for Screen location
L0630:  LD      A,(BC)          ; loop here for one ROW
        LD      (HL),A          ; eXPAND left-to-right bytes
        INC     HL
        LD      (HL),A
        INC     HL
        INC     BC
        DEC     E               ; for Image WIDTH in bytes
        JR      NZ,L0630                ; (-$09)
        LD      (HL),E          ; write 2 ZEROS in case of any SHIFT
        INC     HL
        LD      (HL),E
        POP     HL
        LD      DE,$0050        ; old XY - 80 for next ROW up
        SCF
        CCF
        SBC     HL,DE
        POP     DE              ; restore Image BYTES/ROWS remaining
        DEC     D
        JR      NZ,L062E                ; (-$1a) loop
L0648:  LD      E,$01           ; flag ?? and exit
        RET
; end of DRAW a CHARacter

; 61 word ASCII-to-CHARacter MONOCHROME Image data table
; note: word Zero denotes MISSING ASCII CHARacter Images
L064B:  DW      L0E93           ; ASCII $20 for CHAR SPACE
        DW      LBC5D           ; ASCII $21 for Symbol '!'
        DW      $0000           ; ASCII $22 do NOT use ...
        DW      $0000           ; ASCII $23
        DW      $0000           ; ASCII $24
        DW      $0000           ; ASCII $25
        DW      $0000           ; ASCII $26
        DW      $0000           ; ASCII $27
        DW      $0000           ; ASCII $28
        DW      $0000           ; ASCII $29
        DW      $0000           ; ASCII $2A
        DW      $0000           ; ASCII $2B
        DW      $0000           ; ASCII $2C
        DW      $0000           ; ASCII $2D
        DW      LBC56           ; ASCII $2E for Symbol '.'
        DW      L0E99           ; ASCII $2F for Symbol '/'
        DW      L0FE3           ; ASCII $30 for Number '0'
        DW      L0F6B           ; ASCII $31 for Number '1'
        DW      L0F7A           ; ASCII $32 for Number '2'
        DW      L0F89           ; ASCII $33 for Number '3'
        DW      L0F98           ; ASCII $34 for Number '4'
        DW      L0FA7           ; ASCII $35 for Number '5'
        DW      L0FB6           ; ASCII $36 for Number '6'
        DW      L0FC5           ; ASCII $37 for Number '7'
        DW      L0FF2           ; ASCII $38 for Number '8'
        DW      L0FD4           ; ASCII $39 for Number '9'
        DW      $0000           ; ASCII $3A
        DW      $0000           ; ASCII $3B
        DW      $0000           ; ASCII $3C
        DW      LBC47           ; ASCII $3D for Symbol '='
        DW      $0000           ; ASCII $3E
        DW      $0000           ; ASCII $3F
        DW      $0000           ; ASCII $40
        DW      L1010           ; ASCII $41 for Letter 'A'
        DW      L0EA8           ; ASCII $42 for Letter 'B'
        DW      L0EB7           ; ASCII $43 for Letter 'C'
        DW      L0EC6           ; ASCII $44 for Letter 'D'
        DW      L0ED5           ; ASCII $45 for Letter 'E'
        DW      L0EE4           ; ASCII $46 for Letter 'F'
        DW      L0EF3           ; ASCII $47 for Letter 'G'
        DW      L0F02           ; ASCII $48 for Letter 'H'
        DW      L0F11           ; ASCII $49 for Letter 'I'
        DW      L0F20           ; ASCII $4A for Letter 'J'
        DW      L0F2F           ; ASCII $4B for Letter 'K'
        DW      L1001           ; ASCII $4C for Letter 'L'
        DW      L101F           ; ASCII $4D for Letter 'M'
        DW      L0F3E           ; ASCII $4E for Letter 'N'
        DW      L0F4D           ; ASCII $4F for Letter 'O'
        DW      L1056           ; ASCII $50 for Letter 'P'
        DW      L1065           ; ASCII $51 for Letter 'Q'
        DW      L0F5C           ; ASCII $52 for Letter 'R'
        DW      L1038           ; ASCII $53 for Letter 'S'
        DW      L1074           ; ASCII $54 for Letter 'T'
        DW      L1047           ; ASCII $55 for Letter 'U'
        DW      L1083           ; ASCII $56 for Letter 'V'
        DW      L1092           ; ASCII $57 for Letter 'W'
        DW      L10AB           ; ASCII $58 for Letter 'X'
        DW      L10BA           ; ASCII $59 for Letter 'Y'
        DW      L10C9           ; ASCII $5A for Letter 'Z'
        DW      $0000           ; ASCII $5B missing ...
        DW      $0000           ; ASCII $5C beyond here
; end of ASCII-to-CHARacter Image table

; !! some ASSEMBLED TerseCODE (nissing TERSE Forth _source_ CODE) !!
;
; ?? does ??
L06C5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E9           ; DUP do "DUPlicate Top of System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $7E             ; 126 for ??
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ;
        DW      L02B4           ; do "Push a copy of Second from Top word of System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ; IF False #1 skip
        DW      L03CD,L06DF     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ; THEN #1 label
L06DF:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00D8           ; do "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      L064B           ; word ASCII-to-CHARacter Image data table
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00E9           ; DUP do "DUPlicate Top of System stack"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; IF False #2 skip
        DW      L03CD,L06F8     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00D8           ; do "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      L064B           ; word ASCII-to-CHARacter Image data table
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ; THEN #2 label
L06F8:  DW      L00B0           ; ... TerseRETurn

; ?? does DRAW a CHARacter un-scaled (ONLY in SELF-Test mode !!)
L06FA:  POP     HL              ; read CHARacter Header address (PAST significant Pixels !!)
        PUSH    BC              ; store TERSE Program Counter
        INC     HL              ; skip X & Y OFFSET Bytes
        INC     HL
        LD      E,(HL)          ; byte Image Width in BYTES into DE
        INC     HL
        LD      D,(HL)          ; byte Image Height in ROWS
        INC     HL
        PUSH    HL              ; store CHARacter IMAGE as new IndeX
        EX      (SP),IX         ; stores old IX instead
        PUSH    DE              ; store DE for CHARacter BYTES/ROWS
        LD      DE,($FF16)      ; DE = 0 (LEFT) to 20480 (RIGHT) for X
        LD      HL,($FF14)      ; HL = 0 (TOP) to 13056 (BOTTOM) for Y
        CALL    L059E           ; do SCALE DOWN Full-Scale X and Y locations to ABSolute
        POP     DE              ; restore DE for Image BYTES/ROWS
        OR      $08             ; SET bit 3 for MRXPND on
        LD      C,A             ; preset for MAGIC byte
        LD      B,$0C           ; preset for eXPANDer = Color 3 on Color 0
        CALL    L05C6           ; do DRAW an CHARacter with MAGIC given
        POP     IX              ; restores old IX for ??
        POP     BC              ; restore TERSE PC
        JP      (IY)            ; indexed RETurn

; { BLOCK 0095 }
; ( MORE PARAMETERS )
; 11 C= NCOLS 6 C= NROWS
; NCOLS NROWS * C= NNODES
; 5 C= START-COL
; 82 C= RP-Y 82 C= RQ-Y 0 C= ST-X 52 C= ST-Y
; 15 C= DC-T 40 C= HM-T
; 91 C= SC-Y 30 C= RX-T 15 C= HR-T
; ( MESH PARMS )
; 320 NCOLS / C= COLSIZE 178 NROWS / C= ROWSIZE
; NROWS 1- DUP C= START-ROW
; COLSIZE 21 - C= COLDEV ROWSIZE 21 - C= ROWDEV
;
; -->
;
; end of ( MORE PARAMETERS ) !! where is the block that this follows ??

; missing BLOCK with ?? and SC= value DROP ??
; could have used RAMMARK then RAMLEN VARHERE
;
; 0 StartingConstant= NODX constant 0
; +3 NextConstant= NBX constant 4 ...
; MPL0 constant 8 for ??
; NDX0 constant 12 for ??
; NDY0 constant 16 for ??
; RVMD constant 20 for ??
; NODMSK constant 24 for Byte NODe MaSK
; see bits below :
; NMDRW bit number 0 in NODMSK for ??
; NMDRM constant 1 for Mask bit 0 ??
; NMEXS bit 7 in NODMSK for ??
;
; leaves Next Constant as 25
; then 2+ for NODSIZ as 27
; 27 times 66 for NM-S as 1782 ??
; and NODEMAT as NodeMatrix-Sized  ...

; { BLOCK 0064 }
; NC= >TREASURE 1+
; 1+ C= NODSIZ
; NODSIZ NNODES * C= NM-S
; NM-S BA= NODEMAT
;
; ( ARROW ARRAY )
; ( 4 24 * 4 + C= ARWL ARWL BA= ARWP )
; ( V= Ths )   BV= h-f   ( BV= MAKCON )
; -->
;
; end of { BLOCK 0064 } !! Arrow Array Commented out !!

; { BLOCK 0111 }
;    G 4 ROARRAY )
; 4 24 * 4 + C= ARWL ARWL BA= ARWP
; V= Ths BV= h-f BV= MAKCON
; -->
;
; end of { BLOCK 0111 } !! Arrow Array CHANGED below !!
;
; note: V= Ths NOT used, BV= h-f DUPLICATE, and BV= MAKCON also NOT used !!

; { BLOCK 0283 }
; ( VECTOR FIELDS )
; DECIMAL VLENGTH SC= INTR NC= INTC ( INITIAL POS AND COL )
; NC= NOWR NC= NOWC ( CURRENT ROW AND COLUMN )
; NC= NOWD ( CURRENT DIRECTION )
; ( NC= NXTR NC= NXTC ) ( NEXT ROW AND COLUMN )
; ( CUSTOM VECTOR ROUTINE GOODIES )
; NC= BASEX 1+
; NC= BASEY 1+
; NC= DELTAX 1+
; NC= DELTAY 1+
; NC= MAXDIST MAXDIST NOWR - 1+ C= POSLEN
; NC= DISTANCE 1+
; NC= DELTADIST 1+ DELTADIST NOWR - C= SNATLEN
; ( NC= ACCDIST 1+ )
; NC= MEMDIST NC= MEMR NC= MEMC NC= MEMD
; -->
;
; end of ( VECTOR FIELDS ) !!

; { BLOCK 0155 }
; ( MORE CUSTOM VECTOR FIELDS )
; NC= CUSVEC 1+ ( CUSTOM VECTOR ROUTINE ADDRESS )
; NC= MYFLAG ( BUILD IN NEATO FLAG )
; NC= DRPO ( DROP OFF FLAG )
; NC= DISPF ( DISPLACEMENT FACTOR )
; NC= VCOR 1+ ( MY COROUTINE CELL )
; NC= BEHIND 1+ ( FELLOW BEHIND ME )
; NC= AHEAD 1+ ( FELLOW AHEAD OF ME )
; NC= OBJSV ( OBJECT STATE VARIABLE )
; 1+ C=
; M#L SC= ASSMSV
; NC= DIST-1 ( PREV DISTANCE )
; 1+ C= V#L
; -->
;
; end of ( MORE CUSTOM VECTOR FIELDS ) !!

; { BLOCK 0168 }
; ( CLEARED EACH GAME FRAME STUFF ) RAMMARK
; BV= DIGSCR
; BV= EOF ( END OF FRAME FLAG )
; BV= Hctr
; BV= ARS ( ARROW STATUS )
; ( BV= ARON ARROWS ENABLED FLAG )
; BV= F-F ( FREEZE FLAG )
; BV= DORS ( DOOR STATE )
; BV= MAFLG ( MAGIC IN USE FLAG )
; BV= MASCL ( MAGIC INTERRUPT PRESCALER )
; BV= JAWSF ( JAWS ON SCREEN FLAG )
; BV= Chw ( HOSTAGE WAIT COUNTER )
; BV= DSM4 ( DOOR SEMIFORE )
; BV= ASSH ( MEANNESS COUNTER )
; BV= SOB ( FLAG SET WHEN GAME GETS MEAN )
; RAMLEN C= CGFL VARHERE C= CGFS
; -->
; end of ( CLEARED EACH GAME FRAME STUFF ) !!

; { BLOCK 0275 }
; ( STUFF FOR MONSTERS - PRECEEDS NORMAL VECTOR DOPE )
; { : PC= } 1- DUP C= { ; }
; 0 PC= MMSV ( MONSTER MOTION STATE )
; 1- PC= MSPDS ( MONSTER SLOW SPEED )
; 1- PC= MSPDF ( MONSTER FAST SPEED )
; PC= RMctr ( HOSTAGE GUARDING STATE VAR )
; PC= PMOD
; 1- PC= FNDPTR 1- PC= TRACKPTR 1- PC= TREECK TREECK C= WTCTR
; 1- PC= MYBOSS
; 1- PC= FRONTIER
; NCOLS - PC= VISMAT
; 0 SC= TPL NC= TPH NC= TRC NC= TD 1+ C= TEL
; TEL NNODES * C= TDEPTH 134 C= SURPLUS
; TDEPTH SURPLUS + -
; PC= TREES ABS C= MONSURP
; -->
; end of { STUFF FOR MONSTERS - PRECEEDS NORMAL VECTOR DOPE } !!

; { BLOCK 0088 }
; ( MONSTER STATE VARIABLE )
; 0 SC= MSPRO ( MONSTER ON PROWL )
; NC= MSRIP ( RETURN INITIAL POSITION )
; NC= MSAIP ( AT INITIAL POSITION )
; NC= MSSNA DROP ( SNATCH HOSTAGE )
; ( MONSTER MOTION STATE VARIABLE )
; 0 SC= MMONT ( ON TARGET )
; NC= MMTHK ( THINKING )
; NC= MMSTP ( STOPPED )
; NC= MMINC ( IN CHAMBER )
; NC= MMWLK ( WALKING )
; NC= MMSCU DROP ( SCURRYING )
; -->
; end of ( MONSTER STATE VARIABLE ) !!

; { BLOCK 0198 }
; ( WRITE PROTECTED ROTO GAME VARIABLES )
; XC? NOT IFTRUE
;  BV= #PLA ( # OF PLAYERS 0= 1 PL, 1= 2 PL )
;  BV= plup ( PLAYER UP 0 = PL 1, 1 = PL 2 )
;  BV= botha ( BOTH PLAYERS ACTIVE FLAG )
;
;  SUBR nerd+
;   plup LDA,
;   A ANA,
;   RZ,
;   H INX,
;   RET,
;
; nerd+ does "ADD 1 to HL if plup (PLayer-1 UP) is 1 for P2" routine
; !! has assembler directives !!
L071E:  LD      A,($E399)       ; plup read ( PLayer-1 UP ) Byte-Variable in High WRITE-protected NV RAM
        AND     A
        RET     Z
        INC     HL
        RET

;  CODE NERDUP
;   plup LDA,
;   1 ANI,
;   A L MOV,
;   0 H MVI,
;   H PUSH,
;  NEXT
;
; NERDUP does "TEST bit 0 of plup (PLayer-1 UP) and PUSH 0 = PL 1, 1 = PL 2" from TERSE
L0725:  LD      A,($E399)       ; plup read ( PLayer-1 UP ) Byte-Variable in High WRITE-protected NV RAM
        AND     $01
        LD      L,A
        LD      H,$00
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; !! some TERSE Forth _source_ CODE (between ASCII colon and semi-colon) !!
;
;  V= sc1l V= sc1h ( PLAYER 1 SCORE LO AND HI )
;  V= sc2l V= sc2h ( PLAYER 2 SCORE LO AND HI )
;  2 A= g#m : GA# NERDUP g#m ; ( GAME # FOR EACH PLAYER )
;
;  GA# does "get GAme # for CURRENT player"
L0730:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ;
        DW      L00D8           ; g#m "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E38C           ; for ( GaMe # ) 2-Byte Array base in High WRITE-protected NV RAM
        ;
        DW      L00B0           ; ... TerseRETurn

;  2 BA= ma# : MA# NERDUP ma# ; ( MAGICS LEFT FOR EACH PLAYER )
;
; MA# does "get MAgics left for CURRENT player"
L0739:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ;
        DW      L00CD           ; ma# "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E38A           ; for ( MAgics left ) 2-Byte Array base in High WRITE-protected NV RAM
        ;
        DW      L00B0           ; ... TerseRETurn

;  2 BA= rr# : RR# NERDUP rr# ; ( ROTOS LEFT FOR EACH PLAYER )
;
; RR# does "get Robby Rotos left for CURRENT player"
L0742:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ;
        DW      L00CD           ; rr# "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E388           ; for ( Robby Rotos left ) 2-Byte Array base in High WRITE-protected NV RAM
        ;
        DW      L00B0           ; ... TerseRETurn

;  2 BA= sc* : SC* NERDUP sc* ; ( SCORE MULT FOR EACH PLAYER )
; IFEND
; -->
;
; SC* does "get SCore MULT for CURRENT player"
L074B:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ;
        DW      L00CD           ; sc* "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E386           ; for ( SCore MULT ) 2-Byte Array base in High WRITE-protected NV RAM
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0198 } !!

; { BLOCK 0051 }
; ( THESE FOLKS ARE TACKED ON AT END )
; XC? NOT IFTRUE
;  2 BA= tr# : TR# NERDUP tr# ; ( TREASURE POINTER )
;
; TR# does "get TReasure pointer for CURRENT player"
L0754:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ;
        DW      L00CD           ; tr# "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E384           ; for ( TReasure pointer ) 2-Byte Array base in High WRITE-protected NV RAM ??
        ;
        DW      L00B0           ; ... TerseRETurn

;  2 BA= mh# : MH# NERDUP mh# ; ( MAX HOSTAGES FREED )
;
; MH# does "get Max Hostages FREED by CURRENT player"
L075D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ;
        DW      L00CD           ; mh# "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E382           ; for ( Max Hostages freed ) 2-Byte Array base in High WRITE-protected NV RAM
        ;
        DW      L00B0           ; ... TerseRETurn

;  BV= DIF ( DIFFICULTY FACTOR )
;  BV= GAMEOVER
;

; these 7 Write-Protect entries are SCRAMBLED below !!
;
;  : WPB! B! ; : WP! ! ;
;  : 1+WPB! 1+B! ; : 1-WPB! 1-B! ;
;  : WPZERO ZERO ; : WPBONE BONE ; : WPBZERO BZERO ; IFEND
; -->
;
; end of { BLOCK 0051 } !!

; anuther WORD Pusher ??
L0766:  RST     $20             ; do "(SP)->HL, (HL)->DE->(SP)" !!
        DW      $E37F           ; point to ?? in High WRITE-protected NV RAM ??
; end of Terse for a while ??

; Wait until INTERRUPTs Finished subroutine
L0769:  EXX
        POP     HL
; loop until no background transitions
L076B:  LD      A,I             ; read Background register
        PUSH    AF
        POP     DE
        LD      A,I             ; read Background register again
        XOR     D
        BIT     2,A             ; is ?? changed ?
        JR      NZ,L076B                ; (-$0b) loop if yes
        PUSH    DE
        PUSH    HL
        EXX
        DI                      ; Disable Interrupts
        RET

; ?? does "SUBtract 512 from HL" subroutine
L077B:  PUSH    DE
        OR      A
        LD      DE,$0200        ; minus 512 for write-protected NV-RAM ??
        SBC     HL,DE
        POP     DE
; borrowed for Indexed RETurn
L0783:  RET

; ?? does "write the Word in DE to WRITE-protected NVRAM"
L0784:  LD      A,$A5           ; 10100101B (secret FIXME byte or ...)
        OUT     (UNLOCK),A      ; &(91)=165 to enable Write to protected memory
        LD      (HL),E
        INC     HL
        OUT     (UNLOCK),A      ; &(91)=165 to enable Write to protected memory again
        LD      (HL),D
        RET

; ?? does "Write the Byte in E to WRITE-protected NVRAM"
L078E:  LD      A,$A5           ; 10100101B (... is FIXME the name of these routines ??)
        OUT     (UNLOCK),A      ; &(91)=165 to enable Write to protected memory
        LD      (HL),E
        RET

; write to High and Low-1 WORD in NVRAM subroutine (mis-aligned for Test ??)
L0794:  CALL    L0769           ; do Wait until Interrupts finish
        PUSH    HL
        CALL    L0784           ; ?? do "Write a Word to WRITE-protected NVRAM"
        DEC     HL
        CALL    L077B           ; ?? do "SUBtract 512 from HL"
        CALL    L0784           ; ?? do "Write a Word to WRITE-protected NVRAM"
        POP     HL
        POP     AF
        JP      PO,L07A8        ; if ?? skip re-Enable Interrupts
        EI
L07A8:  RET

; write to High and Low BYTE in WRITE-protected NVRAM subroutine
L07A9:  CALL    L0769           ; do Wait until Interrupts finish
        PUSH    HL
        CALL    L078E           ; ?? do "Write a Byte to WRITE-protected NVRAM"
        CALL    L077B           ; ?? do "SUBtract 512 from HL"
        CALL    L078E           ; ?? do "Write a Byte to WRITE-protected NVRAM"
        POP     HL
        POP     AF
        JP      PO,L07BC        ; if ?? skip re-Enable Interrupts
        EI
L07BC:  RET

; TERSE WPB! does "write BYTE in (SP+2) into (SP) & (SP)-512 WRITE-protected"
L07BD:  POP     HL
        POP     DE
; fall into ... common entry point
; with E = 1 or (SP+2) POP HL then E = 0, (HL)-1, or (HL)+1
L07BF:  CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        JP      (IY)            ; indexed RETurn

; TERSE WPBONE does "write BYTE 1 into (SP) & (SP)-512 WRITE-protected"
L07C4:  POP     HL
; write a 1 to High and Low in WRITE-protected NVRAM subroutine
L07C5:  LD      E,$01
        JR      L07BF                   ; (-$0a) to common entry point

; TERSE WPBZERO does "write BYTE 0 into (SP) WRITE-protected"
L07C9:  POP     HL
        LD      E,$00
        JR      L07BF                   ; (-$0f) to common entry

; TERSE 1-WPB! does "DECREMENT Byte in (SP) WRITE-protected"
L07CE:  POP     HL
        LD      E,(HL)
        DEC     E
        JR      L07BF                   ; (-$14) to common point

; TERSE 1+WPB! does "INCREMENT Byte in (SP) WRITE-protected"
L07D3:  POP     HL
        LD      E,(HL)
        INC     E
        JR      L07BF                   ; (-$19) to common

; TERSE WP! does "write WORD in (SP+2) into (SP) & (SP)-513 WRITE-protected"
L07D8:  POP     HL
        POP     DE
; fall into ... or entry point
; with E = 0 or (SP+2) then POP HL
L07DA:  CALL    L0794           ; do Write WORD to High and Low-1 in WRITE-protected NVRAM
        JP      (IY)            ; indexed RETurn

; TERSE WPZERO does "write WORD 0 into (SP) & (SP)-512 WRITE-protected"
L07DF:  POP     HL
        LD      DE,$0000        ; 0 for ??
        JR      L07DA                   ; (-$0b) to entry point

; ?? does TERSE copy BYTES count (SP+4) in (SP+2) into (SP) WRITE-protected
L07E5:  EXX
        POP     BC
        POP     HL
        POP     DE
L07E9:  LD      A,(DE)
        INC     DE
        PUSH    DE
        LD      E,A
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        POP     DE
        CPI
        JP      PE,L07E9        ; to loop until ??
        EXX
        JP      (IY)            ; indexed RETurn

; Service Mode options "Restored to Factory Recommended settings"
L07F9:  PUSH    IY              ; store Indexed RETurn address
        LD      IY,L0783        ; point to actual RETurn while in here
        LD      HL,$E3F1        ; point to Word PER COIN Slot 1 in High NV RAM
        CALL    L07C5           ; do Write a 1 to High and Low WRITE-protected NVRAM
        LD      HL,$E3F0        ; point to Word CREDITS / Slot 1 in NV RAM
        CALL    L07C5           ; do Write a 1 to High and Low WRITE-protected NVRAM
        LD      HL,$E3ED        ; point to Word PER COIN Slot 2 in NV RAM
        CALL    L07C5           ; do Write a 1 to High and Low WRITE-protected NVRAM
        LD      HL,$E3EC        ; point to Word CREDITS / Slot 2 in NV RAM
        CALL    L07C5           ; do Write a 1 to High and Low WRITE-protected NVRAM
        LD      DE,$0100        ; 256 for ??
        LD      HL,$E3F2        ; point to Word for ?? Slot 1 in NV RAM
        CALL    L0794           ; do Write WORD to High and Low-1 WRITE-protected NVRAM
        LD      HL,$E3EE        ; point to Word for ?? Slot 2 in NV RAM
        CALL    L0794           ; do Write WORD to High and Low-1 WRITE-protected NVRAM
        LD      DE,$F00F        ; point to Word for ?? in Static RAM
        LD      HL,$E37F        ; point to Word ?? for ?? in WRITE-protected High NV RAM
        CALL    L0794           ; do Write WORD to High and Low-1 WRITE-protected NVRAM
        IN      A,(SW0)         ; inport =&(16) Control Port
        LD      E,A
        LD      HL,$E3F4        ; point to Word ?? for ?? in NV RAM
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        LD      E,$03           ; to reset default DIFFiculty
        LD      HL,$E3EB        ; point to Byte-Variable "DIFficulty factor" in High WRITE-protected NV RAM
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        POP     IY              ; restore Indexed RETurn address
        RET

; write Two pairs of 0's then a pair of 1's (why ??) into WRITE-protected NV-RAM
L0843:  LD      HL,$E3FC        ; RESTART? point to "0, 1, 2 counter for RESTART"
        LD      E,$00
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        LD      HL,$E3F9        ; point to ?? (for ??)
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        LD      HL,$E3FF        ; GAMEOVER point to "GAME OVER" (disallows Volume changes and ??)
        INC     E
        JP      L07A9           ; to Write BYTE to High and Low WRITE-protected NVRAM

; TERSE Forth GO-SET ?? from TERSE
L0858:  CALL    L0843           ; do Two pairs of 0's then a pair of 1's in NV-RAM
        JP      (IY)            ; indexed RETurn

; test Option switches here (and RESET if done with SELF-TEST ??)
L085D:  DI
        PUSH    BC
        IN      A,(SW3)         ; =&(19) for SWitch bank 3 for Option DIP switches
        BIT     NVRAM,A         ; test bit 0 for Keep Non-volitible RAM ?
        JP      Z,L08D6
; else feel free to do Full Reset
L0866:  LD      HL,($E37F)      ; read Word ?? for ?? in High WRITE-protected NV RAM
        LD      DE,$F00F        ; point to Word for ?? in Static RAM
        OR      A
        SBC     HL,DE
        JP      NZ,L08D6        ; also skip Full Reset if ??
; Full Reset begins here
        IN      A,(SW0)         ; inport =&(16) Control Port (ignored ??)
        LD      HL,$0000        ; clear ERROR count
        EXX
        LD      BC,$0200        ; for 512 bytes (quarter of x21) an 8416-20
        LD      HL,$E200        ; point to High NVRAM (WRITE-protected !!)
        LD      DE,$E000        ; point DE at Low NVRAM (WRITE-protected !!)
; loop here for ??
L0881:  LD      A,(DE)
        CP      (HL)            ; ComPare each byte in Low and High
        JR      Z,L088E                 ; (+$09) if a match
        EXX
        INC     HL              ; Error count + 1
        EXX
; write Byte in (HL) to DE in WRITE-protected NVRAM
        LD      A,$A5           ; 10100101B (FIXME byte to UNLOCK OUTport)
        OUT     (UNLOCK),A      ; &(91)=165 to enable Write to protected memory
        LD      A,(HL)
        LD      (DE),A          ; Read HIGH and Write LOW with LOCK Off
L088E:  INC     DE
        CPI                     ; ComPare and Increment ??
        JP      PE,L0881        ; loop if ??
        EXX
        IN      A,(SW0)         ; inport =&(16) Control Port
        OR      A
        LD      DE,$0002        ; 2 for ??
        SBC     HL,DE
        JR      NC,L08CB                ; (+$2c) to bypass ?? if ??
        LD      BC,$01FF        ; for 511 bytes in WRITE-protected x21
        LD      DE,$0000        ; clear ERROR ?? count
        LD      HL,$E001        ; point to Low WRITE-protected NVRAM+1
        EXX
        LD      DE,$E000        ; point DE at Low WRITE-protected NVRAM
; next location
L08AC:  EXX
        PUSH    HL
        EXX
        POP     HL
        PUSH    HL
        OR      A
        SBC     HL,DE
        LD      C,L
        LD      B,H
        POP     HL
        LD      A,(HL)
        DEC     HL
        CPDR
        JR      Z,L08C0                 ; (+$03) if ?? matches
        EXX
        INC     DE              ; ?? count + 1
        EXX
; here if ?? matches
L08C0:  EXX
        CPI
        EXX
        JP      PE,L08AC        ; to next location if ??
        EXX
        EX      DE,HL
        JR      L08CE                   ; (+$03)

; bypass ??
L08CB:  LD      HL,$0000        ; 0 for ??
L08CE:  LD      DE,$0004        ; 4 for ??
        OR      A
        SBC     HL,DE
        JR      NC,L08FA                ; (+$24) to ?? if ??
; skip to here if Keep NVRAM was 0
L08D6:  IN      A,(SW0)         ; inport =&(16) Control Port
        LD      BC,$0400        ; check 1K bytes of Low AND High x21 (8416 - 20 Low Power)
        LD      HL,$E000        ; starting at base of WRITE-protected NV RAM
        LD      A,$A5           ; 10100101B (FIXME byte to UNLOCK OUTport)
; loop here for ?? clear WRITE-protected x21 NV RAM
L08E0:  OUT     (UNLOCK),A      ; &(91)=165 to enable write to protected memory
        LD      (HL),$00
        CPI
        JP      PE,L08E0        ; loop until BC = 0 or ??
        LD      HL,$E3FB        ; point to Word ?? for ?? in High WRITE-protected NV RAM ??
        LD      E,$01
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        CALL    L0843           ; do Two pairs of 0's then a pair of 1's
        CALL    L07F9           ; do Reset On-screen "Service Mode" options
        JP      L0866                   ; not JR ?? to Full Reset

; on ??
L08FA:  IN      A,(SW0)         ; inport =&(16) Control Port, then ignore it ??
        IN      A,(SW3)         ; =&(19) for SWitch bank 3 for Option DIP switches
        BIT     USESM,A         ; is bit 1 USE Service mode On
        JR      NZ,L0905                ; (+$03) if yes, else ...
        CALL    L07F9           ; do Reset "Service Mode" options if Off
L0905:  LD      A,($E3FF)       ; GAMEOVER read "GAME OVER" (disallows ??) in High WRITE-protected NV-RAM
        OR      A
        JR      NZ,L091F                ; (+$14)
        LD      HL,$E3FC        ; RESTART? point to "0, 1, 2 counter for RESTART"
        LD      A,(HL)
        INC     A
        LD      E,A
        CP      $03
        JR      NZ,L091C                ; (+$07)
        PUSH    HL
        CALL    L0843           ; do Two pairs of 0's then a pair of 1's
        LD      E,$00
        POP     HL
L091C:  CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
L091F:  LD      HL,$E3F4        ; point to Word ?? for ?? in High WRITE-protected NV RAM
        LD      C,$10           ; can only be SW0 ?? why do it this way ??
        IN      E,(C)           ; =&(16) for SWitch bank 0 for Game controls
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        POP     BC
        JP      (IY)            ; indexed RETurn

; ?? does read Game control SWitches (NOT saved for TERSE to use ??)
L092C:  IN      A,(SW0)         ; inport =&(16) Control Port
        JP      (IY)            ; indexed RETurn
;
;*****************************************************************************
;
; here is SELF-TEST support code for Service mode at L0C99:
;
;*****************************************************************************
; ?? does SETUP offset to Full-Scale Y location from TOP of Screen
L0930:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0300           ; for 768 offset
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF14           ; for Full-Scale Y location = offset
        ;
        DW      L02BB           ; do "Pop HL, Pop DE, ADD DE to (HL) word"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does SETUP offset to Full-Scale X location from LEFT Side of Screen
L093D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $05A0           ; for 1440 offset
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF16           ; for Full-Scale X location = offset
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn


; ?? does SET UP offsets to both X and Y Full-Scale locations
L094A:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L093D           ; do SETUP offset to Full-Scale X location
        ;
        DW      L0930           ; do SETUP offset to Full-Scale Y location
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does CLEAR both X and Y Full-Scale location
L0951:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF14           ; for Full-Scale Y location = 0
        ;
        DW      L0133           ; ZERO do "Pop HL, word 00->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF16           ; for Full-Scale X location = 0
        ;
        DW      L0133           ; ZERO do "Pop HL, word 00->(HL)"
        ;
        DW      L094A           ; do SETUP offsets to both X and Y Full-Scale locations
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does find a Byte 0 ONSCREEN then ZERO Full-Scale X and Y locations
L0962:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0569           ; TerseFILL byte 0 from NORMEM while Size of NORMEM
        ;
        DW      L0951           ; do CLEAR both X and Y Full-Scale locations
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does Print a Character (in SELF-Test mode !!)
L0969:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF16           ; for Full-Scale X location = 0 to 20480
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $4760           ; 18272 for ?? in Screen RAM
        ;
        DW      L01B0           ; do "Pop DE, Pop HL, Push F for Greater Than or T for Less or Equal"
        ; IF False #1 skip
        DW      L03CD,L097C     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L094A           ; do SETUP offsets to both X and Y Full-Scale locations
        ; THEN #1
L097C:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF14           ; for Full-Scale Y location = 0 to 13056
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $2C00           ; 11264 for ??
        ;
        DW      L01B0           ; do "Pop DE, Pop HL, Push F for Greater Than or T for Less or Equal"
        ; IF False #2 skip
        DW      L03CD,L098E     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0962           ; find a Byte 0 ONSCREEN then ZERO Full-Scale X and Y locations
        ; THEN #2
L098E:  DW      L06C5
        ;
        DW      L06FA           ; do Prepare and DRAW Image (only from here ??)
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $02D0           ; 720 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF16           ; for Full-Scale X location = 0 to 20480
        ;
        DW      L02BB           ; do "Pop HL, Pop DE, ADD DE to (HL) word"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does Print Text String
; note: Top of System Stack points to Length, followed by Length number of Characters
L099E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0188           ; do "INC Top of System stack, then make a BYTE ABSolute"
        ;
        DW      L02B4           ; do "Push a copy of Second from Top word of System stack"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM" for TO value
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack" for START was at BC
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L092C           ; read Game control SWitches (NOT saved !!)
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack" next BC
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0969           ; TerseCALL "Print a Character" indexed by current BC
        ; TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does PRINT a NUMBER (SP) + $30
L09B5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0519           ; 48 "BYTE Pusher" for ASCII Numbers base ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0969           ; TerseCALL "Print a Character"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "check for START 1 and START 2 buttons BOTH pressed (Active LOWS !!)""
L09BE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0511           ; 16 "BYTE Pusher" for =&(16) aka Game SW0 read
        ;
        DW      L02E3           ; INP do "Pop BC, INPort L,(C) byte, Push 0,L word"
        ;
        DW      L0509           ; 96 "BYTE Pusher" to MASK bits 5 and 6 ??
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ?? IDLE until START 1 and START 2 buttons are BOTH pressed
L09CB:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ; BEGIN loop at this label
L09CC:  DW      L09BE           ; ?? do "check for START 1 and START 2 buttons BOTH pressed"
        ; END if True, or loop to BEGIN forever
        DW      L03CD,L09CC     ; ConditionalJUMP "while START 1 or START 2 NOT pressed"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does Draw a HORIZontal GRIDLINE across Screen for Self-test #8
L09D4:  EXX
        LD      A,$FF           ; FILL byte 11111111B
        POP     DE
        LD      HL,$0000        ; 0 for ??
        ADD     HL,DE
        LD      (HL),A          ; write -1 into (DE)
        INC     DE
        LD      BC,$0050        ; 80 for Byte Count (should be only 79 ??)
        LDIR                    ; (DE+1)=(DE) repeat 80 times
        DEC     DE
        PUSH    DE              ; store DE + 80 (BPLINE) for next Line
        EXX
        JP      (IY)

; ?? does DRAW a Scanline of PIXELs for GRID uprights
L09E8:  EXX
        POP     HL
        LD      A,$C0           ; for LEFT Pixel in Color 3
        LD      B,$10           ; for 16 blocks left-to-right
L09EE:  LD      (HL),A          ; load 192 into 16 blocks for ?? ...
        LD      DE,$0005        ; quantum 5 (should be outside of loop)
        ADD     HL,DE
        DJNZ    L09EE                   ; (-$07)
        DEC     HL
        LD      A,$03           ; ... and 3 into end of last (NARROW !!) block
        LD      (HL),A          ; for RIGHT Pixel in Color 3
        INC     HL
        PUSH    HL              ; store HL + 80 for next SCANline
        EXX
        JP      (IY)

; ?? does TEST of 4K Robby Roto ROM starting at address in Top of System stack
L09FE:  POP     HL
        PUSH    BC              ; store TERSE PC (during test)
        JP      L006E           ; to Test HL ROM (or Top 1K of Static RAM ??)

; ?? does RAM TEST of (SP) in (SP+2) byte count (SP+4) returns pointer in (SP)
L0A03:  POP     DE              ; read the BYTE to WRITE then CHECK for
        LD      A,E
        POP     HL              ; starting at HL
        POP     DE
        PUSH    BC              ; store TERSE PC
        PUSH    DE
        POP     BC              ; Byte Count
        LD      DE,$0000        ; 0 for ?? ERRORS
L0A0D:  LD      (HL),A          ; RAM TEST loop here
        CPI                     ; is CELL correct ?
        JR      Z,L0A13                 ; (+$01) if OK
        INC     DE              ; else count up BAD locations
L0A13:  JP      PE,L0A0D        ; until BC underflows
        POP     BC              ; restore TERSE PC
        PUSH    DE              ; number of ERRORS found (0 = NONE)
        JP      (IY)

; ?? does ?? show SELF-TEST #1 result for SCREEN RAM test (if BAD)
L0A1A:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ; IF False skip
        DW      L03CD,L0A28     ; ConditionalJUMP to TerseRETurn IF "Top of System stack is Zero"
        ;
        DW      L03E7           ; A" do Terse SKIP RELative by next Byte (counts
        DB      $04,"BAD "      ; over) $42,$41,$44,$20" as embedded Text String
        ;
        DW      L099E           ; TerseCALL "Print Text String"
        ; THEN skip to here
L0A28:  DW      L00B0           ; ... TerseRETurn

; ?? does 1 pass of SELF-TEST #1 for SCREEN RAMS (BOUNCING "curtain" !!)
; AND does 4 passes of SELF-TEST #3 for NON-Protected Static RAMS (Top of x21 to x24)
L0A2A:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack" for bit 0 set
        ;
        DW      L047B           ; do "Push old Saved SP, save SP as new, then SUBtract 2"
        ;
        DW      L04BE           ; do "read Saved SP, SUBtract 2 then Push for ??"
        ;
        DW      L0133           ; ZERO do "Pop HL, word 00->(HL)"
        ;
        DW      L04FB           ; 9 "BYTE Pusher" for loop TO value (9 to CLEAR)
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for loop START
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value) from 0 to 9
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L04E8           ; do "read Saved SP, ADD 6 then Push (HL) for ??"
        ;
        DW      L04E2           ; do "read Saved SP, ADD 4 then Push (HL) for ??"
        ;
        DW      L04DC           ; do "read Saved SP, ADD 2 then Push (HL) for ??"
        ;
        DW      L0A03           ; do "RAM TEST of (SP) in (SP+2) byte count (SP+4) ??"
        ;
        DW      L04BE           ; do "read Saved SP, SUBtract 2 then Push for ??"
        ;
        DW      L02BB           ; do "Pop HL, Pop DE, ADD DE to (HL) word"
        ;
        DW      L092C           ; read Game control SWitches (NOT saved !!)
        ;
        DW      L04DC           ; do "read Saved SP, ADD 2 then Push (HL) for ??"
        ;
        DW      L016B           ; 2* do "Double Top of System stack" for next bit set
        ;
        DW      L04AD           ; do "read Saved SP, ADD 2 then Push for ??"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ; TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" to clear RAM on $0100
        ;
        DW      L04D2           ; do "read Saved SP, SUBtract 2 then Push (HL) for ??"
        ;
        DW      L04B9           ; do "read Saved SP, ADD 6 then Push for ??"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L049C           ; do "restore Saved SP, ZERO old SP, then ADD 4"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does DISPLAY a SPACE CHARacter
L0A5B:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L051F           ; 32 "BYTE Pusher" for ??
        ;
        DW      L0969           ; TerseCALL "Print a Character"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does MULTIPLE reads of Game control SWitches (for (SP) loops TIME DELAY)
L0A62:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for FROM
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L092C           ; read Game control SWitches (NOT saved !!)
        ; TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does make changes to a SETTING Number while in SELF-TEST #7 (with looping !!)
L0A6D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF16           ; for Full-Scale X location = 0 to 20480
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L0471           ; do "Push old Saved SP, Save SP as new"
        ; BEGIN loop at label
L0A76:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $0300           ; 768 for a 1 secund delay ??
        ;
        DW      L0A62           ; do MULTIPLE reads of Game control SWitches
        ;
        DW      L04DC           ; do "read Saved SP, ADD 2 then Push (HL) for ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF16           ; for Full-Scale X location = 0 to 20480
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L0523           ; 18 "BYTE Pusher" for =&(18) aka SW2 Player 1 read
        ;
        DW      L02E3           ; INP do "Pop BC, INPort L,(C) byte, Push 0,L word"
        ;
        DW      L00E9           ; DUP do "DUPlicate Top of System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack" for UNDERFLOW to 0
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; _IF False #1 to THEN #1
        DW      L03CD,L0AAA     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L04E8           ; do "read Saved SP, ADD 6 then Push (HL) for ??"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L00E9           ; DUP do "DUPlicate Top of System stack"
        ;
        DW      L04FB           ; 9 "BYTE Pusher" to check for OVERFLOW to 10
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ; __IF False #2 skip
        DW      L03CD,L0AA6     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; __THEN #2
L0AA6:  DW      L04B9           ; do "read Saved SP, ADD 6 then Push for ??"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ; _THEN #1
L0AAA:  DW      L04ED           ; 2 "BYTE Pusher"
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; _IF False #3 to THEN #3
        DW      L03CD,L0ACA     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L04E8           ; do "read Saved SP, ADD 6 then Push (HL) for ??"
        ;
        DW      L0155           ; 1- do "DECrement Top of System stack"
        ;
        DW      L00E9           ; DUP do "DUPlicate Top of System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack" to ROLL OVER to 1
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; __IF False #4 skip
        DW      L03CD,L0AC6     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L04FB           ; 9 "BYTE Pusher" to ROLL UNDER to 9
        ; __THEN #4
L0AC6:  DW      L04B9           ; do "read Saved SP, ADD 6 then Push for ??"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ; _THEN #3
L0ACA:  DW      L04E8           ; do "read Saved SP, ADD 6 then Push (HL) for ??"
        ;
        DW      L09B5           ; do PRINT a NUMBER (SP) + $30
        ;
        DW      L0A5B           ; do DISPLAY a SPACE CHARacter
        ;
        DW      L0511           ; 16 "BYTE Pusher" for =&(16) aka Game SW0 read
        ;
        DW      L02E3           ; INP do "Pop BC, INPort L,(C) byte, Push 0,L word"
        ;
        DW      L051D           ; 255 "BYTE Pusher" to make all inputs ACTIVE High
        ;
        DW      L0236           ; XOR do "word (SP) XOR (SP+2)"
        ;
        DW      L0509           ; 96 "BYTE Pusher" to MASK bits 5 and 6 (START buttons)
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)" for P1 and P2
        ;
        DW      L04E2           ; do "read Saved SP, ADD 4 then Push (HL) for ??"
        ; _IF False #5 skip
        DW      L03CD,L0AE6     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0509           ; 96 "BYTE Pusher" to CHECK GAME SW0 bits 5 and 6
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; _THEN #5
L0AE6:  DW      L0217           ; -DUP do "DUPlicate Top of System stack IF Not Zero"
        ; END or loop to BEGIN if False
        DW      L03CD,L0A76     ; ConditionalJUMP "while NEITHER P1 or P2 START pressed"
        ;
        DW      L04B3           ; do "read Saved SP, ADD 4 then Push for ??"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L0497           ; do "restore Saved SP, ZERO old SP, then ADD 2"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does TerseCALL Print Text String "CO/CR DOOR"
L0AF4:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L03E7           ; A" do Terse SKIP RELative by next Byte (counts
L0AF7:  DB      $0A,"CO/CR DOOR" ; over) an embedded Text String"
        ; Skip to here ??
        DW      L099E           ; TerseCALL "Print Text String"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does set COins per CRedit in SELF-TEST #7
L0B06:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0AF4           ; do Print "CO/CR DOOR" Text String
        ;
        DW      L09B5           ; do PRINT a NUMBER (SP) + $30
        ;
        DW      L0480           ; do "Push old Saved SP, save SP as new, then SUBtract 4"
        ;
        DW      L0A5B           ; do DISPLAY a SPACE CHARacter
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF16           ; for Full-Scale X location = 0 to 20480
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L04BE           ; do "read Saved SP, SUBtract 2 then Push for ??"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L04DC           ; do "read Saved SP, ADD 2 then Push (HL) for ??"
        ;
        DW      L09B5           ; do PRINT a NUMBER (SP) + $30
        ;
        DW      L03E7           ; A" do Terse SKIP RELative by next Byte (counts
        DB      $03," / "       ; over) $20,$2F,$20" as in-line Text String
        ; to here  ??
        DW      L099E           ; TerseCALL "Print Text String"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF16           ; for Full-Scale X location = 0 to 20480
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L04C3           ; do "read Saved SP, SUBtract 4 then Push for ??"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L04E2           ; do "read Saved SP, ADD 4 then Push (HL) for ??"
        ;
        DW      L09B5           ; do PRINT a NUMBER (SP) + $30
        ;
        DW      L051F           ; 32 "BYTE Pusher" for ??
        ; BEGIN loop here
L0B35:  DW      L051F           ; 32 "BYTE Pusher"  for ??
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ; _IF False to ELSE instead
        DW      L03CD,L0B47     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L04AD           ; do "read Saved SP, ADD 2 then Push for ??"
        ;
        DW      L04DC           ; do "read Saved SP, ADD 2 then Push (HL) for ??"
        ;
        DW      L04D2           ; do "read Saved SP, SUBtract 2 then Push (HL) for ??"
        ; _done with IF so Jump to THEN
        DW      L03C5,L0B4D     ; TerseJUMP to ??
        ; _ELSE instead
L0B47:  DW      L04B3           ; do "read Saved SP, ADD 4 then Push for ??"
        ;
        DW      L04E2           ; do "read Saved SP, ADD 4 then Push (HL) for ??"
        ;
        DW      L04D7           ; do "read Saved SP, SUBtract 4 then Push (HL) for ??"
        ; _THEN carry on either way
L0B4D:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF16           ; for Full-Scale X location = 0 to 20480
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L0A6D           ; make changes to a SETTING Number until EITHER START pressed
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L02ED           ; ROT do "Pop DE, Pop HL, EX (SP),HL then Push DE, Push (Old SP) to New System stack"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00E9           ; DUP do "DUPlicate Top of System stack"
        ;
        DW      L0509           ; 96 "BYTE Pusher" to TEST GAME SW0 bits 5 and 6
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; END or loop to BEGIN if False
        DW      L03CD,L0B35     ; ConditionalJUMP "if P1 or P2 START pressed (but NOT both !!)"
        ;
        DW      L0492           ; do "restore Saved SP, ZERO old SP"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does save COins per CRedit for DOOR1 or DOOR2
L0B6B:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00EE           ; 2DUP do "duplicate top 2 Words of System stack"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L02D4           ; SWAB do "SWAp Bytes in Top word of System stack"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L031E           ; /MOD do "word (SP+2) DIVided by (SP), Push REMAINDER, Push QUOTIENT"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ; IF False skip
        DW      L03CD,L0B7E     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ; THEN label
L0B7E:  DW      L00B0           ; ... TerseRETurn

; ?? does DRAW a 1 followed by a SPACE CHARacter
L0B80:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0515           ; 49 "BYTE Pusher" for ??
        ;
        DW      L0969           ; TerseCALL "Print a Character"
        ;
        DW      L0A5B           ; do DISPLAY a SPACE CHARacter
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does DRAW a 0 NUMBER CHARacter
L0B89:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0519           ; 48 "BYTE Pusher" for ??
        ;
        DW      L0969           ; TerseCALL "Print a Character"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does in SELF-TEST #7 overDRAW old "1" with "0" then DRAW a "1" under it
L0B90:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L093D           ; do ADD offset to Full-Scale X location
        ;
        DW      L0B89           ; do DRAW a 0 NUMBER CHARacter
        ;
        DW      L094A           ; do SETUP offsets to both X and Y Full-Scale locations
        ;
        DW      L0B80           ; do DRAW a 1 and a SPACE CHARacter
        ;
        DW      L00B0           ; ... TerseRETurn

; FULL RESET ?? un-known
L0B9B:  RST     $00             ; !! ReSTart 0 !!

; 13 byte OUTport before Screen Memory TEST table
L0B9C:  DB      $00             ; index 0 = 0 for BLACK in COL0R
        DB      $03             ; index 1 = 3 for Dark GRAY in COL1R
        DB      $05             ; index 2 = 5 for Light GRAY in COL2R
        DB      $07             ; index 3 = 7 for WHITE in COL3R (nice Grayscale !!)
        ;
        DB      $00             ; index 4 = 0 for BLACK in COL0L (becomes GREEN in 9)
        DB      $4A             ; index 5 = 74 for RED in COL1L
        DB      $FA             ; index 6 = 250 for BLUE in COL2L
        DB      $7E             ; index 7 = 126 for YELLOW in COL3L
        ;
        DB      $01             ; index 8 = 1 for CONCM (COMmercial mode ON) !!
        DB      $00             ; index 9 = 0 for HORCB (HORizontal Color Boundary)
        DB      $C9             ; index 10 = 201 for VERBL ?? Not a RET ??
        DB      $00             ; index 11 = 0 for COLBX ?? COLor BloCK multi-port ??
        ;
        DB      $00             ; index 12 = 0 for MAGIC reset ??

; 8 byte table for SOUND to play in SELF-TEST #5
L0BA9:  DB      $40             ; index 0 = 64 for TONMO
        DB      $22             ; index 1 = 34 for TONEA
        DB      $44             ; index 2 = 68 for TONEB
        DB      $88             ; index 3 = 136 for TONEC
        DB      $00             ; index 4 = 0 for VIBRA OFF
        DB      $26             ; index 5 = 38 for VOLC at HALF VOLume (Noise Mode = $02)
        DB      $66             ; index 6 = 102 for VOLAB both at HALF VOLume
        DB      $00             ; index 7 = 0 for VOLN OFF

; ?? does initalize COLORS and CONTROL OUTports then zero all SOUNNDS
L0BB1:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack" for TO
        DB      $18             ; 24 for all the way up to SNDBX #1
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for START AT COL0R
        ; TerseDO Loop #1 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0501           ; 12 "BYTE Pusher" for only 12 OUTports ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      L0B9C           ; for 13 byte OUTport before Screen Memory TEST table
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ; TerseLOOP #1 back to TerseDO #1 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L092C           ; read Game control SWitches (NOT saved !!)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $58             ; 88 for TERSE Loop TO value ?? for SNDBX #2 OUTport ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 for TERSE Loop FROM value ?? for TONMO #2 OUTport ??
        ; TerseDO Loop #2 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; "TerseDO Loop begin" to ZERO second SOUND ports
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for data ??
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ; TerseLOOP #2 back to TerseDO #2 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L092C           ; read Game control SWitches (NOT saved !!)
        ;
        DW      L00B0           ; ... TerseRETurn

; WORD Pushers again ?? for Service mode ONLY !!
L0BE1:  RST     $20             ; do "(SP)->HL, (HL)->DE->(SP)" !!
        DW      $E17F           ; in Low WRITE-protected NV RAM
        ;
L0BE4:  RST     $20             ; do "(SP)->HL, (HL)->DE->(SP)" !!
        DW      $F00F           ; in NON-protected Static RAM ??
        ;
L0BE7:  RST     $20             ; do "(SP)->HL, (HL)->DE->(SP)" for "TOP Half of x21" !!
        DW      $E400           ; base of Battery-backed-up but NON-protected NV RAM
; end of WORD Pushers again ??

; ?? does a few GAME Controls and SERVICE Switch displays
L0BEA:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L02E3           ; INP do "Pop BC, INPort L,(C) byte, Push 0,L word"
        ;
        DW      L0930           ; do ADD offset to Full-Scale Y location
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $1900           ; 6400 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF16           ; for Full-Scale X location = 0 to 20480
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L016B           ; 2* do "Double Top of System stack"
        ;
        DW      L00E9           ; DUP do "DUPlicate Top of System stack"
        ;
        DW      L02D4           ; SWAB do "SWAp Bytes in Top word of System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L09B5           ; do PRINT a NUMBER (SP) + $30
        ; TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does SELF-TEST #4 for x2 to x4 ROM B, C, D checksums (x1 ROM A already tested !!)
; then does SELF-TEST #4 for x5 to x10 ROM E, F, G, H (no I), J, or K checksums
L0C11:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $1000           ; for 4096 ROM size times ROM number
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L09FE           ; TEST Robby Roto ROM starting at Pop HL (returns CheckSum ??)
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF00           ; for mask only HIGH address when finished (if an ERROR ??)
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)" (else ZERO ??)
        ; _IF False #1 to THEN #1
        DW      L03CD,L0C53     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00E9           ; DUP do "DUPlicate Top of System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" is still in first ROM Bank ??
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; __IF False #2 to ELSE #2
        DW      L03CD,L0C3B     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack" if loop = 1 to 3
        DB      $41             ; 65 for base ASCII Letter "A" on ERROR ?? in x2 to x4
        ; __(done so Jump to THEN #2)
        DW      L03C5,L0C4F     ; TerseJUMP to ??
        ; __ELSE #2
L0C3B:  DW      L00E9           ; DUP do "DUPlicate Top of System stack"
        ;
        DW      L04FF           ; 11 "BYTE Pusher" is in first 4 of second Bank ??
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ; ___IF False #3 to ELSE #3
        DW      L03CD,L0C4C     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack" if loop = 12 or 13
        DB      $3E             ; 62 for ??
        ; ___(done so Jump to THEN #3)
        DW      L03C5,L0C4F     ; TerseJUMP to ??
        ; ___ELSE #3
L0C4C:  DW      L00C5           ; do "pushBYTE to System stack" if loop = 8 to 11
        DB      $3D             ; 61 for base ASCII Symbol "=" on ERROR ?? in x5 to x8
        ; __THENs #2 and #3 combined
L0C4F:  DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM" to ADD loop to base
        ;
        DW      L0969           ; TerseCALL "Print a Character" (only IF error occured !!)
        ; _THEN #1
L0C53:  DW      L092C           ; read Game control SWitches (NOT saved !!)
        ; TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does DISPLAY SELF-TEST number "1 " to "9 " in Upper Left (or down a bit ??)
L0C59:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L00E9           ; DUP do "DUPlicate Top of System stack"
        ;
        DW      L09B5           ; do PRINT a NUMBER (SP) + $30
        ;
        DW      L0A5B           ; do DISPLAY a SPACE CHARacter
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does DISPLAY SELF-TEST identification "1 " up to "5 " in a column down
L0C64:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L094A           ; do SETUP offsets to both X and Y Full-Scale locations
        ;
        DW      L0C59           ; do DISPLAY SELF-TEST Number followed by a SPACE
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does show ERROR NUMBER for x21 SELF-TEST #2 only IF error occured (write protected)
L0C6B:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ; IF False skip
        DW      L03CD,L0C74     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00E9           ; DUP do "DUPlicate Top of System stack"
        ;
        DW      L09B5           ; do PRINT a NUMBER (SP) + $30
        ; THEN for next ERROR Number
L0C74:  DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does test ERROR condition for x21 SELF-TEST #2 and show if needed (write protected)
L0C78:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L0BE4           ; $F00F "WORD Pusher" (expected result !!)
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ;
        DW      L0C6B           ; show ERROR NUMBER for SELF-TEST #2 only IF error occured
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does show BAD RAM Socket for SELF-TEST #3 only IF error occured
L0C83:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ; IF False skip
        DW      L03CD,L0C95     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L03E7           ; A" do Terse SKIP RELative by next Byte (counts
        DB      $02,"X2"        ; 2 over) $58,$32" as in-line RAM Text String
        ;
        DW      L099E           ; TerseCALL "Print Text String"
        ;
        DW      L00E9           ; DUP do "DUPlicate Top of System stack"
        ;
        DW      L09B5           ; do PRINT a NUMBER (SP) + $30
        ;
        DW      L0A5B           ; do DISPLAY a SPACE CHARacter
        ; THEN for next RAM Socket Number
L0C95:  DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

;
; !! interesting !!
; from Service mode JumP address with BC pointing to 3 for ?? L0003 for START Game ??
;
; ?? does TEST Screen Memory (all PIXELS 0 to 3 with erase inbetween) then start TESTS
L0C99:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L085D           ; do test Option switches here
        ;
        DW      L092C           ; read Game control SWitches (NOT saved !!)
        ;
        DW      L0BB1           ; initalize first 13 CONTROL ports then zero all SOUNNDS
        ;
        DW      L0962           ; find a Byte 0 ONSCREEN then ZERO Full-Scale X and Y locations
        ;
        DW      L092C           ; read Game control SWitches (NOT saved !!)
        ;
        DW      L0535           ; 16384 (hex $4000) "WORD Pusher" for size of NORMEM
        ;
        DW      L0535           ; 16384 (hex $4000) "WORD Pusher" for NORMEM
        ;
        DW      L0A2A           ; do a pass of SELF-TEST #1 for SCREEN RAM (BOUNCING !!)
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for ??
        ;
        DW      L0C64           ; display SELF-TEST identification "1 " in a column down
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L0A1A           ; show SELF-TEST #1 result for SCREEN RAM test (if BAD)
        ;
        DW      L0C64           ; display SELF-TEST identification "2 " in a column down
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack" for ??
        ;
        DW      L0766           ; $E37F "WORD Pusher" (in High WRITE-protected NV RAM ??)
        ;
        DW      L07DF           ; WPZERO do "WRITE-protectedWORD 0" into (SP) & (SP)-513
        ;
        DW      L0766           ; $E37F "WORD Pusher" (in High WRITE-protected NV RAM)
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L0C6B           ; show ERROR NUMBER "1" if testram high did NOT set
        ;
        DW      L0BE1           ; $E17F "WORD Pusher" (in Low WRITE-protected NV RAM)
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L0C6B           ; show ERROR NUMBER "2" if testram low did NOT zero
        ;
        DW      L0BE4           ; $F00F "WORD Pusher" (11110000B, 00001111B word)
        ;
        DW      L0766           ; $E37F "WORD Pusher" (in High WRITE-protected NV RAM)
        ;
        DW      L07D8           ; WP! do "WRITE-protectedWORD" (SP+2) into (SP) & (SP)-513
        ;
        DW      L0766           ; $E37F "WORD Pusher" (in High WRITE-protected NV RAM)
        ;
        DW      L0C78           ; test ERROR condition "3" if testram high did NOT set
        ;
        DW      L0BE1           ; $E17F "WORD Pusher" (in Low WRITE-protected NV RAM)
        ;
        DW      L0C78           ; test ERROR condition "4" if testram low did NOT set
        ;
        DW      L0766           ; $E37F "WORD Pusher" (in High WRITE-protected NV RAM)
        ;
        DW      L0133           ; ZERO do "Pop HL, word 00->(HL)" WITHOUT Write Protection !!
        ;
        DW      L0766           ; $E37F "WORD Pusher" (in High WRITE-protected NV RAM)
        ;
        DW      L0C78           ; test ERROR condition "5" if zeroed and should NOT have ? WRONG ??
        ;
        DW      L0BE1           ; $E17F "WORD Pusher" (in Low WRITE-protected NV RAM)
        ;
        DW      L0133           ; ZERO do "Pop HL, word 00->(HL)" Write Protect is NOT Enabled
        ;
        DW      L0BE1           ; $E17F "WORD Pusher" (in Low WRITE-protected NV RAM)
        ;
        DW      L0C78           ; test ERROR condition "6" if zeroed and should NOT have ?
        ;
        DW      L0BE4           ; $F00F "WORD Pusher" (11110000B, 00001111B word)
        ;
        DW      L0BE7           ; $E400 "WORD Pusher" for "TOP Half of x21" (in NON-protected NV RAM)
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)" to set scratch RAM
        ;
        DW      L0BE7           ; $E400 "WORD Pusher" for "TOP Half of x21" (in NON-protected NV RAM)
        ;
        DW      L0C78           ; test ERROR condition "7" if scratch RAM did MOT set
        ;
        DW      L0BE7           ; $E400 "WORD Pusher" for "TOP Half of x21" (in NON-protected NV RAM)
        ;
        DW      L0133           ; ZERO do "Pop HL, word 00->(HL)" to zeru scratch(pad) RAM
        ;
        DW      L0BE7           ; $E400 "WORD Pusher" for "TOP Half of x21" (in NON-protected NV RAM)
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L0C6B           ; show ERROR NUMBER "8" if scratch RAM did MOT zero
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack" was a 1 for ??
        ;
        DW      L0C64           ; display SELF-TEST identification "3 " in a column down
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0400           ; for 1024 size of Half of x21 (Low-Power 8416-20)
        ;
        DW      L00BC           ; $E400 do "pushWORD to System stack" (could use WORD Pusher !!)
        DW      $E400           ; for "TOP Half of x21" base (in NON-protected NV RAM)
        ;
        DW      L0A2A           ; do a pass of SELF-TEST #3 for non-protected NV RAMS
        ;
        DW      L0C83           ; show BAD RAM Socket "x21 " IF error occured
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0800           ; for 2048 size of x22 (Normal-Power 8416-20)
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E800           ; for Word base of x22 SCRATCHpad Static RAM
        ;
        DW      L0A2A           ; do a pass of SELF-TEST #3 for Static RAMS
        ;
        DW      L0C83           ; show BAD RAM Socket "x22 " IF error occured
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0800           ; for 2048 size of x23 (Normal-Power 8416-20)
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $F000           ; for Word base of x23 SCRATCHpad Static RAM
        ;
        DW      L0A2A           ; do a pass of SELF-TEST #3 for Static RAMS
        ;
        DW      L0C83           ; show BAD RAM Socket "x23 " IF error occured
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0700           ; for 1792 size of x24 (EXCEPT for System Stack area)
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $F800           ; for Word base of x24 SCRATCHpad Static RAM
        ;
        DW      L0A2A           ; do a pass of SELF-TEST #3 for Static RAMS
        ;
        DW      L0C83           ; show BAD RAM Socket "x24 " IF error occured
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack" was a 1 for ??
        ;
        DW      L0C64           ; display SELF-TEST identification "4 " in a column down
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ROMS x2 TO x4 (x1 ALREADY tested)
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack" to be STARTing at $1000
        ;
        DW      L0C11           ; do SELF-TEST #4 for ROM B, C, and D checksums
        ;
        DW      L0505           ; 14 "BYTE Pusher" for ROMS x5 TO x10
        ;
        DW      L04F9           ; 8 "BYTE Pusher" to be STARTing at $8000
        ;
        DW      L0C11           ; do SELF-TEST #4 for ROM E, F, G, H, J, K checksums
        ;
        DW      L0C64           ; display SELF-TEST identification "5 " in a column down
        ;
        DW      L04F9           ; 8 "BYTE Pusher" OUTports from TONMO to VOLN
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; TerseDO Loop #1 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      L0BA9           ; for 8 byte table to preset SOUNDS to HALF Volume
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "DUPlicate Top of System stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0511           ; 16 "BYTE Pusher" as base SOUND OUTport is TONMO
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 also preset SOUNDS in other CHANNEL to the same
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ; TerseLOOP #1 back to TerseDO #1 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $41             ; 65 for TONMO in second CHANNEL
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; for &(80)=65 as TONMO #2
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L09CB           ; IDLE until START 1 and START 2 are BOTH pressed
        ;
        DW      L0BB1           ; initalize first 13 CONTROL ports then zero all SOUNNDS
        ;
        DW      L0962           ; find a Byte 0 ONSCREEN then ZERO Full-Scale X and Y locations
        ;
        DW      L0C59           ; do DISPLAY SELF-TEST #6 number followed by a SPACE
        ;
        DW      L094A           ; do ADD offsets to Full-Scale X and Y (block) locations
        ; BEGIN loop #2
L0D75:  DW      L0951           ; do CLEAR both X and Y Full-Scale locations (reset ??)
        ;
        DW      L0511           ; 16 "BYTE Pusher" for CONTROL Input port
        ;
        DW      L0BEA           ; displays CONTROL Switch settings as 1 or 0 = ACTIVE
        ;
        DW      L0521           ; 17 "BYTE Pusher" as P2 (COCKTAIL only) INPUT Port
        ;
        DW      L0BEA           ; displays Second Player JOYSTICK Switch settings as ACTIVE low
        ;
        DW      L0523           ; 18 "BYTE Pusher" as P1 (and P2 UPRIGHT mode) INPUT Port
        ;
        DW      L0BEA           ; displays First Player JOYSTICK Switch settings as ACTIVE low
        ;
        DW      L0525           ; 19 "BYTE Pusher" as OPTION Input port
        ;
        DW      L0BEA           ; displays OPTION DIP Switch positions (as 0 = ACTIVE)
        ;
        DW      L09BE           ; ?? do "check for START 1 and START 2 buttons BOTH pressed"
        ; END #2 or loop to BEGIN #2 if False
        DW      L03CD,L0D75     ; ConditionalJUMP to LOOP displays until check is True
        ;
        DW      L0962           ; find a Byte 0 ONSCREEN then ZERO Full-Scale X and Y locations
        ;
        DW      L0C59           ; do DISPLAY SELF-TEST #7 Number followed by a SPACE
        ; BEGIN loop #3
L0D91:  DW      L094A           ; do ADD offsets to Full-Scale X and Y locations
        ;
        DW      L0B80           ; do DRAW a 1 and a SPACE CHARacter
        ;
        DW      L03E7           ; A" do Terse SKIP RELative in SELF-TEST #7 (counts
        DB      $05,"DIFF "     ; over) $44,$49,$46,$46,$20" DIFFiculty Text String
        ; here ??
        DW      L099E           ; TerseCALL "Print Text String"
        ;
        DW      L00BC           ; DIF "pushWORD to System stack"
        DW      $E3EB           ; for ( DIFficulty factor ) 0-9 in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L0A6D           ; make changes to a SETTING Number until EITHER START pressed
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00BC           ; DIF "pushWORD to System stack"
        DW      $E3EB           ; for ( DIFficulty factor ) 0-9 in High WRITE-protected NV RAM
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ;
        DW      L0B90           ; do overDRAW old "1" with "0" then DRAW a "1" under it
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3F0           ; for READ Word CREDITS / Slot 1 in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3F1           ; for READ Word PER COIN Slot 1 in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack" to SET as SLOT 1
        ;
        DW      L0B06           ; do set COins per CRedit in SELF-TEST #7
        ;
        DW      L0B6B           ; save COins per CRedit for DOOR1
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3F2           ; for Word ?? Slot 1 in High WRITE-protected NV RAM
        ;
        DW      L07D8           ; WP! do "WRITE-protectedWORD" (SP+2) into (SP) & (SP)-513
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3F1           ; for Word PER COIN Slot 1 in High WRITE-protected NV RAM
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3F0           ; for Word CREDITS / Slot 1 in High WRITE-protected NV RAM
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ;
        DW      L0B90           ; do overDRAW old "1" with "0" then DRAW a "1" under it
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3EC           ; for READ Word CREDITS / Slot 2 in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3ED           ; for READ Word PER COIN Slot 2 in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" to SET as SLOT 2
        ;
        DW      L0B06           ; do set COins per CRedit in SELF-TEST #7
        ;
        DW      L0B6B           ; save COins per CRedit for DOOR2
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3EE           ; for Word ?? Slot 2 in High WRITE-protected NV RAM
        ;
        DW      L07D8           ; WP! do "WRITE-protectedWORD" (SP+2) into (SP) & (SP)-513
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3ED           ; for Word PER COIN Slot 2 in High WRITE-protected NV RAM
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3EC           ; for Word CREDITS / Slot 2 in High WRITE-protected NV RAM
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0A00           ; 2560 for ?? DELAY timer ??
        ;
        DW      L0A62           ; do MULTIPLE reads of Game control SWitches for ??
        ;
        DW      L0B90           ; do overDRAW old "1" with "0" then DRAW a "1" under it
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0A00           ; 2560 for a very big number ?? for TO value
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for START value
        ; _TerseDO Loop #4 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; "TerseDO Loop begin" from 0 to 2560 ??
        ;
        DW      L09BE           ; ?? do "check for START 1 and START 2 buttons BOTH pressed"
        ;
        DW      L0217           ; -DUP do "DUPlicate Top of System stack IF Not Zero"
        ; __IF False skip
        DW      L03CD,L0E1B     ; ConditionalJUMP to SKIP Loop BREAK (by lowering TO value)
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ; __(?? Fake a BREAK out of TerseDO Loop ??)
        DW      L03D9           ; do "Change TERSE Loop TO Value to current COUNTer"
        ; _THEN and TerseLOOP #4 back to TerseDO #4 (until INCrement COUNTer reaches to END value)
L0E1B:  DW      L0269           ; LOOP "back to DO or continue" if done
        ;
        DW      L093D           ; do ADD offset to Full-Scale X location
        ;
        DW      L0B89           ; do DRAW a 0 NUMBER CHARacter
        ;
        DW      L0951           ; do CLEAR both X and Y Full-Scale locations
        ; END #3 or loop to BEGIN #3 if False
        DW      L03CD,L0D91     ; ConditionalJUMP to LOOP on SELF-TEST #7 until exited
        ;
        DW      L0962           ; find a Byte 0 ONSCREEN then ZERO Full-Scale X and Y locations
        ;
        DW      L094A           ; do ADD offsets to Full-Scale X and Y locations
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0140           ; for 320 PIXelS (not BITS) Per Line ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF16           ; for Full-Scale X location = 0 to 20480
        ;
        DW      L02BB           ; do "Pop HL, Pop DE, ADD DE to (HL) word"
        ;
        DW      L0C59           ; do DISPLAY SELF-TEST #8 Number followed by a SPACE
        ;
        DW      L0535           ; 16384 (hex $4000) "WORD Pusher" for NORMEM ??
        ;
        DW      L04FD           ; 10 "BYTE Pusher" for GRID Blocks height
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; TerseDO Loop #5 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; "TerseDO Loop begin" with $FFs across Screen
        ;
        DW      L09D4           ; do COPY (DE) into 80 following bytes (HORIZONTAL line)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $13             ; for 19 Scan lines in each SQUARE
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; _TerseDO Loop #6 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L09E8           ; draw a Scanline of PIXELs for GRID uprights
        ; _TerseLOOP #6 back to TerseDO #6 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" inner loop
        ; TerseLOOP #5 back to TerseDO #5 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" outer loop
        ;
        DW      L09D4           ; do COPY (DE) into 80 following bytes (for BOTTOM line)
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L09CB           ; IDLE until START 1 and START 2 are BOTH pressed
        ;
        DW      L0962           ; find a Byte 0 ONSCREEN then ZERO Full-Scale X and Y locations
        ;
        DW      L0C59           ; do DISPLAY SELF-TEST #9 Number followed by a SPACE
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; for 20 words ?? to divide Screen by
        ;
        DW      L04FB           ; 9 "BYTE Pusher" &(9)=20 as HORCB (with BC = Color 0)
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $A3             ; for 163 as very Bright GREEN
        ;
        DW      L04F1           ; 4 "BYTE Pusher" &(4)=163 as COL0L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L0527           ; 85 "BYTE Pusher" for 01010101B 4-pixels of Color 1
        ;
        DW      L0535           ; 16384 (hex $4000) "WORD Pusher" for NORMEM ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0D70           ; 3440 for ?? (equals 43 Lines !!)
        ; TerseDO Loop #7 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L00E9           ; DUP do "DUPlicate Top of System stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0535           ; 16384 (hex $4000) "WORD Pusher" for NORMEM ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $10E0           ; 4320 for ?? (equals 54 Lines !!)
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L0527           ; 85 "BYTE Pusher" for 01010101B 4-pixels of Color 1
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $10E0           ; 4320 for ?? (another 54 Lines !!)
        ; (?? ADD 4320 to TerseDO Loop #7 COUNTer ??) for 54 Lines closer to END ??
        DW      L037A           ; do "Pop HL, ADD as Offset to TERSE Loop COUNT, check END limit"
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L09CB           ; IDLE until START 1 and START 2 are BOTH pressed
        ;
        DW      L0B9B           ; do FULL RESET !!
        ;
        DW      L00B0           ; ... TerseRETurn
; end of Service mode code

; Service mode ?? table
L0E90:  DW      L0C99           ; JumP address (next in Word table would be L0003)
        DB      $03             ; with (BC) = 3 (borrows $00 below for RESTART !!)
; end of Service mode table ??

;*****************************************************************************
;
; start of monochrome FONT Patterns, in this bizzare order (by L064B: table):
; / B C D E F G H I J K N O R 1 2 3 4 5 6 7 9 0 8 L A M S U P Q T V W X Y Z
;
;*****************************************************************************
; note: hot-spot(s) marked with _._ or (X) on upper-right corner(s)
;
; AlphaNumeric non-character #00 (uses 3 = significant Pixels from above !!)
L0E93:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $01             ; 1 = Height in rows
        ; ASCII $20 for SPACE CHARacter (after -32 offset applied)
        DB      $00             ;_._. . . . . . .

; AlphaNumeric character #01
        DB      $06             ; 6 = significant Pixels (NOT Labeled !!)
L0E99:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $2F for Symbol '/'
        DB      $0C             ;_._. . . X X . .
        DB      $0C             ; . . . . X X . .
        DB      $18             ; . . . X X . . .
        DB      $18             ; . . . X X . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $60             ; . X X . . . . .
        DB      $60             ; . X X . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .

; AlphaNumeric character #02
        DB      $06             ; 6 = significant Pixels
L0EA8:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $42 for Letter 'B'
        DB      $F8             ;(X)X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $F8             ; X X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $F8             ; X X X X X . . .

; AlphaNumeric character #03
        DB      $06             ; 6 = significant Pixels
L0EB7:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $43 for Letter 'C'
        DB      $78             ;_._X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $78             ; . X X X X . . .

; AlphaNumeric character #04
        DB      $06             ; 6 = significant Pixels
L0EC6:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $44 for Letter 'D'
        DB      $F8             ;(X)X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $F8             ; X X X X X . . .

; AlphaNumeric character #05
        DB      $06             ; 6 = significant Pixels
L0ED5:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $45 for Letter 'E'
        DB      $FC             ;(X)X X X X X . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $FC             ; X X X X X X . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $FC             ; X X X X X X . .

; AlphaNumeric character #06
        DB      $06             ; 6 = significant Pixels
L0EE4:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $46 for Letter 'F'
        DB      $FC             ;(X)X X X X X . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $FC             ; X X X X X X . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .

; AlphaNumeric character #07
        DB      $06             ; 6 = significant Pixels
L0EF3:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $47 for Letter 'G'
        DB      $78             ;_._X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $DC             ; X X . X X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $78             ; . X X X X . . .

; AlphaNumeric character #08
        DB      $06             ; 6 = significant Pixels
L0F02:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $48 for Letter 'H'
        DB      $CC             ;(X)X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $FC             ; X X X X X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .

; AlphaNumeric character #09
        DB      $02             ; 2 = significant Pixels
L0F11:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $49 for Letter 'I'
        DB      $C0             ;(X)X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .

; AlphaNumeric character #10
        DB      $04             ; 4 = significant Pixels
L0F20:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $4A for Letter 'J'
        DB      $30             ;_._. X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $E0             ; X X X . . . . .

; AlphaNumeric character #11
        DB      $06             ; 6 = significant Pixels
L0F2F:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $4B for Letter 'K'
        DB      $C4             ;(X)X . . . X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $D8             ; X X . X X . . .
        DB      $F0             ; X X X X . . . .
        DB      $F0             ; X X X X . . . .
        DB      $D8             ; X X . X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $C4             ; X X . . . X . .

; AlphaNumeric character #12
        DB      $06             ; 6 = significant Pixels
L0F3E:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $4E for Letter 'N'
        DB      $D8             ;(X)X . X X . . .
        DB      $FC             ; X X X X X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .

; AlphaNumeric character #13
        DB      $06             ; 6 = significant Pixels
L0F4D:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $4F for Letter 'O'
        DB      $78             ;_._X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $78             ; . X X X X . . .

; AlphaNumeric character #14
        DB      $06             ; 6 = significant Pixels
L0F5C:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $52 for Letter 'R'
        DB      $F8             ;(X)X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $F8             ; X X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .

; AlphaNumeric character #15
        DB      $06             ; 6 = significant Pixels
L0F6B:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $31 for Number '1'
        DB      $70             ;_._X X X . . . .
        DB      $B0             ; X . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $FC             ; X X X X X X . .

; AlphaNumeric character #16
        DB      $06             ; 6 = significant Pixels
L0F7A:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $32 for Number '2'
        DB      $78             ;_._X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $0C             ; . . . . X X . .
        DB      $0C             ; . . . . X X . .
        DB      $78             ; . X X X X . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $FC             ; X X X X X X . .

; AlphaNumeric character #17
        DB      $06             ; 6 = significant Pixels
L0F89:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $33 for Number '3'
        DB      $78             ;_._X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $0C             ; . . . . X X . .
        DB      $78             ; . X X X X . . .
        DB      $0C             ; . . . . X X . .
        DB      $0C             ; . . . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $78             ; . X X X X . . .

; AlphaNumeric character #18
        DB      $06             ; 6 = significant Pixels
L0F98:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $34 for Number '4'
        DB      $CC             ;(X)X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $FC             ; X X X X X X . .
        DB      $0C             ; . . . . X X . .
        DB      $0C             ; . . . . X X . .
        DB      $0C             ; . . . . X X . .
        DB      $0C             ; . . . . X X . .

; AlphaNumeric character #19
        DB      $06             ; 6 = significant Pixels
L0FA7:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $35 for Number '5'
        DB      $FC             ;(X)X X X X X . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $F8             ; X X X X X . . .
        DB      $0C             ; . . . . X X . .
        DB      $0C             ; . . . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $78             ; . X X X X . . .

; AlphaNumeric character #20
        DB      $06             ; 6 = significant Pixels
L0FB6:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $36 for Number '6'
        DB      $78             ;_._X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $C0             ; X X . . . . . .
        DB      $F8             ; X X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $78             ; . X X X X . . .

; AlphaNumeric character #21
        DB      $06             ; 6 = significant Pixels
L0FC5:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $37 for Number '7'
        DB      $FC             ;(X)X X X X X . .
        DB      $0C             ; . . . . X X . .
        DB      $0C             ; . . . . X X . .
        DB      $0C             ; . . . . X X . .
        DB      $18             ; . . . X X . . .
        DB      $30             ; . . X X . . . .
        DB      $60             ; . X X . . . . .
        DB      $60             ; . X X . . . . .
        DB      $60             ; . X X . . . . .
        DB      $60             ; . X X . . . . .

; AlphaNumeric character #22
        DB      $06             ; 6 = significant Pixels
L0FD4:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $39 for Number '9'
        DB      $78             ;_._X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $7C             ; . X X X X X . .
        DB      $0C             ; . . . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $78             ; . X X X X . . .

; AlphaNumeric character #23
        DB      $06             ; 6 = significant Pixels
L0FE3:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $30 for Number '0'
        DB      $78             ;_._X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $78             ; . X X X X . . .

; AlphaNumeric character #24
        DB      $06             ; 6 = significant Pixels
L0FF2:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $38 for Number '8'
        DB      $78             ;_._X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $78             ; . X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $78             ; . X X X X . . .

; AlphaNumeric character #25
        DB      $06             ; 6 = significant Pixels
L1001:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $4C for Letter 'L'
        DB      $C0             ;(X)X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $FC             ; X X X X X X . .

; AlphaNumeric character #26      ; ALPHA 'A' through 'Z'
        DB      $06             ; 6 = significant Pixels
L1010:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $41 for Letter 'A'
        DB      $78             ;_._X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $FC             ; X X X X X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .

; double-wide AlphaNumeric character #27
        DB      $0A             ; 10 = significant Pixels
L101F:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $02             ; 2 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $4D for Letter 'M'
        DB      $DB,$80         ;(X)X . X X . X X X . . . . . . .
        DB      $FF,$C0         ; X X X X X X X X X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .

; AlphaNumeric character #28
        DB      $06             ; 6 = significant Pixels
L1038:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $53 for Letter 'S'
        DB      $78             ;_._X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $C0             ; X X . . . . . .
        DB      $78             ; . X X X X . . .
        DB      $0C             ; . . . . X X . .
        DB      $0C             ; . . . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $78             ; . X X X X . . .

; AlphaNumeric character #29
        DB      $06             ; 6 = significant Pixels
L1047:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $55 for Letter 'U'
        DB      $CC             ;(X)X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $FC             ; X X X X X X . .
        DB      $6C             ; . X X . X X . .

; AlphaNumeric character #30
        DB      $06             ; 6 = significant Pixels
L1056:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $50 for Letter 'P'
        DB      $F8             ;(X)X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $F8             ; X X X X X . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .

; AlphaNumeric character #31
        DB      $07             ; 7 = significant Pixels
L1065:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $51 for Letter 'Q'
        DB      $78             ;_._X X X X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $DC             ; X X . X X X . .
        DB      $CE             ; X X . . X X X .
        DB      $7A             ; . X X X X . X .

; AlphaNumeric character #32
        DB      $06             ; 6 = significant Pixels
L1074:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $54 for Letter 'T'
        DB      $FC             ;(X)X X X X X . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .

; AlphaNumeric character #33
        DB      $06             ; 6 = significant Pixels
L1083:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $56 for Letter 'V'
        DB      $CC             ;(X)X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $78             ; . X X X X . . .
        DB      $30             ; . . X X . . . .

; double-wide AlphaNumeric character #34
        DB      $0A             ; 10 = significant Pixels
L1092:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $02             ; 2 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII #57 for Letter 'W'
        DB      $CC,$C0         ;(X)X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $CC,$C0         ; X X . . X X . . X X . . . . . .
        DB      $73,$80         ; . X X X . . X X X . . . . . . .


; AlphaNumeric character #35
        DB      $06             ; 6 = significant Pixels
L10AB:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $58 for Letter 'X'
        DB      $CC             ;(X)X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $48             ; . X . . X . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $48             ; . X . . X . . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .

; AlphaNumeric character #36
        DB      $06             ; 6 = significant Pixels
L10BA:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $59 for Letter 'Y'
        DB      $CC             ;(X)X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $CC             ; X X . . X X . .
        DB      $78             ; . X X X X . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .
        DB      $30             ; . . X X . . . .

; AlphaNumeric character #37
        DB      $06             ; 6 = significant Pixels
L10C9:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $5A for Letter 'Z'
        DB      $FC             ;(X)X X X X X . .
        DB      $0C             ; . . . . X X . .
        DB      $0C             ; . . . . X X . .
        DB      $1C             ; . . . X X X . .
        DB      $38             ; . . X X X . . .
        DB      $70             ; . X X X . . . .
        DB      $E0             ; X X X . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $FC             ; X X X X X X . .  <-- Zed

; end of FONT
;
;*****************************************************************************
; back to Terse code
; RECREATED SOURCE for code !! FROM SCRATCH !!
; : noname @ DUP 4 + SWAP 2DUP ! 2 + :
;*****************************************************************************
; noname does ??
L10D7:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L00EE           ; 2DUP do "duplicate top 2 Words of System stack"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L04ED           ; 2 "BYTE Pusher"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, DE->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "VERIFY ?? Words in Static RAM match" with (HL) -> new IY for ??
L10EE:  CALL    L0769           ; do Wait until Interrupts finish
        PUSH    DE              ; store ??
        LD      E,(HL)          ; point to 2-word table for ??
        INC     HL
        LD      D,(HL)
        PUSH    DE              ; stuff first word into IndexY
        POP     IY
        INC     HL
        LD      C,(IY+$00)      ; get Word BC from NV RAM
        LD      E,C             ; and into Word DE as well
        LD      B,(IY+$01)
        LD      D,B
        LD      A,(HL)          ; is next Byte of table
        INC     HL
        CP      C               ; different from Low Byte of ??
        JR      NZ,L110B                ; (+$05) if yes
        PUSH    IY              ; un-stuff first word from IndexY
        POP     BC
        INC     BC              ; add 2
        INC     BC
L110B:  INC     BC              ; add 2 nore
        INC     BC
        LD      A,(IY+$02)      ; is next Word from IndexY
        CP      C               ; different from Low Byte of ??
        LD      A,(IY+$03)
        JR      NZ,L1117                ; (+$01) if yes
        CP      B               ; and different from High Byte of ??
L1117:  JR      NZ,L1123                ; (+$0a) if yes
        POP     DE              ; restore ??
        LD      HL,$0001        ; 1 for ?? True
        POP     AF              ; restore A and Flags from ??
        JP      PO,L1122        ; if ?? skip re-Enable Interrupts
        EI
L1122:  RET                     ; urn with HL = 1 on Successful exit ??

; ?? more if second Word different from first Word+2 (or +4 ??) in IndexY
L1123:  POP     HL              ; restore ?? (was in DE ??)
        LD      A,L
        LD      (DE),A          ; save HL ?? in first Word of IndexY
        INC     DE
        LD      A,H
        LD      (DE),A
        LD      (IY+$00),C      ; write first Word+2 (or +4 ??) in IndexY ??
        LD      (IY+$01),B
        LD      HL,$0000        ; 0 for ?? False
        POP     AF
        JP      PO,L1137        ; if ?? skip re-Enable Interrupts
        EI
L1137:  RET                     ; urn with HL = 0 on Unsuccessful exit ??

; ?? does ?? with (HL) -> new IY for ?? also
L1138:  CALL    L0769           ; do Wait until Interrupts finish
        LD      E,(HL)          ; point to 2-word table for ??
        INC     HL
        LD      D,(HL)
        PUSH    DE              ; stuff first word into IndexY
        POP     IY
        INC     HL
        LD      C,(IY+$02)      ; read next Word from IndexY
        LD      B,(IY+$03)
        LD      A,(IY+$00)      ; is first Word from IndexY ...
        CP      C               ; different from Low Byte of ??
        JR      NZ,L1152                ; (+$04) if yes
        LD      A,(IY+$01)
        CP      B               ; and different from High Byte of ??
L1152:  JR      NZ,L115D                ; (+$09) if yes
        LD      HL,$0001        ; 1 for ?? True
        POP     AF              ; restore A and Flags from ??
        JP      PO,L115C        ; if ?? skip re-Enable Interrupts
        EI
L115C:  RET                     ; urn with HL = 1 on Successful exit ??

; ?? more if first Word different from second Word+2 (or +4 ??) in IndexY
L115D:  LD      A,(BC)          ; copy Word from BC ?? into DE
        LD      E,A
        INC     BC
        LD      A,(BC)
        LD      D,A
        DEC     BC
        LD      A,(HL)          ; is second word from ?? 2-word table
        INC     HL
        CP      C               ; different from Low Byte of ??
        JR      NZ,L116A                ; (+$02) if yes
        LD      A,(HL)
        CP      B               ; and different from High Byte of ??
L116A:  JR      NZ,L1171                ; (+$05) if yes
        PUSH    IY              ; un-stuff first word from IndexY
        POP     BC
        INC     BC              ; add 2
        INC     BC
L1171:  INC     BC              ; add 2 more
        INC     BC
        LD      (IY+$02),C      ; write BC+2 (or +4 ??) into second word of IndexY ??
        LD      (IY+$03),B
        LD      HL,$0000        ; 0 for ?? False
        POP     AF
        JP      PO,L1181        ; if ?? skip re-Enable Interrupts
        EI
L1181:  RET                     ; urn with HL = 0 on Unsuccessful exit ??

; 4 2-word tables "Range of locations in Static RAM" for ?? Interrupt Routines ??
L1182:  DW      $FEB0           ; table #1 index 1 = point to WORD ?? for ??
        DW      $FEDC           ; + 46-Words index 2 = point to WORD ?? for ??

L1186:  DW      $FE82           ; table #2 index 1 = point to WORD ?? for ??
        DW      $FEAE           ; + 22-Words index 2 = point to WORD ?? for ??

L118A:  DW      $FE62           ; table #3 index 1 = point to WORD ?? for ??
        DW      $FE80           ; + 15-Words index 2 = point to WORD ?? for ??

L118E:  DW      $FE42           ; table #4 index 1 = point to WORD ?? for ??
        DW      $FE60           ; + 15-Words index 2 = point to WORD ?? for ??
; end of 2-word tables ?? for ??

; ?? does point to 2 word table #1 for "Range of locations in Static RAM" then ??
L1192:  LD      HL,L1182        ; point to 2 word table #1 for ??
; re-entry point with HL pointers at tables #2 through #4 for ??
L1195:  PUSH    IY              ; store ??
        PUSH    IY              ; also put it in DE
        POP     DE
        CALL    L10EE           ; ?? do "VERIFY ?? Words match" with (DE) = old IY for ??
        LD      A,L             ; check for ERROR RETurned
        OR      H
        JP      NZ,L0000        ; if False to RESET ?? Robby Roto ??
        POP     IY              ; else restore ??
        RET

; TERSE Forth vm-que-in ?? does "increment ?? and point to 2 word table #2 for ?? then ??"
L11A5:  LD      HL,$FEEF        ; point to Word ?? for ?? in Static RAM
        INC     (HL)            ; add 1 for ??
        LD      HL,L1186        ; point to 2 word table #2 for ??
        JP      L1195                   ; not JR ?? to re-entry point

; ?? does check ??, increment ?? and point to 2 word table #3 or #4 for ?? then ??
L11AF:  LD      A,(IY+$0A)      ; check ?? for ??
        CP      $01
        RET     NC
        INC     (IY+$0A)        ; add 1 for ??
        LD      HL,$FEED        ; point to Word ?? for ?? in Static RAM
        INC     (HL)            ; add 1 for ??
        LD      A,($FEFF)       ; bit 0 = 1 for P2 in COCKTAIL mode ONLY !!
        OR      A
        JR      NZ,L11CA                ; (+$08) yes ...
        LD      A,($FEF3)       ; read Byte ?? for ?? in Static RAM
        CP      (IY+$1F)        ; VYH offset 31 compare ?? to ??
        JR      L11D2                   ; (+$08) ... or no

; ?? more ??
L11CA:  LD      A,($FEF3)       ; read Byte ?? for ?? in Static RAM
        LD      B,A
        LD      A,(IY+$1F)      ; VYH offset 31 compare ?? to ??
        CP      B
L11D2:  JR      NC,L11D9                ; (+$05) is ?? > ??
        LD      HL,L118E        ; point to 2 word table #4 for ??
        JR      L11DC                   ; (+$03)

; ?? if ?? > ??
L11D9:  LD      HL,L118A        ; point to 2 word table #3 for ??
L11DC:  JP      L1195                   ; not JR ?? to re-entry point
; end of ?? uses 2 word tables for ??

; ?? does "PREPARE an Image with DE = Full-Scale X and HL = Full-Scale Y" routine
L11DF:  CALL    L0588           ; invertxy? du "read CABINet mode and if Not 0 do Full-Scale INVERT"
        SLA     L               ; times 4 for ??
        RL      H
        SLA     L
        RL      H
        LD      B,(IY+$21)      ; write Word PATTERN Source address
        LD      C,(IY+$20)
        PUSH    BC
        POP     IX
        LD      C,(IY+$1A)      ; read Byte MAGIC to use ??
        CALL    L057E           ; invert? du "read CABINet mode and if Not 0 set MRFLOP and MRFLIP"
        PUSH    HL
        EX      DE,HL
        LD      D,(IX+$00)      ; read X Hot Spot offset
        LD      E,$00
        SRA     D               ; divide by 4
        RR      E
        SRA     D
        RR      E
        BIT     MRFLOP,C        ; is MAGIC FLOP bit 6 set ?
        JR      Z,L120F                 ; (+$03) if no
        ADD     HL,DE           ; else X plus Byte 1/4 X Hot Spot
        JR      L1212                   ; (+$03) resume

; if MRFLOP set ??
L120F:  OR      A               ; ?? X minus Byte 1/4 X Hot Spot
        SBC     HL,DE
L1212:  EX      (SP),HL         ; resume here (store X location)
        LD      D,(IX+$01)      ; read Y Hot Spot offset
        LD      E,$00
        BIT     MRFLIP,C        ; is MAGIC FLIP bit 7 set ?
        JR      Z,L1220                 ; (+$04) if no
        ADD     HL,DE           ; ?? Y plus Byte Y Hot Spot MINUS 1
        DEC     HL
        JR      L1223                   ; (+$03) resume

; if MRFLIP set ??
L1220:  OR      A               ; ?? Y minus Byte Y Hot Spot
        SBC     HL,DE
L1223:  POP     DE              ; resume here (DE is NOT needed !!)
        LD      A,H             ; divide by 16 for ??
        LD      H,$00
        LD      L,A
        ADD     HL,HL           ; ?? times 16
        ADD     HL,HL
        ADD     HL,HL
        ADD     HL,HL
        PUSH    DE              ; store (unused !!) DE for X location
        LD      E,L             ; save times 16
        LD      D,H
        ADD     HL,HL           ; now times 64
        ADD     HL,HL
        ADD     HL,DE           ; plus times 16
        EX      DE,HL           ; now DE is H * 80 (for BPLINEs)
        POP     HL              ; restore X location
        LD      A,L             ; plus 1/16th
        LD      L,H
        LD      H,$00
        ADD     HL,DE           ; merge X and Y (for ABSOLUTE Address ??)
        RLCA                    ; Circulate Top 2 bits of ??, then
        RLCA
        AND     $03             ; Mask to Bottom 2 SHIFT bits of ??
        BIT     MRFLOP,C        ; is MAGIC FLOP bit 6 set ?
        JR      Z,L1246                 ; (+$05) no
        NEG                     ; if FLOPped, -SHIFT and
        JR      NZ,L1246                ; (+$01) on ??
        DEC     HL              ; if 0 SHIFT a whole byte LEFT
L1246:  AND     $03
        LD      E,A             ; mask off SHIFT bits
        CALL    L057E           ; invert? du "read CABINet mode and if Not 0 set MRFLOP and MRFLIP"
        LD      A,C
        AND     $FC             ; mask SHIFT bits OFF
        OR      E               ; mix SHIFT bits back in
        LD      (IY+$1A),A      ; save Byte MAGIC register
        LD      (IY+$2D),H      ; VSCRADRH offset 45 save Word ABSOLUTE Address ??
        LD      (IY+$2C),L      ; VSCRADR offset 44
        RET
; end of "PREPARE an Image with DE = Full-Scale X and HL = Full-Scale Y"

; L125A: ?? ChecKsum Byte ??
        INC     BC

; TERSE Forth write (rename ??) does "Pattern Board handler"
; B for expand, C for magic but if P2 in COCKTAIL mode then XOR to 11000000B first
; D = Height, IX = Source address, HL = Destination address "to COPY ?? to Screen"
L125B:  LD      A,B
        OUT     (XPAND),A       ; &(25)=?? eXPANDer pixel definition port
        CALL    L057E           ; invert? du "read CABINet mode and if Not 0 set MRFLOP and MRFLIP"
        LD      A,C
        OUT     (MAGIC),A       ; &(12)=?? for MAGIC register
; initialize Pattern Board's Line Offset value
        LD      A,$24           ; start with 00100100B for CMCONSTant and CMFLOP
        BIT     MRFLIP,C        ; is MAGIC FLIP bit 7 set ?
        JR      Z,L126C                 ; (+$02) if no, else ...
        SET     CMFLIP,A        ; yes, set FLIP bit 4 of CopyMODE
L126C:  BIT     MRFLOP,C        ; is MAGIC FLOP bit 6 set ?
        JR      Z,L1272                 ; (+$02) if no, else ...
        RES     CMFLOP,A        ; yes, clear ?? FLOP bit 5 of CopyMODE
L1272:  BIT     MRXPND,C        ; is MAGIC eXPaND bit 3 set ?
        JR      Z,L127A                 ; (+$04) if no, else ...
        SET     CMXPND,A        ; yes, set eXPaND bit 1 of CopyMODE
        JR      L127C                   ; (+$02)

; fire up Pattern Board for Transfer
L127A:  SET     CMFLUSH,A       ; else set FLUSH bit 3 of CopyMODE (already set ??)
L127C:  BIT     CMCONST,C       ; is CONSTant bit 2 of CopyMODE set ?
        JR      Z,L1285                 ; (+$05)
        INC     E               ; yes, Width + 1 ...
        RES     CMCONST,A       ; clear CONSTant bit 2 of CopyMODE
        SET     CMFLUSH,A       ; and set FLUSH bit 3 of CopyMODE
L1285:  LD      B,A
        OUT     (CMODE),A       ; $7A for &(122)=?? Pattern Board Copy MODE
        PUSH    HL              ; store Destination address
        PUSH    IX              ; read Source address
        POP     HL
        LD      A,L
        OUT     (SRCLO),A       ; $78 for &(120)=?? Low Source Address
        LD      A,H
        OUT     (SRCHI),A       ; $79 for &(121)=?? High Source Address
        POP     HL              ; restore Destination address
        LD      A,L
        OUT     (SKIPLO),A      ; $7B for &(123)=?? Low Destination Address
        LD      A,H
        OUT     (DESTHI),A      ; $7C for &(124)=?? High Destination Address
        LD      H,E
        BIT     MRXPND,C        ; is MAGIC eXPaND bit 3 set ?
        JR      Z,L12A0                 ; (+$02)
        RLC     H               ; yes, then H x 2 for double the Width
L12A0:  BIT     CMFLUSH,B       ; is FLUSH bit 3 of CopyMODE set ?
        JR      Z,L12A5                 ; (+$01)
        INC     H               ; yes, H = H+1 for 1 WASTEr byte per line
L12A5:  DEC     H
        BIT     MRFLIP,C        ; is MAGIC FLIP bit 7 set ?
        JR      Z,L12B8                 ; (+$0e)
        BIT     MRFLOP,C        ; yes, is MAGIC FLOP bit 6 set ?
        JR      Z,L12B3                 ; (+$05)
        LD      A,$B0           ; both, 176 BYTEs for ?? plus Pattern Width ??
        ADD     A,H
        JR      L12B6                   ; (+$03) to L12C4:

; here on MRFLIP but No MRFLOP
L12B3:  LD      A,$B0           ; 176 BYTEs for ?? minus Pattern Width ??
        SUB     H
L12B6:  JR      L12C4                   ; (+$0c)

; here on No MRFLIP
L12B8:  BIT     MRFLOP,C        ; is MAGIC FLOP bit 6 set ?
        JR      Z,L12C1                 ; (+$05)
        LD      A,BYTEPL        ; $50 or 80 BYTEs Per Line plus Pattern Width ??
        ADD     A,H
        JR      L12C4                   ; (+$03)

; here on No MRFLIP and No MRFLOP either
L12C1:  LD      A,BYTEPL        ; $50 or 80 BYTEs Per Line minus Pattern Width
        SUB     H
; done with A = SKIP value ??
L12C4:  OUT     (SKIPLO),A      ; $7B for &(123)=?? number of bytes to Skip
        LD      A,H
        OUT     (LENGTH),A      ; $7D for &(125)=?? Width in bytes of each row
        LD      E,$01           ; set Pattern Width = 1 ??
        LD      A,D             ; load Pattern Height in rows
        DEC     A
        OUT     (LOOPS),A       ; $7E for &(126)=?? Height-1, also Starts Xfer !!
        RET
; end of TERSE Forth write (rename ??) !!

; TERSE Forth writep does "Pop DE from Terse stack then Pattern Transfer start"
; note: (IX)->DE, then draw Pattern (not VGER write ??)
L12D0:  LD      E,(IX+$00)
        INC     IX
        LD      D,(IX+$00)
        INC     IX
        JP      L125B           ; to write (routine) do "Pattern Board handler to COPY ?? to Screen"

; TERSE Forth VWRITE does "load Pattern Board values to Draw with"
L12DD:  LD      B,(IY+$1B)      ; load BC for eXpand and Magic values
        LD      (IY+$23),B      ; VOXPAND offset 35 and save as OLD eXpand and Magic values
        LD      C,(IY+$1A)
        LD      (IY+$22),C      ; VOMAGIC offset 34
        LD      H,(IY+$21)      ; load IX + 2 for PATTERN Source address
        LD      L,(IY+$20)
        LD      (IY+$2B),H      ; VOPATH offset 43 and save as OLD Source address
        LD      (IY+$2A),L      ; VOPAT offset 42
        INC     HL
        INC     HL
        PUSH    HL
        POP     IX              ; restore as Terse SP
        LD      H,(IY+$2D)      ; VSCRADRH offset 45
        LD      L,(IY+$2C)      ; VSCRADR offset 44
L1300:  LD      (IY+$2F),H      ; VOSCRADRH offset 47 load HL for Destination address
L1303:  LD      (IY+$2E),L      ; VOSCRADR offset 46
        SET     CMFLIP,(IY+$24) ; set CMFLIP bit 4 of VLOGICSTAT to ENable Write
        JP      L12D0           ; to writep do "Pop DE from Terse stack then Pattern Transfer start"

; VERASE does "load Pattern Board values to Erase with"
L130D:  LD      B,(IY+$23)      ; VOXPAND offset 35 load BC for OLD eXpand,
        LD      C,(IY+$22)      ; VOMAGIC offset 34 and Magic values
        LD      H,(IY+$2B)      ; VOPATH offset 43 load IX + 2 for OLD Source address
        LD      L,(IY+$2A)      ; VOPAT offset 42
        INC     HL
        INC     HL
        PUSH    HL
        POP     IX              ; restore as Terse SP
        LD      H,(IY+$2F)      ; VOSCRADRH offset 47 load HL for Destination address
        LD      L,(IY+$2E)      ; VOSCRADR offset 46
        RES     CMFLIP,(IY+$24) ; clear CMFLIP bit 4 of VLOGICSTAT to DISable Write
        JP      L12D0           ; to writep do "Pop DE from Terse stack then Pattern Transfer start"

; ?? does "more Pattern Board stuff ??"
L132B:  BIT     CMCONST,(IY+$24); is CMCONST bit 2 of VLOGICSTAT offset 36 set ?
        JR      NZ,L133E                ; (+$0d) yes
        LD      A,(IY+$2B)      ; VOPATH offset 43
        OR      (IY+$2A)        ; VOPAT offset 42
        JR      Z,L133C                 ; (+$03) skip ERASE
        CALL    L130D           ; VERASE do "load Pattern Board values to Erase with"
L133C:  JR      L1342                   ; (+$04) resume

; if CMCONST bit 2 of VLOGICSTAT offset 36 set
L133E:  RES     CMCONST,(IY+$24); clear it
L1342:  BIT     CMXPND ,(IY+$24) ; is CMXPND bit 1 of VLOGICSTAT offset 36 set ?
        JR      NZ,L1362                ; (+$1a) if yes
        IN      A,(INTST)       ; aka INTCPT inport =&(8) to CLEAR INTercept STatus
        CALL    L12DD           ; VWRITE do "load Pattern Board values to Draw with"
        BIT     0,(IY+$10)      ; ?? bit 0 of TVMROPT offset 16
        JR      Z,L1360                 ; (+$0d) skip if ??
        IN      A,(INTST)       ; aka INTCPT inport =&(8) to READ INTercept STatus
        AND     A
        JR      Z,L1360                 ; (+$08) skip if No HITs
        SET     1,(IY+$12)      ; ?? bit 1 of TCHGSTAT offset 18
        SET     5,(IY+$10)      ; TBNOVECT bit 5 of TVMROPT offset 16
L1360:  JR      L1366                   ; (+$04) to RETurn

; if CMXPND bit 1 of VLOGICSTAT offset 36 set
L1362:  RES     CMXPND,(IY+$24) ; just clear it
L1366:  RET

; mastersur does ?? routine
L1367:  CALL    L132B           ; do "more Pattern Board stuff ??"
; re-entry point for ??
L136A:  LD      A,(IY+$12)      ; TCHGSTAT offset 18
        AND     A
        JR      NZ,L1378                ; (+$08)
        BIT     2,(IY+$04)      ; TBMISSLE bit 2 of TSTAT offset 4
        RET     NZ
        JP      L11A5           ; to vm-que-in "increment ?? and point to 2 word table #2 for ?? then ??"

; ?? if ??
L1378:  LD      (IY+$10),$00    ; TVMROPT offset 16 to Clear ??
        LD      (IY+$11),$00
        RES     2,(IY+$04)      ; TBMISSLE bit 2 of TSTAT offset 4
        JP      L1192           ; to point to 2 word table #1 for ?? then ??
; end of TERSE Forth write !! (and end of CopyMODE EQUates ??)

; ?? does First Interrupt Routine ?? in Static RAM ??
L1387:  PUSH    AF
        PUSH    BC
        PUSH    DE
        PUSH    HL
        EXX
        EX      AF,AF'
        PUSH    AF
        PUSH    BC
        PUSH    DE
        PUSH    HL
        PUSH    IY
        PUSH    IX
; continue First Interrupt Routine ?? ALSO ?? from L3125: Alternate entry
L1395:  LD      A,($FEF7)       ; read Byte (always 200 ??) for ?? in Static RAM
        OUT     (INLIN),A       ; &(15)=?? for INterrupt LINe
        LD      A,$FE           ; SUI1V SWAB (SWAp Bytes)
        LD      I,A             ; ( load I reg )
        LD      A,$FC           ; SUI1V for INterrupt Vector at $FEFC in RAM ?? (MIS-INT or Second)
        OUT     (INFBK),A       ; &(13)= ( load feedback port )
        LD      A,($FEEA)       ; divg read Byte ?? for ?? in Static RAM
        OR      A
        JP      Z,L13B5         ; IF "vger NOT disabled" to THEN More of First Interrupt Routine
        LD      DE,L13B5
        LD      HL,$FEE8        ; divgct point to Word "eivg ct ??" for ?? in Static RAM
        LD      (HL),E
        INC     HL
        LD      (HL),D          ; tell eivg that we hit "vger disabled"
        JP      L147F           ; to restore environment, EI and RETurn

; THEN More of First Interrupt Routine if "vger NOT disabled"
L13B5:  LD      HL,$FEF4        ; point to Word ?? for ?? in Static RAM
        INC     (HL)
        LD      A,($FEF1)       ; SU1flag read Byte for ( inprogress ) in Static RAM
        CP      $00
        JP      NZ,L147F        ; restore environment, EI and RETurn
        LD      A,$01
        EI
        LD      ($FEF1),A       ; SU1flag write Byte 1 for ( inprogress ) in Static RAM
        XOR     A
        LD      ($FEEC),A
L13CB:  LD      A,($FEF1)       ; SU1flag read Byte for ( inprogress ) in Static RAM
        CP      $01
        JP      NZ,L13E2
        LD      A,($FEEC)       ; read Byte ?? for ?? in Static RAM
        OR      A
        JP      NZ,L13E2
        LD      HL,L118A        ; point to 2 word table #3 for ??
        CALL    L1138           ; (HL) -> new IY
        LD      A,L
        OR      H
L13E2:  JP      NZ,L13FF
        LD      HL,$FEED        ; point to Word ?? for ?? in Static RAM
        DEC     (HL)
        PUSH    DE
        POP     IY
        DEC     (IY+$0A)
        LD      HL,$13FB
        PUSH    HL
        LD      H,(IY+$09)      ; TSURH offset 9
        LD      L,(IY+$08)      ; TSUR(L) offset 8
        DI
        JP      (HL)

; Enable Interrupts stub ?? (on return from (TSUR word) routine ??)
L13FB:  EI
        JP      L13CB                   ; not JR ??

; ?? does ??
L13FF:  DI
        LD      A,($FEF2)       ; read Byte ?? for ?? in Static RAM
        CP      $00
        JP      NZ,L1479
        LD      A,$01
        EI
        LD      ($FEF2),A       ; write Byte 1 for ?? in Static RAM
        LD      A,($FEEF)       ; read Byte ?? for ?? in Static RAM
        LD      ($FEEE),A
L1414:  LD      A,($FEF2)       ; read Byte ?? for ?? in Static RAM
        CP      $01
        JP      NZ,L1431
        LD      A,($FEEE)       ; read Byte ?? for ?? in Static RAM
        OR      A
        JP      Z,L142E
        LD      HL,L1186        ; point to 2 word table #2 for ??
        CALL    L1138           ; (HL) -> new IY
        LD      A,L
        OR      H
        JP      L1431                   ; not JR ??

L142E:  LD      A,$01
        OR      A
L1431:  JP      NZ,L1474
        PUSH    DE
        POP     IY
        LD      HL,$FEEF        ; point to Word ?? for ?? in Static RAM
        DEC     (HL)
        LD      HL,$FEEE        ; point to Word ?? for ?? in Static RAM
        DEC     (HL)
        BIT     0,(IY+$04)      ; ?? bit 0 of TSTAT offset 4
        JP      Z,L144C
        CALL    L1192           ; do point to 2 word table #1 for ?? then ??
        JP      L1471                   ; not JR ??

; ??
L144C:  LD      A,($FEF4)       ; read Byte ?? for ?? in Static RAM
        SUB     (IY+$0B)
        LD      B,(IY+$0D)      ; TTBMAX offset 13
        CP      B
        JP      C,L145A
        LD      A,B
L145A:  OR      A
        JP      Z,L146D
        LD      HL,L1470
        PUSH    HL
        LD      H,(IY+$07)      ; TVMRH offset 7
        LD      L,(IY+$06)      ; TVMRL offset 6
        DI
        JP      (HL)

        JP      L1470                   ; not JR ?? (L146A: not used ??)

; ??
L146D:  CALL    L11A5           ; vm-que-in do "increment ?? and point to 2 word table #2 for ?? then ??"
L1470:  EI
L1471:  JP      L1414                   ; not JR ??

; ??
L1474:  LD      A,$00
        LD      ($FEF2),A       ; write Byte 0 for ?? in Static RAM
L1479:  DI
        LD      A,$00
        LD      ($FEF1),A       ; SU1flag write Byte 0 for ( inprogress ) in Static RAM
; INout does restore environment, EI and RETurn
L147F:  POP     IX
        POP     IY
        POP     HL
        POP     DE
        POP     BC
        POP     AF
        EX      AF,AF'
        EXX
        POP     HL
        POP     DE
        POP     BC
        POP     AF
        EI
        RET
; end of ?? routines

; ?? does "Disable Interrupts, First Interrupt Routine and Disable Interrupts"
L148F:  DI
        LD      A,$08
        OUT     (INMOD),A       ; &(14)=8 for INterrupt MODe of Screen Ints ONLY
        IM      2               ; set Bally standard
        CALL    L1387           ; do ?? First Interrupt routine
        DI
        JP      (IY)            ; indexed RETurn

; Second Interrupt Routine ?? in Static RAM ??
L149C:  PUSH    AF
        PUSH    BC
        PUSH    DE
        PUSH    HL
        EXX
        EX      AF,AF'
        PUSH    AF
        PUSH    BC
        PUSH    DE
        PUSH    HL
        PUSH    IY
        PUSH    IX
        LD      A,($FE41)       ; read WORD ?? for ?? in Static RAM
        OR      A
        JP      Z,L14B7
        OUT     (COL1L),A       ; &(5)=?? for COLor 1 Left ?? LEFT ??
        XOR     A
        LD      ($FE41),A       ; write Byte 0 for ?? in Static RAM
L14B7:  LD      A,($FEF6)       ; SUI2L read Byte (always 50 ??) for ?? in Static RAM
        OUT     (INLIN),A       ; &(15)=?? for INterrupt scan LINe
        LD      A,$FE           ; SUI2V SWAB (SWAp Bytes)
        LD      I,A             ; ( load I reg )
        LD      A,$FA           ; SUI2V for INterrupt Vector at $FEFA (Third)
        OUT     (INFBK),A       ; &(13)= ( load feedback port )
        LD      A,($FEF1)       ; SU1flag read Byte for ( inprogress ) in Static RAM
        CP      $01
        JP      NZ,L14D1
        LD      A,$02
        LD      ($FEF1),A       ; SU1flag write Byte 2 for ( inprogress ) in Static RAM
L14D1:  LD      A,($FEEA)       ; divg read Byte ?? for ?? in Static RAM
        OR      A
        JP      Z,L14E4         ; IF "vger NOT disabled" to THEN More of Second Interrupt Routine
        LD      DE,L14E4
        LD      HL,$FEE8        ; divgct point to Word "eivg ct ??" for ?? in Static RAM
        LD      (HL),E
        INC     HL
        LD      (HL),D          ; tell eivg that we hit "vger disabled"
        JP      L147F                   ; not JR ?? INout to restore environment, EI and RETurn

; THEN SUI2-DI More of Second Interrupt Routine ??
L14E4:  LD      A,($FEF0)       ; read Byte ?? for ?? in Static RAM
        CP      $00
        JP      NZ,L1530
        LD      A,$01
        EI
        LD      ($FEF0),A       ; write Byte 1 for ?? in Static RAM
        XOR     A
        LD      ($FEEC),A
L14F6:  LD      A,($FEF0)       ; read Byte ?? for ?? in Static RAM
        CP      $01
        JP      NZ,L150D
        LD      A,($FEEC)       ; read Byte ?? for ?? in Static RAM
        OR      A
        JP      NZ,L150D
        LD      HL,L118E        ; point to 2 word table #4 for ??
        CALL    L1138           ; (HL) -> new IY
        LD      A,L
        OR      H
L150D:  JP      NZ,L152A        ; if ?? to Disable Interrupts stub
        LD      HL,$FEED        ; point to Word ?? for ?? in Static RAM
        DEC     (HL)
        PUSH    DE
        POP     IY
        DEC     (IY+$0A)
        LD      HL,$1526        ; fake Return Address to Second Enable Interrupts stub
        PUSH    HL
        LD      H,(IY+$09)      ; TSURH offset 9
        LD      L,(IY+$08)      ; TSUR(L) offset 8
        DI
        JP      (HL)            ; to (TSUR word) routine ??

; Second Enable Interrupts stub ?? (on return from (TSUR word) routine ??)
L1526:  EI
        JP      L14F6                   ; not JR ?? back into Second Interrupt Routine ??

; Disable Interrupts stub ??
L152A:  DI
        LD      A,$00
        LD      ($FEF0),A       ; write Byte 0 for ?? in Static RAM
L1530:  JP      L147F           ; INout to restore environment, EI and RETurn

; Third Interrupt Routine ?? in Static RAM ??
L1533:  PUSH    AF
        LD      A,($FEF5)       ; read Byte (always 100 ??) for ?? in Static RAM
        OUT     (INLIN),A       ; &(15)=?? for INterrupt scan LINe
        LD      A,$FE           ; SUI3V SWAB
        LD      I,A             ; ( load I reg )
        LD      A,$F8           ; SUI3V for INterrupt Vector at $FEF8 (First or Alternate)
        OUT     (INFBK),A       ; &(13)= ( load feedback port )
        LD      A,($FEF0)       ; read Byte ?? for ?? in Static RAM
        CP      $01
        JR      NZ,L154D                ; (+$05)
        LD      A,$02
        LD      ($FEF0),A       ; write Byte 2 for ?? in Static RAM
L154D:  LD      A,($FEF2)       ; read Byte ?? for ?? in Static RAM
        CP      $01
        JR      NZ,L1559                ; (+$05)
        LD      A,$02
        LD      ($FEF2),A       ; write Byte 2 for ?? in Static RAM
L1559:  POP     AF
        EI
        RET

; More of Third Interrupt Routine ??
L155C:  LD      ($FEE2),BC      ; write WORD ?? into ?? in Static RAM
L1560:  XOR     A
        LD      ($FEEA),A       ; divg write Byte 0 for ?? in Static RAM
        EI
        LD      A,($FEEB)       ; read Byte ?? for ?? in Static RAM
        OR      A
        JR      Z,L1580                 ; (+$15)
        DI
        XOR     A
        LD      ($FEEB),A       ; write Byte 0 for ?? in Static RAM
        LD      BC,($FEE2)      ; read WORD ?? for ?? in Static RAM
        LD      IY,($FEE4)      ; read WORD ?? for IndexY in Static RAM
        LD      HL,$0000
        LD      ($FEE6),HL      ; vaddr write "Vector ADDRess" base in Static RAM
        JP      (IY)            ; indexed RETurn

; ??
L1580:  LD      ($FEDE),SP      ; write Stack Pointer into WORD ?? in Static RAM
        LD      ($FEE0),IX      ; write IndeX into WORD ?? for in Static RAM
        LD      HL,L1182        ; point to 2 word table #1 for ??
        CALL    L1138           ; (HL) -> new IY
        LD      A,L
        OR      H
        JR      NZ,L15EA                ; (+$58)
        LD      ($FEE6),DE      ; vaddr write "Vector ADDRess" base in Static RAM
        PUSH    DE
        POP     IY
        LD      A,(IY+$0A)
        OR      A
        JR      NZ,L15E5                ; (+$46)
        BIT     4,(IY+$04)      ; ?? bit 4 of TSTAT offset 4
        JR      Z,L15B4                 ; (+$0f)
        LD      L,(IY+$18)
        LD      H,(IY+$19)
        PUSH    HL
        POP     IX
        BIT     0,(IY+$04)      ; ?? bit 0 of TSTAT offset 4
        JR      L15B6                   ; (+$02)

; ??
L15B4:  XOR     A
        INC     A
L15B6:  JR      Z,L15C5                 ; (+$0d)
        LD      BC,L15ED        ; point to ?? code with RST  $28 in it !!
        DEC     IX
        LD      (IX+$00),B
        DEC     IX
        LD      (IX+$00),C
L15C5:  BIT     0,(IY+$04)      ; ?? bit 0 of TSTAT offset 4
        JR      Z,L15D7                 ; (+$0c)
        LD      C,(IY+$00)
        LD      B,(IY+$01)
        RES     0,(IY+$04)      ; ?? bit 0 of TSTAT offset 4
        JR      L15DD                   ; (+$06)

; ??
L15D7:  LD      C,(IY+$02)      ; TRC offset 2 (?? or TOPAPCL offset 2 ??)
        LD      B,(IY+$03)      ; TD offset 3 (?? or TOPAPCH offset 3 ??)
L15DD:  LD      IY,($FEE4)      ; read WORD ?? for IndexY in Static RAM
        JP      (IY)            ; indexed RETurn

; L15E3: not used ??
        JR      L15E8                   ; (+$03)

; ??
L15E5:  CALL    L1192           ; do point to 2 word table #1 for ?? then ??
L15E8:  JR      L15EA                   ; (+$00) to fall through ...

; ??
L15EA:  JP      L160A                   ; not JR ?? ...

; ?? does ?? code with RST  $28 in it !!
L15ED:  RST     $28             ; ONLY VALID User ReSTart $28 ??
        DEC     D
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        SET     0,(IY+$04)      ; ?? bit 0 of TSTAT offset 4
        RES     1,(IY+$04)      ; TBACT bit 1 of TSTAT offset 4
; Terse restore point
L15FB:  BIT     4,(IY+$04)      ; ?? bit 4 of TSTAT offset 4
        JR      Z,L160A                 ; (+$09)
        PUSH    IX
        POP     HL
        LD      (IY+$18),L
        LD      (IY+$19),H
L160A:  LD      SP,($FEDE)      ; read WORD ?? for Stack Pointer in Static RAM
        LD      IX,($FEE0)      ; read WORD ?? for IndeX in Static RAM
        JP      L1560           ; to More of Third Interrupt Routine ??

; TERSE Forth ;TASK: commented out ?? does ??
L1615:  EX      (SP),IY
        LD      (IY+$01),B
        LD      (IY+$00),C
        LD      A,(IY+$04)      ; TSTAT offset 4
        BIT     1,A
        JR      Z,L1627                 ; (+$03)
        CPL
        BIT     3,A
L1627:  JR      NZ,L1633                ; (+$0a)
        CALL    L1192           ; do point to 2 word table #1 for ?? then ??
        LD      A,($FEF4)       ; read Byte ?? for ?? in Static RAM
        DEC     A
        LD      (IY+$0B),A
L1633:  RES     3,(IY+$04)      ; ?? bit 3 of TSTAT offset 4
        SET     1,(IY+$04)      ; TBACT bit 1 of TSTAT offset 4
        SET     0,(IY+$04)      ; ?? bit 0 of TSTAT offset 4
        PUSH    IY
        POP     HL
        LD      DE,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        OR      A
        SBC     HL,DE
        JR      NZ,L1652                ; (+$07)
        CALL    L1192           ; do point to 2 word table #1 for ?? then ??
        POP     HL
        JP      L15FB                   ; not JR ?? to restore

; ??
L1652:  POP     IY
        LD      C,(IX+$00)
        INC     IX
        LD      B,(IX+$00)
        INC     IX
        JP      (IY)            ; indexed RETurn

; TERSE Forth SYNC does ??
L1660:  LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      (IY+$02),C      ; TRC offset 2 (?? or TOPAPCL offset 2 ??)
        LD      (IY+$03),B      ; TD offset 3 (?? or TOPAPCH offset 3 ??)
        CALL    L1192           ; do point to 2 word table #1 for ?? then ??
        JP      L15FB                   ; not JR ?? to restore

; TERSE Forth SLEEP does ??
L1670:  LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      (IY+$02),C      ; TRC offset 2 (?? or TOPAPCL offset 2 ??)
        LD      (IY+$03),B      ; TD offset 3 (?? or TOPAPCH offset 3 ??)
        SET     3,(IY+$04)      ; ?? bit 3 of TSTAT offset 4
        JP      L15FB                   ; not JR ?? to restore

; ??
L1681:  EX      (SP),IY
        PUSH    BC
        BIT     3,(IY+$04)      ; ?? bit 3 of TSTAT offset 4
        JR      Z,L1698                 ; (+$0e)
        CALL    L1192           ; do point to 2 word table #1 for ?? then ??
        LD      A,($FEF4)       ; read Byte ?? for ?? in Static RAM
        DEC     A
        LD      (IY+$0B),A
        RES     3,(IY+$04)      ; ?? bit 3 of TSTAT offset 4
L1698:  POP     BC
        POP     IY
        JP      (IY)            ; indexed RETurn

; TERSE Forth vect does ??
L169D:  EX      AF,AF'
        LD      A,B
        LD      H,(IY+$1D)      ; VXH offset 29
        LD      L,(IY+$1C)      ; VX offset 28
        LD      D,(IY+$27)
        LD      E,(IY+$26)
        EXX
        LD      B,A
        LD      H,(IY+$1F)      ; VYH offset 31
        LD      L,(IY+$1E)      ; VY offset 30
        LD      D,(IY+$29)      ; VDYH offset 41
        LD      E,(IY+$28)      ; VDY offset 40
L16B9:  ADD     HL,DE
        EXX
        ADD     HL,DE
        EXX
        DJNZ    L16B9                   ; (-$06)
        PUSH    HL
        EXX
        POP     DE
        EX      DE,HL
        EX      AF,AF'
        RET

; ?? does "PUSH HOOKed routine" (only from mastervmr if ?? bit 6 of TVMROPT offset 16 set !!)
L16C5:  EXX
        LD      H,(IY+$17)      ; read Word for HOOKed routine ??
        LD      L,(IY+$16)
        PUSH    HL
        EXX
        RET

; ?? does ?? (only from mastervmr CALL !!)
L16CF:  XOR     A
        PUSH    HL
        SBC     HL,DE
        EX      AF,AF'
        POP     HL
        SBC     HL,BC
        JR      NC,L16DE                ; (+$05)
        EX      AF,AF'
        JR      NC,L16E4                ; (+$08)
        JR      L16E3                   ; (+$05)

; ??
L16DE:  EX      AF,AF'
        JR      C,L16E4                 ; (+$03)
        JR      Z,L16E4                 ; (+$01)
L16E3:  RET

; ??
L16E4:  INC     A
        SET     2,(IY+$12)      ; TBDEST bit 2 of TCHGSTAT offset 18
        RET
; end of only from mastervmr CALL ??

; ?? does ?? (only from mastervmr if ?? bit 3 of TVMROPT offset 16 set ...
; ... but only if TBNOVECT bit 5 of TVMROPT offset 16 also set !!)
L16EA:  EX      AF,AF'
        PUSH    HL
        PUSH    DE
        EXX
        POP     DE
        BIT     3,(IY+$11)      ; bit 3 ?? of TVMROPT2 offset 17
        JR      Z,L170B                 ; (+$16)
        LD      H,(IY+$32)
        LD      L,(IY+$31)
        LD      B,(IY+$1D)       ; VXH offset 29
        LD      C,(IY+$1C)       ; VX offset 28
        CALL    L16CF
        AND     A
        JR      Z,L170B                 ; (+$04)
        SET     4,(IY+$13)      ; ?? bit 4 of TCHGSTAT2 offset 19
L170B:  POP     DE
        BIT     4,(IY+$11)      ; ?? bit 4 ?? of TVMROPT2 offset 17
        JR      Z,L1728                 ; (+$16)
        LD      H,(IY+$34)
        LD      L,(IY+$33)
        LD      B,(IY+$1F)      ; VYH offset 31
        LD      C,(IY+$1E)      ; VY offset 30
        CALL    L16CF
        AND     A
        JR      Z,L1728                 ; (+$04)
        SET     5,(IY+$13)      ; ?? bit 5 TCHGSTAT2 offset 19
L1728:  EX      AF,AF'
        EXX
        RET

; ?? does ?? (only from mastervmr if ?? bit 7 of TVMROPT set !!)
L172B:  EX      AF,AF'
        LD      C,$00
        LD      D,C
        LD      H,(IY+$0F)
        LD      L,(IY+$0E)      ; TTIMER offset 14 for "Time for TIMER"
        LD      A,L
        LD      E,B
        OR      A
        SBC     HL,DE
        JR      NC,L1744                ; (+$08)
        LD      C,L
        LD      B,A
        SET     3,(IY+$12)      ; ?? bit 3 of TCHGSTAT offset 18
        JR      L174A                   ; (+$06)

L1744:  JR      NZ,L174A                ; (+$04)
        SET     3,(IY+$12)      ; ?? bit 3 of TCHGSTAT offset 18
L174A:  EX      AF,AF'
        RET

; ?? does ?? (only from mastervmr !!)
L174C:  EX      AF,AF'
        LD      L,(IY+$14)      ; MYFLAG read Word for MY FLAG address
        LD      H,(IY+$15)
        LD      A,(HL)          ; MYFLAG read Byte for ( build in neato FLAG ) value
        OR      A
        JR      Z,L1761                 ; (+$0a)
        LD      (HL),$00        ; MYFLAG clear Byte for ( build in neato FLAG )
        SET     4,(IY+$12)      ; ?? bit 4 of TCHGSTAT offset 18
        SET     5,(IY+$10)      ; TBNOVECT bit 5 of TVMROPT offset 16
L1761:  EX      AF,AF'
        RET

; ?? does ?? (only from mastervmr if ?? bit 4 of ?? offset 37 set ...
; ... but only if TBNOVECT bit 5 of TVMROPT offset 16 also set !!)
L1763:  EX      AF,AF'
        EXX
        LD      L,(IY+$35)      ; read CURRENT Animation table ENTRY Duration
        LD      H,(IY+$36)
        BIT     2,(IY+$25)      ; ?? bit 2 of ?? offset 37
        JR      Z,L177F                 ; (+$0e)
        LD      E,(IY+$3A)      ; VPERINX offset 58 for "VECTORS PERspective INdeX"
        LD      D,$00
        SLA     E               ; times 2
        RL      D
        ADD     HL,DE
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        EX      DE,HL
L177F:  BIT     1,(IY+$25)      ; ?? bit 1 of ?? offset 37
        JR      Z,L17A9                 ; (+$24)
        LD      A,(IY+$3B)      ; VANGLE offset 59 for "Vector ANGLE"
        LD      B,(IY+$39)
        LD      D,$FF
L178D:  SRL     D               ; divide by 2
        RRA                     ; move CY right
        DJNZ    L178D                   ; (-$05)
        ADC     A,$00
        AND     D
        LD      E,A
        LD      D,$00
        ADD     HL,DE
        ADD     HL,DE
        ADD     HL,DE
        LD      A,(IY+$1A)
        AND     $3F
        OR      (HL)
        LD      (IY+$1A),A
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        EX      DE,HL
L17A9:  BIT     0,(IY+$25)      ; ?? bit 0 of ?? offset 37
        JP      Z,L1820
        EXX
        LD      A,B
        EXX
        LD      B,A
        LD      A,(IY+$37)      ; VANIMTIMER offset 55
        LD      E,(IY+$38)      ; VANIMINX offset 56
        LD      C,E
        LD      D,$00
        ADD     HL,DE
        ADD     HL,DE
        ADD     HL,DE
        BIT     3,(IY+$25)      ; ?? bit 3 of ?? offset 37
        JP      Z,L17F6
        ADD     HL,DE
        INC     HL
L17C9:  SUB     B
        JP      NC,L17CE
        CP      A
L17CE:  JP      NZ,L17F3
        NEG
        LD      B,A
        INC     HL
        INC     HL
        INC     HL
        INC     C
L17D8:  LD      A,(IY+$1A)
        AND     $3F
        OR      (HL)
        LD      (IY+$1A),A
        INC     HL
        LD      A,(HL)
        OR      A
        JP      NZ,L17F0
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        EX      DE,HL
        LD      C,$00
        JR      L17D8                   ; (-$18)

L17F0:  JP      L17C9                   ; not JR ??

L17F3:  JP      L1815                   ; not JR ??

L17F6:  SUB     B
        JP      NC,L17FB
        CP      A
L17FB:  JP      NZ,L1815
        NEG
        LD      B,A
        INC     HL
        INC     HL
        INC     HL
        INC     C
        LD      A,(HL)
        OR      A
        JP      NZ,L1812
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        EX      DE,HL
        LD      A,(HL)
        LD      C,$00
L1812:  JP      L17F6                   ; not JR ??

L1815:  INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        EX      DE,HL
        LD      (IY+$37),A      ; VANIMTIMER offset 55
        LD      (IY+$38),C      ; VANIMINX offset 56
L1820:  LD      (IY+$21),H      ; write Word PATTERN address
        LD      (IY+$20),L
        EXX
        EX      AF,AF'
        RET
; end of only from mastervmr ??

; ?? does ?? (CONTINUES mastervmr)
L1829:  LD      A,(IY+$0E)      ; TTIMER offset 14 for "Time for TIMER"
        SUB     B
        LD      (IY+$0E),A      ; TTIMER offset 14 for "Time for TIMER"
        LD      A,(IY+$0F)
        SBC     A,$00
        LD      (IY+$0F),A
        LD      B,(IY+$0C)      ; TSCALE offset 12
        XOR     A
L183C:  SUB     C
        DJNZ    L183C                   ; (-$03)
        ADD     A,(IY+$0B)
        LD      (IY+$0B),A
        BIT     3,(IY+$24)      ; is UNKNOWN bit 3 of VLOGICSTAT offset 36 set ?
        JP      NZ,L136A
        BIT     5,(IY+$10)      ; TBNOVECT bit 5 of TVMROPT offset 16
        JP      NZ,L136A
        BIT     CMDIR,(IY+$24) ; is CMDIR bit 0 of VLOGICSTAT offset 36 set ?
        JP      NZ,L189E
        LD      A,(IY+$22)      ; VOMAGIC offset 34
        XOR     (IY+$1A)
        JP      NZ,L189E
        LD      A,(IY+$2A)      ; VOPAT offset 42
        XOR     (IY+$20)        ; mask with Word PATTERN address
        JP      NZ,L189E
        LD      A,(IY+$2B)      ; VOPATH offset 43
        XOR     (IY+$21)
        JP      NZ,L189E
        PUSH    HL
        LD      H,(IY+$1D)       ; VXH offset 29
        LD      L,(IY+$1C)       ; VX offset 28
        LD      A,$C0
        AND     L
        LD      L,A
        LD      A,$C0
        AND     E
        LD      C,A
        LD      B,D
        XOR     A
        SBC     HL,BC
        POP     HL
        JR      NZ,L189E                ; (+$13)
        PUSH    HL
        LD      B,(IY+$1F)      ; VYH offset 31
        LD      C,(IY+$1E)      ; VY offset 30
        LD      A,$C0
        AND     L
        LD      L,A
        LD      A,$C0
        AND     C
        LD      C,A
        XOR     A
        SBC     HL,BC
        POP     HL
L189E:  LD      (IY+$1F),H      ; VYH offset 31
        LD      (IY+$1E),L      ; VY offset 30
        LD      (IY+$1D),D      ; VXH offset 29
        LD      (IY+$1C),E      ; VX offset 28
        JP      Z,L136A
        RES     CMDIR,(IY+$24) ; clear CMDIR bit 0 of VLOGICSTAT offset 36
        CALL    L11DF           ; do "PREPARE an Image at full-scale XY offsets"
        BIT     2,(IY+$04)      ; is TBMISSLE bit 2 of TSTAT offset 4 clear ?
        JP      Z,L11AF         ; to check ??, increment ?? and point to 2 word table #3 or #4 for ?? then ??
        SET     CMFLOP,(IY+$24) ; else don't, just set CMFLOP bit 5 of VLOGICSTAT if ??
        RET
; end of CONTINUES mastervmr ?? routine below !!

; TERSE Forth mastervmr ?? routine
L18C0:  LD      B,$00
        LD      C,(IY+$0C)      ; TSCALE offset 12
        CP      C
        JP      C,L11A5         ; if ?? to vm-que-in "increment ?? and point to 2 word table #2 for ??
L18C9:  SUB     C
        INC     B
        CP      C
        JP      NC,L18C9
        LD      C,A
        LD      A,($FEF4)       ; read Byte ?? for ??
        SUB     C
        LD      (IY+$0B),A
        LD      C,$00
        LD      A,(IY+$10)      ; read TVMROPT offset 16
        BIT     1,A
        CALL    NZ,L174C
        BIT     7,A             ; ?? bit 7 of TVMROPT
        CALL    NZ,L172B
        BIT     5,A             ; TBNOVECT bit 5 of TVMROPT offset 16
        JR      NZ,L18F9                ; (+$0f) to skip
        CALL    L88A3           ; NEWVECT does ?? in Upper ROMs ??
        BIT     3,A             ; ?? bit 3 of TVMROPT offset 16
        CALL    NZ,L16EA
        BIT     4,(IY+$25)      ; ?? bit 4 of ?? offset 37
        CALL    NZ,L1763
L18F9:  BIT     6,A             ; ?? bit 6 of TVMROPT offset 16
        CALL    NZ,L16C5        ; ?? do "PUSH HOOKed routine
        JP      L1829                   ; not JR ?? to CONTINUE mastervmr !!
; NOT end of mastervmr ?? (see CONTINUES mastervmr ?? routine above !!)

; { BLOCK 0264 }
;     b h S S S S UR> ZGO )
; <STKH
; CODE ZGO ( load master vmr routine and special sur )
;  vaddr LIYD,
;  TBNOVECT TVMROPT Y RESX,
;  mastervmr H LXI,
;  H TVMRH Y STX,
;  L TVMRL Y STX,
;  H POP,
;  H TSURH Y STX,
;  L TSURL Y STX,
;  0 TCHGSTAT Y MVIX, ( zero chgstat )
;  0 TCHGSTAT2 Y MVIX, ( zero chgstat2 )
;  A XRA,
;  TSCALE Y CMPX,
;  =, IF,
;   1 TSCALE Y MVIX,
;  THEN,
;  TTBMAX Y CMPX,
;  =, IF,
;   0FF TTBMAX Y MVIX,
;  THEN,
;  C TOPAPCL Y STX,
;  B TOPAPCH Y STX,
;  vm-que-in CALL,
;  restore JMP,
; STK>
; -->
;
; ZGO does "load master VMR routine and special SUR ??" ?? routine
; ?? does ?? with TBNOVECT of TVMROPT cleared (or WAIT ?? with TBNOVECT of TVMROPT set)
L1901:  LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        RES     5,(IY+$10)      ; TBNOVECT bit 5 of TVMROPT offset 16
L1909:  LD      HL,L18C0        ; mastervmr point to routine
        LD      (IY+$07),H      ; TVMRH offset 7
        LD      (IY+$06),L      ; TVMRL offset 6
        LD      HL,$1367        ; point to ?? routine ?? (!! H POP, in source !!)
        LD      (IY+$09),H      ; TSURH offset 9
        LD      (IY+$08),L      ; TSURL offset 8
        LD      (IY+$12),$00    ; TCHGSTAT offset 18 ( zero chgstat )
        LD      (IY+$13),$00    ; TCHGSTAT2 offset 19 ( zero chgstat2 )
        XOR     A
        CP      (IY+$0C)        ; TSCALE offset 12
        JR      NZ,L192D                ; (+$04) IF = False skip
        LD      (IY+$0C),$01    ; TSCALE offset 12
L192D:  CP      (IY+$0D)        ; TTBMAX offset 13
        JR      NZ,L1936                ; (+$04) IF = False skip
        LD      (IY+$0D),$FF    ; TTBMAX offset 13
L1936:  LD      A,($FEF4)       ; read Byte ?? for ?? in Static RAM ?? (!! NOT in source !!)
        DEC     A
        LD      (IY+$0B),A
        LD      (IY+$02),C      ; TOPAPCL offset 2
        LD      (IY+$03),B      ; TOPAPCH offset 3
        CALL    L11A5           ; vm-que-in do "increment ?? and point to 2 word table #2 for ?? then ??"
        JP      L15FB           ; to ?? restore
; end of ( load master VMR routine and special SUR ) !!

; TERSE Forth WAIT does "ZGO but ... with TBNOVECT of TVMROPT set"
L1949:  LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        SET     5,(IY+$10)      ; TBNOVECT bit 5 of TVMROPT offset 16
        JP      L1909                   ; not JR ?? to ZGO but ...

; L1954: great year, not used ??
        EXX
        POP     BC
        DEC     C
        LD      HL,$0001
        ADD     HL,SP
        ADD     HL,BC
        ADD     HL,BC
L195D:  LD      D,(HL)
        DEC     HL
        LD      E,(HL)
        PUSH    DE
        DEC     HL
        DEC     C
        JP      P,L195D
        EXX
        JP      (IY)            ; indexed RETurn

; good year, does "multiply Low byte of Top of Stack by 16"
L1969:  POP     HL
        LD      A,L
        RLCA
        RLCA
        RLCA
        RLCA
        LD      L,A
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; ?? does ??
L1973:  XOR     A
        LD      ($FEEA),A       ; divg write Byte 0 for ?? in Static RAM
        LD      HL,$FEE9        ; point to Word ?? for ?? in Static RAM
        OR      (HL)
        RET     Z               ; bail if ?? empty
; begin Save Environment and JumP to ??
        DI                      ; Disable Interrupts
        PUSH    AF
        PUSH    BC
        PUSH    DE
        PUSH    HL
        EXX
        EX      AF,AF'
        PUSH    AF
        PUSH    BC
        PUSH    DE
        PUSH    HL
        PUSH    IY
        PUSH    IX
        EXX
        LD      D,(HL)
        DEC     HL
        LD      E,(HL)
        EX      DE,HL
        JP      (HL)

; "clear ?? word"
L1991:  XOR     A
        LD      ($FEE9),A       ; write Byte 0 for ?? in Static RAM
        INC     A
        LD      ($FEEA),A       ; divg write Byte 1 for ?? in Static RAM
        RET

; EIVG does ?? from Terse
L199A:  CALL    L1973
        JP      (IY)            ; indexed RETurn

; TERSE Forth DIVG does "clear ?? word"
L199F:  CALL    L1991           ; do "clear ?? word"
        JP      (IY)            ; indexed RETurn

; ??
L19A4:  INC     E
        XOR     A
        SCF
L19A7:  RLA
        DEC     E
        JR      NZ,L19A7                ; (-$04)
        RET

; L19AC: not used ??
        POP     HL
        POP     DE
        CALL    L19A4
        LD      DE,$0000        ; 0 for False
        AND     (HL)
        JR      Z,L19B8                 ; (+$01)
        INC     E               ; 1 for True
L19B8:  PUSH    DE
        JP      (IY)            ; indexed RETurn

; L19BB: not used ??
        POP     HL
        POP     DE
        CALL    L19A4
        OR      (HL)
        LD      (HL),A
        JP      (IY)            ; indexed RETurn

; L19C4: not used ??
        POP     HL
        POP     DE
        CALL    L19A4
        XOR     $FF
        AND     (HL)
        LD      (HL),A
        JP      (IY)            ; indexed RETurn

; L19CF: does MUTE both SOUND Channels (not used ??)
        RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $15             ; 21 for &(VOLC #1)=0
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $16             ; 22 for &(VOLAB #1)=0
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $55             ; 85 for &(VOLC #2)=0
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $56             ; 86 for &(VOLAB #2)=0
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L00B0           ; ... TerseRETurn

;
; ?? does SHIFT for generating Pseudo-RANDOM Numbers routine
L19EE:  PUSH    BC
        LD      BC,($FE3D)      ; read Word Low RANdom SHifT register in Static RAM
        LD      HL,$1321        ; 4897 for Word Low RANSHT Initialize
        ADD     HL,BC
        PUSH    HL
        LD      HL,$2776        ; 10102 for Word High RANSHT + 2 Initialize
        ADC     HL,BC
        LD      DE,($FE3F)      ; read Word High RANSHT + 2 in Static RAM
        ADD     HL,DE
        EX      (SP),HL         ; mix it up
        ADD     HL,BC
        EX      (SP),HL
        ADC     HL,DE
        EX      (SP),HL
        ADD     HL,BC
        EX      (SP),HL
        ADC     HL,DE
        EX      (SP),HL
        LD      D,E             ; Two Words of ??
        LD      E,B
        LD      B,C
        LD      C,$00
        ADD     HL,BC
        LD      ($FE3D),HL      ; write Word Low RANSHT register in Static RAM
        EX      (SP),HL
        ADC     HL,DE
        LD      ($FE3F),HL      ; write Word High RANSHT + 2 in Static RAM
        POP     DE
        POP     BC
        RET

; ?? does Multiply for RANGED Pseudo-RANDOM Numbers routine
L1A1F:  PUSH    BC
        EXX
        LD      HL,$0000        ; 0 for ?? First Word
        LD      D,H
        LD      E,L
        EXX
        PUSH    DE
        POP     BC
        EX      DE,HL
        LD      HL,$0000        ; 0 for ?? Second Word
L1A2D:  SRL     B               ; for Powers of Two
        RR      C
        JR      NC,L1A38                ; (+$05) skip if BC = Not
        ADD     HL,DE           ; for Two Words
        EXX
        ADC     HL,DE
        EXX
L1A38:  LD      A,B
        OR      C
        JR      Z,L1A49                 ; (+$0d) bail if BC Empty
        SLA     E               ; for Two Words
        RL      D
        EXX
        RL      E
        RL      D
        EXX
        JP      L1A2D                   ; not JR ?? loop for next BC

L1A49:  EXX
        POP     BC
        RET

; TERSE Forth rnd does "SHIFT and limit RANGE for Next Pseudo-RANDOM Number" routine
L1A4C:  PUSH    DE
        CALL    L19EE           ; do SHIFT for generating Pseudo-RANDOM Numbers
        POP     DE
        CALL    L1A1F           ; do Multiply for RANGED Pseudo-RANDOM Numbers
        RET

; ?? does Un-RANGED for Pseudo-RANDOM Number (Byte 0 to 255 UNmasked ??)
L1A55:  CALL    L19EE           ; do SHIFT for generating Pseudo-RANDOM Numbers
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth RND does "SHIFT and limit RANGE for Next Pseudo-RANDOM Number"
L1A5B:  CALL    L19EE           ; do SHIFT for generating Pseudo-RANDOM Numbers
        POP     DE
        CALL    L1A1F           ; do Multiply for RANGED Pseudo-RANDOM Numbers
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth xadj does "convert Screen +/- X REL to Bytes offset from Left side"
L1A65:  LD      DE,$00A0        ; 160 for ?? HALF of BITSPL
        ADD     HL,DE
        XOR     A               ; X RELative divided by 4
        SRA     H
        RR      L
        RRA
        SRA     H
        RR      L
        RRA
        LD      H,L             ; return Word X offset
        LD      L,A             ; return Rotated Right bits
        RET

; ?? does "Divide DE by 4" routine
L1A77:  SRA     D
        RR      E
        SRA     D
        RR      E
        RET

; TERSE Forth DE*4 does "Multiply DE by 4" routine
L1A80:  SLA     E
        RL      D
        SLA     E
        RL      D
        RET

; TERSE Forth xlookadj does "X LOOK ADJust" routine
L1A89:  BIT     7,H
        JR      Z,L1A91                 ; (+$04)
        LD      A,$FF
        JR      L1A92                   ; (+$01)

L1A91:  XOR     A
L1A92:  SLA     L
        RL      H
        RLA
        SLA     L
        RL      H
        RLA
        LD      L,H
        LD      H,A
        OR      A
        LD      DE,$00A0        ; 160 for ??
        SBC     HL,DE
        RET

; ?? does "Divide DE by 4, then Negate" routine
L1AA5:  SRA     D
        RR      E
        SRA     D
        RR      E
        LD      A,D
        CPL
        LD      D,A
        LD      A,E
        CPL
        LD      E,A
        INC     DE
        RET

; TERSE Forth COMPDE*4 does "Negate DE, then Multiply by 4" routine
L1AB5:  LD      A,D
        CPL
        LD      D,A
        LD      A,E
        CPL
        LD      E,A
        INC     DE
        SLA     E
        RL      D
        SLA     E
        RL      D
        RET

; TERSE Forth yadj does "convert +/- Y REL to PIXEL lines from the Top of Screen"
L1AC5:  CALL    L053E           ; do Two's COMPLEMENT of HL
        LD      DE,$0065        ; 101 for ?? roughly HALF of VERBL
        ADD     HL,DE
        XOR     A               ; Y RELative divided by 4
        SRA     H
        RR      L
        RRA
        SRA     H
        RR      L
        RRA
        LD      H,L             ; save Word Y offset
        LD      L,A             ; save Rotated Right bits
        RET

; TERSE Forth ylookadj does "Y LOOK ADJust" routine
L1ADA:  BIT     7,H
        JR      Z,L1AE2                 ; (+$04)
        LD      A,$FF
        JR      L1AE3                   ; (+$01)

L1AE2:  XOR     A
L1AE3:  SLA     L
        RL      H
        RLA
        SLA     L
        RL      H
        RLA
        LD      L,H
        LD      H,A
        OR      A
        LD      DE,$0065        ; 101 for ??
        SBC     HL,DE
        CALL    L053E           ; do Two's COMPLEMENT of HL
        RET

; TERSE Forth ANGLE! does "SET ANGLE"
L1AF9:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$003B        ; VANGLE offset 59 for "Vector ANGLE"
        ADD     HL,DE
        POP     DE
        LD      (HL),E
        JP      (IY)            ; indexed RETurn

; TERSE Forth TIMER!-ON does "save TTIMER and START TIMER"
L1B04:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0010        ; TVMROPT offset 16 for ??
        ADD     HL,DE
        SET     7,(HL)          ; ?? bit 7 of TVMROPT activates "Vector TIMER"
        LD      DE,$FFFE        ; -2 point to TTIMER offset 14 for "Time for TIMER"
        ADD     HL,DE
        POP     DE
        LD      (HL),E          ; save it
        INC     HL
        LD      (HL),D
        JP      (IY)            ; indexed RETurn

; L1B17: ?? does "RE-START TIMER" (not used)
        LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0010        ; TVMROPT offset 16 for ??
        ADD     HL,DE
        SET     7,(HL)          ; ?? bit 7 of TVMROPT activates "Vector TIMER"
        JP      (IY)            ; indexed RETurn

; L1B22: ?? does "PAUSE TIMER" (not used)
        LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0010        ; TVMROPT offset 16 for ??
        ADD     HL,DE
        RES     7,(HL)          ; ?? bit 7 of TVMROPT de-activates "Vector TIMER"
        JP      (IY)            ; indexed RETurn

; L1B2D: ?? does "Set TTIMER" (not used)
        LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$000E        ; TTIMER offset 14 for "Time for TIMER"
        ADD     HL,DE
        POP     DE
        LD      (HL),E          ; save it
        INC     HL
        LD      (HL),D
        JP      (IY)            ; indexed RETurn

; L1B3A: ?? does ?? (not used)
        LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0012        ; TCHGSTAT offset 18 for ??
        ADD     HL,DE
        LD      DE,$0000        ; 0 for False
        BIT     3,(HL)          ; ?? bit 3 of TCHGSTAT offset 18
        JR      Z,L1B49                 ; (+$01)
        INC     E               ; 1 for True
L1B49:  PUSH    DE
        JP      (IY)            ; indexed RETurn

; TERSE Forth FLAG!-ON does ??
L1B4C:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0010        ; TVMROPT offset 16 for ??
        ADD     HL,DE
        SET     1,(HL)          ; ?? bit 1 activates MY FLAG ??
        LD      DE,$0004        ; 4 for ?? (actually offset 20 by now !!)
        ADD     HL,DE
        POP     DE
        LD      (HL),E          ; write Word for MY FLAG address ??
        INC     HL
        LD      (HL),D
        JP      (IY)            ; indexed RETurn

; TERSE Forth FLAG? does ??
L1B5F:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0012        ; TCHGSTAT offset 18 for ??
        ADD     HL,DE
        LD      DE,$0000        ; 0 for False
        BIT     4,(HL)          ; ?? bit 4 of TCHGSTAT offset 18
        JR      Z,L1B6E                 ; (+$01)
        INC     E               ; 1 for True
L1B6E:  PUSH    DE
        JP      (IY)            ; indexed RETurn

; TERSE Forth DESTX! does "convert +/- X REL to ABSolute PIXELs and save in VDESTX ??"
L1B71:  POP     HL
        CALL    L1A65           ; xadj do "convert Screen +/- X REL to Bytes offset from Left"
        PUSH    HL
        LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0031        ; VDESTX offset 49 for ?? roughly QUARTER of VERBL
        ADD     HL,DE
        POP     DE
        LD      (HL),E          ; save Word X offset
        INC     HL
        LD      (HL),D          ; save  Rotated Right bits
        JP      (IY)            ; indexed RETurn

; TERSE Forth DESTY! does "convert +/- Y REL to PIXEL lines and save in VDESTY ??"
L1B83:  POP     HL
        CALL    L1AC5           ; yadj does "convert +/- Y REL to PIXEL lines from Top of Screen"
        PUSH    HL
        LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0033        ; VDESTY offset 51 for ??
        ADD     HL,DE
        POP     DE
        LD      (HL),E          ; save Word Y offset
        INC     HL
        LD      (HL),D
        JP      (IY)            ; indexed RETurn

; TERSE Forth DEST? does ??
L1B95:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0012        ; TCHGSTAT offset 18 for ??
        ADD     HL,DE
        LD      DE,$0000        ; 0 for False
        BIT     2,(HL)          ; TBDEST bit 2 of TCHGSTAT offset 18
        JR      Z,L1BA4                 ; (+$01)
        INC     E               ; 1 for True
L1BA4:  PUSH    DE
        JP      (IY)            ; indexed RETurn

; L1BA7: does ?? (not used)
        LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0010        ; TVMROPT offset 16 for ??
        ADD     HL,DE
        SET     0,(HL)          ; ?? bit 0 activates ??
        JP      (IY)            ; indexed RETurn

; L1BB2: does ?? (not used)
        LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0010        ; TVMROPT offset 16 for ??
        ADD     HL,DE
        RES     0,(HL)          ; ?? bit 0 de-activates ??
        JP      (IY)            ; indexed RETurn

; L1BBD: does ?? (not used)
        LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0012        ; TCHGSTAT offset 18 for ??
        ADD     HL,DE
        LD      DE,$0000        ; 0 for False
        BIT     1,(HL)          ; ?? bit 1 of TCHGSTAT offset 18
        JR      Z,L1BCC                 ; (+$01)
        INC     E               ; 1 for True
L1BCC:  PUSH    DE
        JP      (IY)            ; indexed RETurn

; TERSE Forth HOOK!-ON does ??
L1BCF:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0010        ; TVMROPT offset 16 for ??
        ADD     HL,DE
        SET     6,(HL)          ; ?? bit 6 activates HOOK ??
        LD      DE,$0006        ; 6 for ?? (actually offset 22 by now !!)
        ADD     HL,DE
        POP     DE
        LD      (HL),E          ; write Word for HOOKed routine ??
        INC     HL
        LD      (HL),D
        JP      (IY)            ; indexed RETurn

; TERSE Forth ANIM! does "SET UP ?? ANIMATION LOOP (or Pattern ??)" for ??
L1BE2:  POP     HL              ; either Pattern address OR Animation table
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      E,(HL)          ; read First Byte for X offet OR NUMBER of Entries
        INC     HL
        INC     HL
        LD      A,(HL)          ; read Third Byte for Width in Bytes OR Flagged ??
        AND     $0F
        LD      D,A             ; 0 - 15 for ??
        LD      A,(IY+$25)      ; read ?? offset 37
        AND     $E0             ; for 11100000B
        BIT     7,(HL)          ; test SIGN is POSITIVE = Pattern, NEGATIVE = Animation table
        JR      Z,L1C20                 ; (+$27) if PATTERN
        SET     4,A             ; now 11110000B for ANIMATION
        OR      D               ; mix in lower nybble of Third Byte (Flag stripped !!)
        LD      (IY+$25),A      ; write ?? offset 37
        LD      D,(HL)          ; read Byte ?? with NEGATIVE ?? again
        INC     HL              ; point to DURATION of first entry
        BIT     0,D             ; is ?? set ?
        JR      Z,L1C0D                 ; (+$08) if no
        LD      (IY+$38),$00    ; VANIMINX offset 56
        LD      (IY+$37),$01    ; VANIMTIMER offset 55
L1C0D:  BIT     1,D             ; is ?? set ?
        JR      Z,L1C18                 ; (+$07) if no
        LD      (IY+$39),E      ; save NUMBER of Entries
        LD      (IY+$37),$01    ; VANIMTIMER offset 55
L1C18:  LD      (IY+$36),H      ; save First ENTRY address
        LD      (IY+$35),L
        JR      L1C2B                   ; (+$0b)

; for a PATTERN
L1C20:  DEC     HL              ; point back at original HL
        DEC     HL
        LD      (IY+$21),H      ; save Word PATTERN address ??
        LD      (IY+$20),L
        LD      (IY+$25),A      ; write 11100000B or 11110000B ?? offset 37
L1C2B:  POP     IY
        JP      (IY)            ; indexed RETurn

; L1C2F: does ?? (not used)
        LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0025        ; offset 37 for ??
        ADD     HL,DE
        RES     4,(HL)          ; ?? bit 4 of ?? offset 37
        JP      (IY)            ; indexed RETurn

; TERSE Forth PERINX! does ??
L1C3A:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$003A        ; VPERINX offset 58 for "VECTORS PERspective INdeX"
        ADD     HL,DE
        POP     DE
        LD      (HL),E
        JP      (IY)            ; indexed RETurn

; ?? does ?? routine
L1C45:  PUSH    DE
        LD      D,(IY+$1F)      ; VYH offset 31
        LD      E,(IY+$1E)      ; VY offset 30
        OR      A
        SBC     HL,DE
        POP     DE
        PUSH    AF
        CALL    C,L053E         ; if ?? do Two's COMPLEMENT of HL
        PUSH    HL
        EX      DE,HL
        LD      D,(IY+$1D)      ; VXH offset 29
        LD      E,(IY+$1C)      ; VX offset 28
        OR      A
        SBC     HL,DE
        POP     DE
        PUSH    AF
        CALL    C,L053E         ; if ?? do Two's COMPLEMENT of HL
        PUSH    HL
        SBC     HL,DE
        POP     HL
        PUSH    AF
        JR      NC,L1C6C                ; (+$01)
        EX      DE,HL
L1C6C:  PUSH    DE
        PUSH    BC
        POP     DE
        LD      B,$00
L1C71:  INC     B
        SRA     H
        RR      L
        PUSH    HL
        SBC     HL,DE
        POP     HL
        JR      Z,L1C7E                 ; (+$02)
        JR      NC,L1C71                ; (-$0d)
L1C7E:  POP     DE
        PUSH    HL
        LD      HL,$0000        ; 0 for ??
        INC     HL              ; now 1 for ??
; loop for SPEED of ?? Byte count ??
L1C84:  SRA     D               ; divide DE by 2
        RR      E
        SLA     L               ; HL times 2 (powers of 2 ??)
        RL      H
        DJNZ    L1C84                   ; (-$0a)
        LD      (IY+$0F),H
        LD      (IY+$0E),L      ; TTIMER offset 14 for "Time for TIMER"
        POP     HL
        SET     7,(IY+$10)      ; ?? bit 7 of TVMROPT offset 16 activates ??
        POP     AF
        JR      NC,L1C9D                ; (+$01)
        EX      DE,HL
L1C9D:  POP     AF
        CALL    C,L053E         ; if ?? do Two's COMPLEMENT of HL
        POP     AF
        CALL    C,L0548         ; if ?? do Two's COMPLEMENT of DE
        LD      (IY+$27),H
        LD      (IY+$26),L
        LD      (IY+$29),D      ; VDYH offset 41
        LD      (IY+$28),E      ; VDY offset 40
        RET

; A->DEST does ??
L1CB2:  POP     DE
        CALL    L1A77           ; ?? do "Divide DE by 4"
        PUSH    IY
        PUSH    BC
        PUSH    DE
        POP     BC
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      H,(IY+$34)
        LD      L,(IY+$33)
        LD      D,(IY+$32)
        LD      E,(IY+$31)
        CALL    L1C45
        POP     BC
        POP     IY
        JP      (IY)            ; indexed RETurn

; ?? does ??
L1CD3:  POP     DE
        CALL    L1A77           ; ?? do "Divide DE by 4"
        POP     HL
        PUSH    DE
        CALL    L1AC5           ; yadj does "convert +/- Y REL to PIXEL lines from Top of Screen"
        POP     DE
        PUSH    BC
        EXX
        POP     BC
        POP     HL
        CALL    L1A65           ; xadj do "convert Screen +/- X REL to Bytes offset from Left"
        PUSH    IY
        PUSH    BC
        PUSH    HL
        EXX
        PUSH    DE
        POP     BC
        POP     DE
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        CALL    L1C45
        POP     BC
        POP     IY
        JP      (IY)            ; indexed RETurn

; TERSE Forth X! does ??
L1CF8:  POP     HL
        CALL    L1A65           ; xadj do "convert Screen +/- X REL to Bytes offset from Left"
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      (IY+$1C),L      ; VX offset 28
        LD      (IY+$1D),H      ; VXH offset 29
        SET     CMDIR,(IY+$24) ; set CMDIR bit 0 of VLOGICSTAT offset 36 for ??
        POP     IY
        JP      (IY)            ; indexed RETurn

; TERSE Forth Y! does ??
L1D10:  POP     HL
        CALL    L1AC5           ; yadj does "convert +/- Y REL to PIXEL lines from Top of Screen"
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      (IY+$1E),L      ; VY offset 30
        LD      (IY+$1F),H      ; VYH offset 31
        SET     CMDIR,(IY+$24) ; set CMDIR bit 0 of VLOGICSTAT offset 36 for ??
        POP     IY
        JP      (IY)            ; indexed RETurn

; ?? does ??
L1D28:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1D10           ; Y! do ??
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; TERSE Forth ZERODXDYAXAY does ??
L1D2F:  PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        XOR     A
        LD      (IY+$26),A
        LD      (IY+$27),A
        LD      (IY+$28),A      ; VDY offset 40
        LD      (IY+$29),A      ; VDYH offset 41
        POP     IY
        JP      (IY)            ; indexed RETurn

; ?? does ?? (not used)
L1D46:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0026        ; VDX offset 38 for ??
        ADD     HL,DE
        POP     DE
        CALL    L1A77           ; ?? do "Divide DE by 4"
        LD      (HL),E
        INC     HL
        LD      (HL),D
        JP      (IY)            ; indexed RETurn

; TERSE Forth DY! does "Divide DE by 4, then Negate then save as VDY"
L1D56:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0028        ; VDY offset 40 for ??
        ADD     HL,DE
        POP     DE
        CALL    L1AA5           ; ?? do "Divide DE by 4, then Negate" routine
        LD      (HL),E
        INC     HL
        LD      (HL),D
        JP      (IY)            ; indexed RETurn

; ?? does ?? (not used)
L1D66:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0028        ; VDY offset 40 for ??
        ADD     HL,DE
        POP     DE
        CALL    L1AA5           ; ?? do "Divide DE by 4, then Negate" routine
        LD      (HL),E
        INC     HL
        LD      (HL),D
        LD      DE,$FFFD        ; -3 for ??
        ADD     HL,DE
        POP     DE
        CALL    L1A77           ; ?? do "Divide DE by 4"
        LD      (HL),E
        INC     HL
        LD      (HL),D
        JP      (IY)            ; indexed RETurn

; { BLOCK 0282 }
;         Y ( c S   3 ctctct      X@ Y@ DX@ DY@ ) <STKH
; CODE X@ ( vector address --- x )
;  H POP,
;  VX D LXI,
;  D DAD,
;  M E MOV,
;  H INX,
;  M D MOV,
;  XCHG,
;  xlookadj CALL,
;  H PUSH,
; NEXT
;
; TERSE Forth X@ does "get ( vector address --- X )"
L1D81:  POP     HL
        LD      DE,$001C        ; VX offset 28 for ??
        ADD     HL,DE
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        EX      DE,HL
        CALL    L1A89           ; xlookadj do "X LOOK ADJust"
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; CODE Y@ ( vector address --- y )
;  H POP,
;  VY D LXI,
;  D DAD,
;  M E MOV,
;  H INX,
;  M D MOV,
;  XCHG,
;  ylookadj CALL,
;  H PUSH,
; NEXT
;
; TERSE Forth Y@ does "get ( vector address --- Y )"
L1D90:  POP     HL
        LD      DE,$001E        ; VY offset 30 for ??
        ADD     HL,DE
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        EX      DE,HL
        CALL    L1ADA           ; ylookadj do "Y LOOK ADJust"
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; CODE DX@ ( vector address --- delta x )
;  H POP,
;  VDX D LXI,
;  D DAD,
;  M E MOV,
;  H INX,
;  M D MOV,
;  DE*4 CALL,
;  D PUSH,
; NEXT
;
; TERSE Forth DX@ does "get ( vector address --- Delta X )"
L1D9F:  POP     HL
        LD      DE,$0026        ; VDX offset 38 for ??
        ADD     HL,DE
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        CALL    L1A80           ; DE*4 do "Multiply DE by 4"
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; CODE DY@ ( vector address --- delta y )
;  H POP,
;  VDY D LXI,
;  D DAD,
;  M E MOV,
;  H INX,
;  M D MOV,
;  COMPDE*4 CALL,
;  D PUSH,
; NEXT
; STK>
; -->
;
; L1DAD: TERSE Forth DY@ not used ?? does "get ( vector address --- Delta Y )"
        POP     HL
        LD      DE,$0028        ; VDY offset 40 for ??
        ADD     HL,DE
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        CALL    L1AB5           ; COMPDE*4 do "Negate DE, then Multiply by 4"
        PUSH    DE
        JP      (IY)            ; indexed RETurn
; end of { BLOCK 0282 } !!

; ?? does ??
L1DBB:  PUSH    IY
        PUSH    BC
        PUSH    IX
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        CALL    L1991           ; do "clear ?? word"
        CALL    L130D           ; VERASE do "load Pattern Board values to Erase with"
        CALL    L1973           ; EIVG do ??
        POP     IX
        POP     BC
        POP     IY
        JP      (IY)            ; indexed RETurn

; ?? does ??
L1DD4:  PUSH    IY
        PUSH    BC
        PUSH    IX
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      D,(IY+$1D)      ; VXH offset 29
        LD      E,(IY+$1C)      ; VX offset 28
        LD      H,(IY+$1F)      ; VYH offset 31
        LD      L,(IY+$1E)      ; VY offset 30
        CALL    L11DF           ; do "PREPARE an Image at full-scale XY offsets"
        CALL    L1991           ; do "clear ?? word"
        CALL    L12DD           ; VWRITE do "load Pattern Board values to Draw with"
        CALL    L1973
        POP     IX
        POP     BC
        POP     IY
        JP      (IY)            ; indexed RETurn

; TERSE Forth ERASEWRITE does ??
L1DFC:  PUSH    IY
        PUSH    BC
        PUSH    IX
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      D,(IY+$1D)      ; VXH offset 29
        LD      E,(IY+$1C)      ; VX offset 28
        LD      H,(IY+$1F)      ; VYH offset 31
        LD      L,(IY+$1E)      ; VY offset 30
        CALL    L11DF           ; do "PREPARE an Image at full-scale XY offsets"
        CALL    L1991           ; do "clear ?? word"
        CALL    L132B           ; do "more Pattern Board stuff ??"
        CALL    L1973
        POP     IX
        POP     BC
        POP     IY
        JP      (IY)            ; indexed RETurn

; XPAND! ?? does "Load eXPAND value ?? but DON'T turn it ON yet"
L1E24:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$001B        ; 27 offset for ?? eXPAND value ??
        ADD     HL,DE
        POP     DE              ; eXpand value ??
        LD      (HL),E          ; write Low Byte fot ON/OFF Colors
        JP      (IY)            ; indexed RETurn

; TERSE Forth XPAND-ON does "Turn eXPAND back ON without Loading it !!"
L1E2F:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$001A        ; 26 offset for ?? Magic value ??
        ADD     HL,DE
        SET     3,(HL)          ; MRXPND bit 3 of Magic value ??
        JP      (IY)            ; indexed RETurn

; TERSE Forth XPAND-OFF does "Turn eXPAND ?? OFF"
L1E3A:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$001A        ; 26 offset for ?? Magic value ??
        ADD     HL,DE
        RES     3,(HL)          ; MRXPND bit 3 of Magic value ??
        JP      (IY)            ; indexed RETurn

; TERSE Forth XPAND!-ON does "Load eXPAND value ?? and turn it ON"
L1E45:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$001B        ; 27 offset for ?? eXPAND value ??
        ADD     HL,DE
        POP     DE              ; eXpand value ??
        LD      (HL),E
        LD      DE,$FFFF        ; -1 quantum for ?? Magic value ??
        ADD     HL,DE
        SET     3,(HL)          ; MRXPND bit 3 of Magic value ??
        JP      (IY)            ; indexed RETurn

; TERSE Forth PATTERN! does "Load Word PATTERN ?? address"
L1E56:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0020        ; 32 offset for PATTERN ?? address ??
        ADD     HL,DE
        POP     DE
        LD      (HL),E          ; write Word PATTERN address
        INC     HL
        LD      (HL),D
        JP      (IY)            ; indexed RETurn

; TERSE Forth OR-ON does "Turn OR writes ON in Magic ??"
L1E63:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$001A        ; 26 offset for ?? Magic value ??
        ADD     HL,DE
        SET     4,(HL)          ; MROR bit 4 of Magic value ??
        RES     5,(HL)          ; MRXOR bit 5 of Magic value ??
        JP      (IY)            ; indexed RETurn

; TERSE Forth XOR-ON does "Turn X-OR writes ON in Magic ??"
L1E70:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$001A        ; 26 offset for ?? Magic value ??
        ADD     HL,DE
        RES     4,(HL)          ; MROR bit 4 of Magic value ??
        SET     5,(HL)          ; MRXOR bit 5 of Magic value ??
        JP      (IY)            ; indexed RETurn

; FLIP-ON does "Turn FLIPped writes ON in Magic ??"
L1E7D:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$001A        ; 26 offset for ?? Magic value ??
        ADD     HL,DE
        RES     6,(HL)          ; MRFLOP bit 6 of Magic value ??
        SET     7,(HL)          ; MRFLIP bit 7 of Magic value ??
        JP      (IY)            ; indexed RETurn

; FLOP-ON does "Turn FLOPped writes ON in Magic ??"
L1E8A:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$001A        ; 26 offset for ?? Magic value ??
        ADD     HL,DE
        RES     7,(HL)          ; MRFLIP bit 7 of Magic value ??
        SET     6,(HL)          ; MRFLOP bit 6 of Magic value ??
        JP      (IY)            ; indexed RETurn

; TERSE Forth PLOP-ON does "Turn OR and X-OR writes OFF in Magic ??"
L1E97:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$001A        ; 26 offset for ?? Magic value ??
        ADD     HL,DE
        RES     4,(HL)          ; MROR bit 4 of Magic value ??
        RES     5,(HL)          ; MRXOR bit 5 of Magic value ??
        JP      (IY)            ; indexed RETurn

; FLIP-FLOP-ON does "Turn FLIPped and FLOPped writes ON in Magic ??" (not used)
L1EA4:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$001A        ; 26 offset for ?? Magic value ??
        ADD     HL,DE
        SET     6,(HL)          ; MRFLOP bit 6 of Magic value ??
        SET     7,(HL)          ; MRFLIP bit 7 of Magic value ??
        JP      (IY)            ; indexed RETurn

; FLIP-FLOP-OFF does "Turn FLIPped and FLOPped writes OFF in Magic ??" (not used)
L1EB1:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$001A        ; 26 offset for ?? Magic value ??
        ADD     HL,DE
        RES     7,(HL)          ; MRFLIP bit 7 of Magic value ??
        RES     6,(HL)          ; MRFLOP bit 6 of Magic value ??
        JP      (IY)            ; indexed RETurn

; TERSE Forth MAGIC! does "Load MAGIC value ??" (only used to CLEAR Magic ??)
L1EBE:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$001A        ; 26 offset for ?? Magic value ??
        ADD     HL,DE
        POP     DE
        LD      (HL),E
        JP      (IY)            ; indexed RETurn

; TERSE Forth SELF does "Push CURRENT Vector Address"
L1EC9:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth 1STWRITE does ??
L1ECF:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0024        ; 36 offset for ??
        ADD     HL,DE
        SET     0,(HL)
        SET     2,(HL)
        JP      (IY)            ; indexed RETurn

; TERSE Forth ZEROTIMEB does ??
L1EDC:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$000B        ; 11 offset for ??
        ADD     HL,DE
        LD      A,($FEF4)       ; read Byte ?? for ?? in Static RAM
        DEC     A
        LD      (HL),A
        JP      (IY)            ; indexed RETurn

; ?? does ??
L1EEA:  POP     HL
        LD      DE,$0004        ; 4 for ??
        ADD     HL,DE
        BIT     3,(HL)
        LD      DE,$0000        ; 0 for False
        JR      Z,L1EF7                 ; (+$01)
        INC     E               ; 1 for True
L1EF7:  PUSH    DE
        JP      (IY)            ; indexed RETurn

; ACTIVE? does ??
L1EFA:  POP     HL
        LD      DE,$0004        ; 4 for ??
        ADD     HL,DE
        BIT     1,(HL)
        LD      DE,$0000        ; 0 for False
        JR      Z,L1F07                 ; (+$01)
        INC     E               ; 1 for True
L1F07:  PUSH    DE
        JP      (IY)            ; indexed RETurn

; TERSE Forth TIMEBSCALE! does ??
L1F0A:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$000C        ; 12 offset for ??
        ADD     HL,DE
        POP     DE
        LD      (HL),E
        JP      (IY)            ; indexed RETurn

; ?? does ??
L1F15:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$000C        ; 12 offset for ??
        ADD     HL,DE
        LD      E,(HL)
        LD      D,$00
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; TERSE Forth TIMEBMAX! does ??
L1F22:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$000D        ; 13 offset for ??
        ADD     HL,DE
        POP     DE
        LD      (HL),E
        JP      (IY)            ; indexed RETurn

; TERSE Forth INVERT-ON does "set COCKTAIL mode for P2 ONLY" !!
L1F2D:  LD      A,$01
        LD      ($FEFF),A       ; bit 0 = 1 for draw screen FLIPped !!
        JP      (IY)            ; indexed RETurn

; TERSE Forth INVERT-OFF does "clear COCKTAIL mode for UPRIGHTs (and P1 ALWAYS !!)
L1F34:  XOR     A
        LD      ($FEFF),A       ; write Byte 0 for ?? in Static RAM
        JP      (IY)            ; indexed RETurn

; L1F3A: ?? routine (not used ??)
        PUSH    AF
        SLA     A
        ADD     A,L
        LD      L,A
        LD      A,$00
        ADC     A,H
        LD      H,A
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        DEC     HL
        POP     AF
        RET

; TERSE Forth NORMAL-SPACING does "load $FE3C with Byte 0 for ??"
L1F49:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE3C           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00B0           ; ... TerseRETurn

; TERSE Forth EVEN-SPACE-NUMS does "load $FE3C with Byte 6 for ??""
L1F52:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE3C           ; for Word ?? n Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; L1F5D: (NOT used !!) does load $FE3C with Byte 10 for ??
        RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE3C           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does Prepare and DRAW CHARacter from L1F98: routine
L1F69:  LD      D,(IY+$1D)      ; VXH offset 29
        LD      E,(IY+$1C)      ; VX offset 28
        CALL    L11DF           ; do "PREPARE an Image at full-scale XY offsets"
        LD      B,(IY+$1B)
        LD      C,(IY+$1A)
        LD      H,(IY+$21)      ; read Word PATTERN Source address
        LD      L,(IY+$20)
        INC     HL
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        INC     HL
        PUSH    HL
        POP     IX
        LD      H,(IY+$2D)      ; VSCRADRH offset 45
        LD      L,(IY+$2C)      ; VSCRADR offset 44
        CALL    L1991           ; do "clear ?? word"
        LD      A,B
        CALL    L05C6           ; do DRAW an CHARacter with MAGIC given
        CALL    L1973
        RET

; ?? does DRAW CHARacter(s) using given MAGIC routine
L1F98:  PUSH    IY
        PUSH    BC
        PUSH    IX
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      H,(IY+$21)      ; read Word PATTERN Source address
        LD      L,(IY+$20)
        LD      A,(HL)
L1FA8:  EX      AF,AF'
        INC     HL
        LD      A,(HL)
        PUSH    HL
        SUB     $20
        SLA     A
        LD      HL,L064B        ; point to word ASCII-to-CHARacter Image table
        LD      E,A
        LD      D,$00
        ADD     HL,DE
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        PUSH    DE
        PUSH    DE
        LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0020        ; 32 offset for ??
        ADD     HL,DE
        POP     DE
        LD      (HL),E
        INC     HL
        LD      (HL),D
        INC     DE
        INC     DE
        INC     DE
        LD      A,(DE)
        LD      B,A
        LD      C,$00
        SRA     B
        RR      C
        SRA     B
        RR      C
        LD      H,(IY+$1F)      ; VYH offset 31
        LD      L,(IY+$1E)      ; VY offset 30
        PUSH    HL
        OR      A
        SBC     HL,BC
        CALL    L1F69           ; do Prepare and DRAW CHARacter
        POP     HL
        LD      (IY+$1F),H      ; VYH offset 31
        LD      (IY+$1E),L      ; VY offset 30
        POP     DE
        LD      A,($FE3C)       ; read Byte ?? for ?? in Static RAM
        OR      A
        JP      NZ,L1FF4
        DEC     DE
        LD      A,(DE)
L1FF4:  BIT     7,(IY+$1B)
        JP      Z,L1FFF
        SLA     A
        SLA     A
L1FFF:  BIT     6,(IY+$1B)
L2003:  JP      Z,L2008
        SLA     A
L2008:  LD      E,A
        LD      D,$00
        LD      A,($FE3B)       ; read Byte ?? for ?? in Static RAM
        LD      L,A
        LD      H,$00
        ADD     HL,DE
        LD      H,L
        LD      L,$00
        SRA     H
        RR      L
        SRA     H
        RR      L
        LD      D,(IY+$1D)      ; VXH offset 29
        LD      E,(IY+$1C)      ; VX offset 28
        ADD     HL,DE
        LD      (IY+$1D),H      ; VXH offset 29
        LD      (IY+$1C),L      ; VX offset 28
        POP     HL
        EX      AF,AF'
        DEC     A
        JP      NZ,L1FA8        ; loop for next CHARacter
        POP     IX
        POP     BC
        POP     IY
        RET

; ?? does DRAW CHARacter(s) frpm TERSE ??
L2036:  CALL    L1F98           ; do DRAW CHARacter(s) using given MAGIC
        JP      (IY)            ; indexed RETurn

; TERSE Forth STRING does "READ then DRAW CHARacter(s)"
L203B:  PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      H,(IY+$1D)      ; VXH offset 29
        LD      L,(IY+$1C)      ; VX offset 28
        PUSH    HL
        CALL    L1F98           ; do DRAW CHARacter(s) using given MAGIC
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM again
        POP     HL
        LD      (IY+$1D),H      ; VXH offset 29
        LD      (IY+$1C),L      ; VX offset 28
        POP     IY
        JP      (IY)            ; indexed RETurn

; ?? does ??
L205A:  POP     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        PUSH    DE
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; ?? does ??
L2066:  POP     DE
        POP     HL
        EX      (SP),HL
        EX      DE,HL
        LD      (HL),E
        INC     HL
        LD      (HL),D
        INC     HL
        POP     DE
        LD      (HL),E
        INC     HL
        LD      (HL),D
        JP      (IY)            ; indexed RETurn

; TERSE Forth D+ does ??
L2074:  POP     DE
        EXX
        POP     DE
        EXX
        POP     HL
        EXX
        POP     HL
        EXX
        EXX
        ADD     HL,DE
        EXX
        ADC     HL,DE
        EXX
        PUSH    HL
        EXX
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; ?? does ??
L2087:  POP     DE
        EXX
        POP     DE
        EXX
        POP     HL
        EXX
        POP     HL
        EXX
        EXX
        OR      A
        SBC     HL,DE
        EXX
        SBC     HL,DE
        EXX
        PUSH    HL
L2098:  EXX                     ; base address index 0 for table below
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; L209C: Powers of TEN 2-word table (no index 0 !!)
        DW      $0001,$0000     ; index 1 for 1
        DW      $000A,$0000     ; index 2 for 10
        DW      $0064,$0000     ; index 3 for 100
        DW      $03E8,$0000     ; index 4 for 1000
        DW      $2710,$0000     ; index 5 for 10000
        DW      $86A0,$0001     ; index 6 for 100000
        DW      $4240,$000F     ; index 7 for 1000000
        DW      $9680,$0098     ; index 8 for 10000000
        DW      $E100,$05F5     ; index 9 for 100000000
        DW      $CA00,$3B9A     ; index 10 for 1000000000
; end of Powers of TEN table

; ?? does CONVERT ?? Number to ASCII Text String routine (with IY = Sign byte)
; note: BC is significant Digits, HL is High WORD, EXX HL is Low WORD to parse
L20C4:  XOR     A
        ADD     A,H
        LD      A,$2B           ; 43 for ASCII "+" Plus sign
        JP      P,L20E0
        LD      DE,$0000        ; Two's Complement if Negative
        EXX
        LD      DE,$0000
        EXX
        EX      DE,HL
        EXX
        EX      DE,HL
        EXX                     ; eh?
        EXX
        OR      A
        SBC     HL,DE
        EXX
        SBC     HL,DE
        LD      A,$2D           ; 45 for ASCII "-" Minus sign
L20E0:  LD      (IY+$00),A
L20E3:  INC     IY              ; next Digit
        LD      DE,L2098        ; point to Powers of TEN base address
        PUSH    BC              ; must be 1 through 10 to work !!
        POP     IX
        ADD     IX,IX           ; times 4
        ADD     IX,IX
        ADD     IX,DE
L20F1:  LD      D,(IX+$03)      ; High Word
        LD      E,(IX+$02)
        EXX
        LD      D,(IX+$01)      ; Low Word
        LD      E,(IX+$00)
        EXX
        LD      A,$30           ; 48 for ASCII Number "0"
        LD      B,$0A           ; for 10 loops of Powers
L2103:  EXX
        OR      A
        SBC     HL,DE           ; Low word
        EXX
        SBC     HL,DE           ; High word
        JP      M,L2111         ; if gone too far
        INC     A               ; ASCII Number + 1
        DJNZ    L2103                   ; (-$0d) next Power
        DEC     A               ; ASCII Number - 1

; if too far, UNDO
L2111:  EXX
        ADD     HL,DE           ; Low word
        EXX
        ADC     HL,DE           ; High word
        LD      (IY+$00),A
        INC     IY              ; next storage
        LD      DE,$FFFC        ; -4 for previous entry
        ADD     IX,DE
        DEC     C
        JP      NZ,L20F1        ; loop to next Digit
        RET

; TERSE Forth BIN->ASC does "CONVERT BINary Number to ASCII Text String"
L2125:  EXX
        POP     BC
        POP     DE
        POP     HL
        EXX
        POP     HL
        PUSH    BC
        PUSH    IX
        PUSH    IY
        EXX
        PUSH    DE
        POP     IY
        CALL    L20C4           ; do CONVERT ?? Number to ASCII Text String
        POP     IY
        POP     IX
        POP     BC
        JP      (IY)            ; indexed RETurn

; TERSE Forth 0SUPR does "REPLACE Leading Zeroes with SPACEs in Text String"
L213E:  POP     HL
        LD      E,(HL)          ; read Length of string
        INC     HL
L2141:  LD      A,E
        CP      $01             ; is it 1 yet ? (leave a single "0" !!)
        JR      Z,L2152                 ; (+$0c) to end
        LD      A,(HL)
        CP      $30             ; is it ASCII "0" ?
        JR      NZ,L2151                ; (+$06) no
        LD      (HL),$20        ; turn it into ASCII " " SPACE
        INC     HL
        DEC     E
        JR      L2152                   ; (+$01) for next CHARacter

L2151:  XOR     A               ; set flags for a NULL found
L2152:  JR      NZ,L2141                ; (-$13) loop for Length-1
        JP      (IY)            ; indexed RETurn

; ?? does write IndexY WORD into ?? in Static RAM
L2156:  LD      ($FEE4),IY      ; write Word IndexY into ?? in Static RAM
        JP      (IY)            ; indexed RETurn
;
;**********************************************************
;
;**********************************************************
; ?? does ??
L215C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0538           ; DI do "Disable Interrupt"
        ;
        DW      L00BC           ; divg "pushWORD to System stack"
        DW      $FEEA           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00BC           ; divgct "pushWORD to System stack"
        DW      $FEE8           ; for Word "eivg ct ??" in Static RAM
        ;
        DW      L0133           ; ZERO do "Pop HL, word 00->(HL)"
        ;
        DW      L00BC           ; vaddr "pushWORD to System stack"
        DW      $FEE6           ; for Word ?? in Static RAM
        ;
        DW      L0133           ; ZERO do "Pop HL, word 00->(HL)"
        ;
        DW      L2156           ; ?? do write IndexY WORD into ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L1387           ; point to ?? First Interrupt routine
        ;
        DW      L00BC           ; SUI3V "pushWORD to System stack"
        DW      $FEF8           ; for Word ?? (an Interrupt Vector !!) in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $64             ; 100 for INterrupt LINe number ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEF5           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; SU1flag "pushWORD to System stack"
        DW      $FEF1           ; for Word ( inprogress ) in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEF0           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L149C           ; point to Second Interrupt Routine ?? in Static RAM ??
        ;
        DW      L00BC           ; SUI1V "pushWORD to System stack"
        DW      $FEFC           ; for Word ?? (an Interrupt Vector !!) in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $C8             ; 200 for Interrupt LINe ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEF7           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEF2           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEEF           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L1533           ; point to ?? Third Interrupt Routine ?? in Static RAM ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEFA           ; for Word ?? (an Interrupt Vector !!) in Static RAM ??
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $32             ; 50 for INterrupt LINe number ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEF6           ; SUI2L for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEED           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $19             ; 25 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEF3           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEF4           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEEC           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEEB           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L1182           ; point to 2 word table #1 for ??
        ;
        DW      L10D7           ; noname do ?? RECREATED SOURCE code !!
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L1186           ; point to 2 word table #2 for ??
        ;
        DW      L10D7           ; noname do ?? RECREATED SOURCE code !!
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L118A           ; point to 2 word table #3 for ??
        ;
        DW      L10D7           ; noname do ?? RECREATED SOURCE code !!
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L118E           ; point to 2 word table #4 for ??
        ;
        DW      L10D7           ; noname do ?? RECREATED SOURCE code !!
        ;
        DW      L1F49           ; NORMAL-SPACING do "load $FE3C with Byte 0 for ??"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE3B           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $CB             ; note: 203 for Bottom LINE of Screen-1
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; for setting &(10)=203 as VERBL
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L148F           ; ?? does "DI, First Interrupt Routine and DI"
        ;
        DW      L00B0           ; ... TerseRETurn

; TERSE Forth BREAK does "null Terse subroutine" ?? (NOT a BREAK for CASE !!)
L2215:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00B0           ; ... TerseRETurn

; TT does "First Interrupt Routine then More of Third Interrupt Routine"
L2218:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L148F           ; ?? does "DI, First Interrupt Routine and DI"
        ;
        DW      L155C           ; More of Third Interrupt Routine ?? in Static RAM ??
        ;
        DW      L00B0           ; ... TerseRETurn

; TERSE Forth VGER-OUT does ??
L221F:  LD      A,$01
        LD      ($FEEB),A       ; write Byte 1 for ?? in Static RAM
        JP      (IY)
; end of ??

;**********************************************************
; start of Patterns !! Colors are ALWAYS as indicated:
; . = TRANSPARENT; 1 = Yellow; 2 = Red; 3 = DARK Blue!
; will need to be cleaned up
;**********************************************************
; L2226: ?? ChecKsum Byte ??
        DB      $6A             ; loose byte ??

; 4-color Robby Roto all wrapped up #1
L2227:  DB      $07             ; 7 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$0A,$00,$00 ; . . . . . . 2 2 . . . . . . . .
        DB      $00,$BA,$E0,$00 ; . . . . 1 3 2 2 3 2 . . . . . .
        DB      $0A,$FE,$BA,$00 ; . . 2 2 3 3 3 2 2 3 2 2 . . . .
        DB      $0A,$5F,$EE,$00 ; . . 2 2 1 1 3 3 3 2 3 2 . . . .
        DB      $2E,$D7,$EB,$80 ; . 2 3 2 3 1 1 3 3 2 2 3 2 . . .
        DB      $2A,$F5,$EA,$C0 ; . 2 2 2 3 3 1 1 3 2 2 2 3 . . .
        DB      $EA,$AA,$BB,$A0 ; 3 2 2 2 2 2 2(2)2 3 2 3 2 2 . .
        DB      $30,$3A,$AE,$A0 ; . 3 . . . 3 2 2 2 2 3 2 2 2 . .
        DB      $0C,$2E,$BB,$A0 ; . . 3 . . 2 3 2 2 3 2 3 2 2 . .
        DB      $03,$AB,$EA,$C0 ; . . . 3 2 2 2 3 3 2 2 2 3 . . .
        DB      $0A,$EA,$EA,$00 ; . . 2 2 3 2 2 2 3 2 2 2 . . . .
        DB      $00,$7A,$90,$00 ; . . . . 1 3 2 2 2 1 . . . . . .
        DB      $00,$10,$11,$00 ; . . . . . 1 . . . 1 . 1 . . . .
        DB      $00,$50,$04,$00 ; . . . . 1 1 . . . . 1 . . . . .

; Robby Roto all wrapped up #2
L2263:  DB      $07             ; 7 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$0A,$00,$00 ; . . . . . . 2 2 . . . . . . . .
        DB      $00,$EA,$E0,$00 ; . . . . 3 2 2 2 3 2 . . . . . .
        DB      $0A,$BA,$BA,$00 ; . . 2 2 2 3 2 2 2 3 2 2 . . . .
        DB      $0B,$FE,$EE,$00 ; . . 2 3 3 3 3 2 3 2 3 2 . . . .
        DB      $28,$7F,$AB,$80 ; . 2 2 . 1 3 3 3 2 2 2 3 2 . . .
        DB      $EC,$1F,$EA,$C0 ; 3 2 3 . . 1 3 3 3 2 2 2 3 . . .
        DB      $AA,$AA,$BB,$A0 ; 2 2 2 2 2 2 2(2)2 3 2 3 2 2 . .
        DB      $30,$3A,$AE,$A0 ; . 3 . . . 3 2 2 2 2 3 2 2 2 . .
        DB      $0C,$2E,$BB,$80 ; . . 3 . . 2 3 2 2 3 2 3 2 . . .
        DB      $03,$AB,$AA,$C0 ; . . . 3 2 2 2 3 2 2 2 2 3 . . .
        DB      $0A,$EE,$EA,$10 ; . . 2 2 3 2 3 2 3 2 2 2 . 1 . .
        DB      $00,$7A,$B5,$50 ; . . . . 1 3 2 2 2 3 1 1 1 1 . .
        DB      $11,$00,$00,$00 ; . 1 . 1 . . . . . . . . . . . .
        DB      $04,$00,$00,$00 ; . . 1 . . . . . . . . . . . . .

; PDOA "Player Dead On Arrival" animation table for 2 Wrapped-up ROBBY patterns above
L229F:  DB      $02,$00,$81     ; byte 2 ENTRIES; byte 0; byte -2 for ??
        ;
; 2 byte-plus-word for Robby Roto all wrapped ups
; entries are a duration and a WORD for pattern, then a loop !!
L22A2:  DB      $0A,$27,$22     ; byte DURATION = 10, word LABEL #1
        DB      $0A,$63,$22     ; byte DURATION = 10, word LABEL #2
        DB      $00,$A2,$22     ; loops to first entry LABEL

; 4-color BIRD/Pteradon VOLTAR #1
L22AB:  DB      $11             ; 17 = X offset
        DB      $0C             ; 12 = Y offset
        DB      $08             ; 8 = Width in bytes
        DB      $11             ; 17 = Height in rows
        ;
        DB      $00,$00,$00,$00,$00,$15,$55,$65
        DB      $00,$00,$00,$00,$05,$5A,$AA,$90
        DB      $00,$00,$00,$00,$5A,$55,$56,$40
        DB      $00,$00,$40,$01,$56,$56,$A9,$00
        DB      $00,$01,$54,$06,$55,$A5,$50,$00
        DB      $00,$55,$50,$19,$55,$56,$80,$00
        DB      $55,$7F,$40,$56,$95,$00,$00,$00
        DB      $15,$6B,$41,$55,$54,$00,$00,$00
        DB      $00,$55,$5A,$55,$00,$00,$00,$10
        DB      $00,$01,$59,$95,$40,$00,$01,$64
        DB      $00,$00,$25,$6A,$59,$55,$54,$10
        DB      $00,$00,$09,$55,$55,$50,$00,$00
        DB      $00,$00,$00,$59,$54,$00,$00,$00
        DB      $00,$00,$0A,$80,$80,$00,$00,$00
        DB      $00,$00,$08,$8A,$20,$00,$00,$00
        DB      $00,$00,$02,$08,$20,$00,$00,$00
        DB      $00,$00,$00,$02,$00,$00,$00,$00
;
; . . . . . . . . . . . . . . . . . . . . . 1 1 1 1 1 1 1 1 2 1 1
; . . . . . . . . . . . . . . . . . . 1 1 1 1 2 2 2 2 2 2 2 1 . .
; . . . . . . . . . . . . . . . . 1 1 2 2 1 1 1 1 1 1 1 2 1 . . .
; . . . . . . . . 1 . . . . . . 1 1 1 1 2 1 1 1 2 2 2 2 1 . . . .
; . . . . . . . 1 1 1 1 . . . 1 2 1 1 1 1 2 2 1 1 1 1 . . . . . .
; . . . . 1 1 1 1 1 1 . . . 1 2 1 1 1 1 1 1 1 1 2 2 . . . . . . .
; 1 1 1 1 1 3 3 3 1 . . . 1 1 1 2 2 1 1 1 . . . . . . . . . . . .
; . 1 1 1 1 2 2 3 1 . . 1 1 1 1 1 1 1 1 . . . . . . . . . . . . .
; . . . . 1 1 1 1 1 1 2 2 1 1 1 1 . . . . . . . . . . . . . 1 . .
; . . . . . . . 1 1 1 2 1 2 1 1 1 1 . . . . . . . . . . 1 1 2 1 .
; . . . . . . . . . 2 1 1 1 2 2 2 1 1 2 1 1 1 1 1 1 1 1 . . 1 . .
; . . . . . . . . . . 2 1 1 1 1 1 1 1 1 1 1 1 . . . . . . . . . .
; . . . . . . . . . . . . 1 1 2 1 1(1)1 . . . . . . . . . . . . .
; . . . . . . . . . . 2 2 2 . . . 2 . . . . . . . . . . . . . . .
; . . . . . . . . . . 2 . 2 . 2 2 . 2 . . . . . . . . . . . . . .
; . . . . . . . . . . . 2 . . 2 . . 2 . . . . . . . . . . . . . .
; . . . . . . . . . . . . . . . 2 . . . . . . . . . . . . . . . .

; BIRD/Pteradon VOLTAR #2
L2337:  DB      $11             ; 17 = X offset
        DB      $0C             ; 12 = Y offset
        DB      $09             ; 9 = Width in bytes
        DB      $14             ; 20 = Height in rows
        ;
        DB      $00,$00,$40,$00,$00,$00,$00,$00,$00
        DB      $00,$01,$54,$00,$00,$00,$00,$00,$00
        DB      $00,$55,$50,$00,$00,$00,$00,$00,$00
        DB      $55,$7F,$40,$01,$55,$55,$00,$00,$00
        DB      $01,$6B,$4A,$55,$6A,$40,$00,$00,$00
        DB      $15,$55,$66,$55,$55,$55,$40,$01,$00
        DB      $00,$02,$99,$55,$55,$55,$55,$56,$40
        DB      $00,$00,$25,$55,$56,$55,$00,$01,$00
        DB      $00,$00,$65,$55,$68,$00,$00,$00,$00
        DB      $00,$00,$59,$55,$00,$00,$00,$00,$00
        DB      $00,$01,$56,$50,$00,$00,$00,$00,$00
        DB      $00,$01,$55,$50,$00,$00,$00,$00,$00
        DB      $00,$06,$55,$40,$00,$00,$00,$00,$00
        DB      $00,$05,$94,$00,$00,$00,$00,$00,$00
        DB      $00,$05,$54,$00,$00,$00,$00,$00,$00
        DB      $00,$05,$40,$00,$00,$00,$00,$00,$00
        DB      $00,$05,$40,$00,$00,$00,$00,$00,$00
        DB      $00,$05,$00,$00,$00,$00,$00,$00,$00
        DB      $00,$05,$00,$00,$00,$00,$00,$00,$00
        DB      $00,$04,$00,$00,$00,$00,$00,$00,$00
;
; . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . . . . . . . . .
; . . . . . . . 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . .
; . . . . 1 1 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . .
; 1 1 1 1 1 3 3 3 1 . . . . . . 1 1 1 1 1 1 1 1 1 . . . . . . . . . . . .
; . . . 1 1 2 2 3 1 . 2 2 1 1 1 1 1 2 2 2 1 . . . . . . . . . . . . . . .
; . 1 1 1 1 1 1 1 1 2 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . . 1 . . . .
; . . . . . . . 2 2 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 . . .
; . . . . . . . . . 2 1 1 1 1 1 1 1 1 1 2 1 1 1 1 . . . . . . . 1 . . . .
; . . . . . . . . 1 2 1 1 1 1 1 1 1 2 2 . . . . . . . . . . . . . . . . .
; . . . . . . . . 1 1 2 1 1 1 1 1 . . . . . . . . . . . . . . . . . . . .
; . . . . . . . 1 1 1 1 2 1 1 . . . . . . . . . . . . . . . . . . . . . .
; . . . . . . . 1 1 1 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . .
; . . . . . . 1 2 1 1 1 1 1 . . . ._._. . . . . . . . . . . . . . . . . .
; . . . . . . 1 1 2 1 1 . . . . . . . . . . . . . . . . . . . . . . . . .
; . . . . . . 1 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . .
; . . . . . . 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . .
; . . . . . . 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . .
; . . . . . . 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
; . . . . . . 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
; . . . . . . 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

; animation table for 2 BIRD (aka VOLTAR) patterns above
L23EF:  DB      $02,$00,$81     ; 2 ENTRIES; 0 for ??; -2 for ??
        ;
L23F2:  DB      $0A,$AB,$22     ; byte durations = 10 + word for Pteradons
        DB      $0A,$37,$23
        DB      $00,$F2,$23     ; loop to 1st entry

; 4-color PIN-WHEEL #1 (4 small-sized first ...) DIGGER patterns
L23FB:  DB      $03             ; 3 = X offset
        DB      $06             ; 6 = Y offset
        DB      $02             ; 2 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $14,$00         ;  . 1 1 . . . . .
        DB      $04,$00         ;  . . 1 . . . . .
        DB      $04,$00         ;  . . 1 . . . . .
        DB      $04,$00         ;  . . 1 . . . . .
        DB      $0A,$00         ;  . . 2 2 . . . .
        DB      $2A,$80         ;  . 2 2 2 2 . . .
        DB      $AA,$A0         ;  2 2 2(2)2 2 . .
        DB      $AA,$A0         ;  2 2 2 2 2 2 . .
        DB      $2A,$80         ;  . 2 2 2 2 . . .
        DB      $0A,$00         ;  . . 2 2 . . . .
        DB      $01,$00         ;  . . . 1 . . . .
        DB      $01,$00         ;  . . . 1 . . . .
        DB      $01,$00         ;  . . . 1 . . . .
        DB      $01,$40         ;  . . . 1 1 . . .

; DIGGER PIN-WHEEL #2
L241B:  DB      $07             ; 7 = X offset
        DB      $02             ; 2 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $06             ; 6 = Height in rows
        ;
        DB      $00,$0A,$00,$00 ;  . . . . . . 2 2 . . . . . . . .
        DB      $00,$2A,$80,$10 ;  . . . . . 2 2 2 2 . . . . 1 . .
        DB      $00,$AA,$A5,$50 ;  . . . . 2 2 2(2)2 2 1 1 1 1 . .
        DB      $55,$AA,$A0,$00 ;  1 1 1 1 2 2 2 2 2 2 . . . . . .
        DB      $40,$2A,$80,$00 ;  1 . . . . 2 2 2 2 . . . . . . .
        DB      $00,$0A,$00,$00 ;  . . . . . . 2 2 . . . . . . . .

; DIGGER PIN-WHEEL #3
L2437:  DB      $05             ; 5 = X offset
        DB      $04             ; 4 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ;
        DB      $10,$00,$00     ; . 1 . . . . . . . . . .
        DB      $44,$00,$00     ; 1 . 1 . . . . . . . . .
        DB      $01,$A0,$00     ; . . . 1 2 2 . . . . . .
        DB      $02,$A8,$00     ; . . . 2 2 2 2 . . . . .
        DB      $0A,$AA,$00     ; . . 2 2 2(2)2 2 . . . .
        DB      $0A,$AA,$00     ; . . 2 2 2 2 2 2 . . . .
        DB      $02,$A8,$00     ; . . . 2 2 2 2 . . . . .
        DB      $00,$A4,$00     ; . . . . 2 2 1 . . . . .
        DB      $00,$01,$10     ; . . . . . . . 1 . 1 . .
        DB      $00,$00,$40     ; . . . . . . . . 1 . . .

; DIGGER PIN-WHEEL #4
L2459:  DB      $05             ; 5 = X offset
        DB      $06             ; 6 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$00,$40     ; . . . . . . . . 1 . . .
        DB      $00,$00,$10     ; . . . . . . . . . 1 . .
        DB      $00,$00,$40     ; . . . . . . . . 1 . . .
        DB      $00,$01,$00     ; . . . . . . . 1 . . . .
        DB      $00,$A4,$00     ; . . . . 2 2 1 . . . . .
        DB      $02,$A8,$00     ; . . . 2 2 2 2 . . . . .
        DB      $0A,$AA,$00     ; . . 2 2 2(2)2 2 . . . .
        DB      $0A,$AA,$00     ; . . 2 2 2 2 2 2 . . . .
        DB      $02,$A8,$00     ; . . . 2 2 2 2 . . . . .
        DB      $01,$A0,$00     ; . . . 1 2 2 . . . . . .
        DB      $04,$00,$00     ; . . 1 . . . . . . . . .
        DB      $10,$00,$00     ; . 1 . . . . . . . . . .
        DB      $40,$00,$00     ; 1 . . . . . . . . . . .
        DB      $10,$00,$00     ; . 1 . . . . . . . . . .

; 4-color (... then 4 REGULAR-sized ...) DIGGER #5 patterns
L2487:  DB      $06             ; 6 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$01,$5F,$40 ; . . . . . . . 1 1 1 3 3 1 . . .
        DB      $01,$55,$7F,$40 ; . . . 1 1 1 1 1 1 3 3 3 1 . . .
        DB      $15,$55,$7F,$C0 ; . 1 1 1 1 1 1 1 1 3 3 3 3 . . .
        DB      $55,$55,$55,$00 ; 1 1 1 1 1 1 1 1 1 1 1 1 . . . .
        DB      $2A,$BD,$28,$00 ; . 2 2 2 2 3 3 1 . 2 2 . . . . .
        DB      $2A,$B4,$28,$00 ; . 2 2 2 2 3 1 . . 2 2 . . . . .
        DB      $AA,$AA,$AA,$00 ; 2 2 2 2 2 2(2)2 2 2 2 2 . . . .
        DB      $AA,$A0,$00,$00 ; 2 2 2 2 2 2 . . . . . . . . . .
        DB      $2A,$A8,$00,$00 ; . 2 2 2 2 2 2 . . . . . . . . .
        DB      $2A,$AA,$00,$00 ; . 2 2 2 2 2 2 2 . . . . . . . .
        DB      $0A,$AA,$A0,$00 ; . . 2 2 2 2 2 2 2 2 . . . . . .
        DB      $02,$AA,$80,$00 ; . . . 2 2 2 2 2 2 . . . . . . .
        DB      $00,$28,$00,$00 ; . . . . . 2 2 . . . . . . . . .
        DB      $00,$14,$00,$00 ; . . . . . 1 1 . . . . . . . . .

; DIGGER #6 (REGULAR-size)
L24C3:  DB      $07             ; 7 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0D             ; 13 = Height in rows
        ;
        DB      $00,$00,$57,$D0 ; . . . . . . . . 1 1 1 3 3 1 . .
        DB      $00,$55,$5F,$D0 ; . . . . 1 1 1 1 1 1 3 3 3 1 . .
        DB      $05,$55,$5F,$F0 ; . . 1 1 1 1 1 1 1 1 3 3 3 3 . .
        DB      $15,$55,$55,$40 ; . 1 1 1 1 1 1 1 1 1 1 1 1 . . .
        DB      $0A,$AF,$4A,$00 ; . . 2 2 2 2 3 3 1 . 2 2 . . . .
        DB      $0A,$AD,$0A,$10 ; . . 2 2 2 2 3 1 . . 2 2 . 1 . .
        DB      $6A,$AA,$AA,$90 ; 1 2 2 2 2 2 2(2)2 2 2 2 2 1 . .
        DB      $6A,$A8,$00,$00 ; 1 2 2 2 2 2 2 . . . . . . . . .
        DB      $0A,$AA,$00,$00 ; . . 2 2 2 2 2 2 . . . . . . . .
        DB      $0A,$AA,$80,$00 ; . . 2 2 2 2 2 2 2 . . . . . . .
        DB      $02,$AA,$A8,$00 ; . . . 2 2 2 2 2 2 2 2 . . . . .
        DB      $00,$AA,$A0,$00 ; . . . . 2 2 2 2 2 2 . . . . . .
        DB      $00,$0A,$00,$00 ; . . . . . . 2 2 . . . . . . . .

; DIGGER #7 (REGULAR-size)
L24FB:  DB      $06             ; 6 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0D             ; 13 = Height in rows
        ;
        DB      $00,$01,$5F,$80 ; . . . . . . . 1 1 1 3 3 2 . . .
        DB      $01,$55,$7F,$80 ; . . . 1 1 1 1 1 1 3 3 3 2 . . .
        DB      $15,$55,$7F,$C0 ; . 1 1 1 1 1 1 1 1 3 3 3 3 . . .
        DB      $55,$55,$55,$00 ; 1 1 1 1 1 1 1 1 1 1 1 1 . . . .
        DB      $2A,$BD,$28,$00 ; . 2 2 2 2 3 3 1 . 2 2 . . . . .
        DB      $2A,$B4,$28,$00 ; . 2 2 2 2 3 1 . . 2 2 . . . . .
        DB      $AA,$AA,$AA,$00 ; 2 2 2 2 2 2(2)2 2 2 2 2 . . . .
        DB      $AA,$A0,$00,$00 ; 2 2 2 2 2 2 . . . . . . . . . .
        DB      $2A,$A8,$00,$00 ; . 2 2 2 2 2 2 . . . . . . . . .
        DB      $2A,$AA,$00,$00 ; . 2 2 2 2 2 2 2 . . . . . . . .
        DB      $0A,$AA,$A0,$00 ; . . 2 2 2 2 2 2 2 2 . . . . . .
        DB      $12,$AA,$80,$00 ; . 1 . 2 2 2 2 2 2 . . . . . . .
        DB      $04,$28,$00,$00 ; . . 1 . . 2 2 . . . . . . . . .

; DIGGER #8 (REGULAR-size)
L2533:  DB      $06             ; 5 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0D             ; 13 = Height in rows
        ;
        DB      $00,$01,$5F,$80 ; . . . . . . . 1 1 1 3 3 2 . . .
        DB      $01,$55,$7F,$80 ; . . . 1 1 1 1 1 1 3 3 3 2 . . .
        DB      $15,$55,$7F,$C0 ; . 1 1 1 1 1 1 1 1 3 3 3 3 . . .
        DB      $55,$55,$55,$00 ; 1 1 1 1 1 1 1 1 1 1 1 1 . . . .
        DB      $2A,$BD,$28,$00 ; . 2 2 2 2 3 3 1 . 2 2 . . . . .
        DB      $2A,$B4,$28,$00 ; . 2 2 2 2 3 1 . . 2 2 . . . . .
        DB      $AA,$AA,$AA,$00 ; 2 2 2 2 2 2(2)2 2 2 2 2 . . . .
        DB      $AA,$A0,$00,$00 ; 2 2 2 2 2 2 . . . . . . . . . .
        DB      $2A,$A8,$00,$00 ; . 2 2 2 2 2 2 . . . . . . . . .
        DB      $2A,$AA,$00,$00 ; . 2 2 2 2 2 2 2 . . . . . . . .
        DB      $0A,$AA,$A0,$00 ; . . 2 2 2 2 2 2 2 2 . . . . . .
        DB      $02,$AA,$84,$00 ; . . . 2 2 2 2 2 2 . 1 . . . . .
        DB      $00,$28,$10,$00 ; . . . . . 2 2 . . 1 . . . . . .

; DIGGER #9 (... and a BIGGER-size)
L256B:  DB      $07             ; 7 = X offset
        DB      $08             ; 8 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $10             ; 16 = Height in rows
        ;
        DB      $00,$00,$15,$F4 ; . . . . . . . . . 1 1 1 3 3 1 .
        DB      $00,$55,$5F,$F4 ; . . . . 1 1 1 1 1 1 3 3 3 3 1 .
        DB      $05,$55,$5F,$F4 ; . . 1 1 1 1 1 1 1 1 3 3 3 3 1 .
        DB      $15,$55,$57,$FC ; . 1 1 1 1 1 1 1 1 1 1 3 3 3 3 .
        DB      $55,$55,$55,$50 ; 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . .
        DB      $0A,$AF,$5A,$00 ; . . 2 2 2 2 3 3 1 1 2 2 . . . .
        DB      $2A,$BD,$7A,$80 ; . 2 2 2 2 3 3 1 1 3 2 2 2 . . .
        DB      $2A,$BD,$FA,$80 ; . 2 2 2 2 3 3 1 3 3 2 2 2 . . .
        DB      $AA,$AA,$AA,$A0 ; 2 2 2 2 2 2 2(2)2 2 2 2 2 2 . .
        DB      $AA,$AA,$00,$00 ; 2 2 2 2 2 2 2 2 . . . . . . . .
        DB      $2A,$AA,$00,$00 ; . 2 2 2 2 2 2 2 . . . . . . . .
        DB      $2A,$AA,$80,$00 ; . 2 2 2 2 2 2 2 2 . . . . . . .
        DB      $0A,$AA,$A0,$00 ; . . 2 2 2 2 2 2 2 2 . . . . . .
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .
        DB      $00,$AA,$A0,$00 ; . . . . 2 2 2 2 2 2 . . . . . .
        DB      $00,$0A,$00,$00 ; . . . . . . 2 2 . . . . . . . .

; animation table for 4 + 5 (REGULAR-size) DIGGER patterns above
L25AF:  DB      $11,$00,$81     ; 17 byte+words for 9 patterns
        ;
L25B2:  DB      $02,$6B,$25     ; BIGGER DIGGER #9 NOT repeated ...
        DB      $02,$87,$24     ; #5 ... 8 duplicates from here
        DB      $02,$FB,$24     ; #7
        DB      $02,$C3,$24     ; #6
        DB      $02,$33,$25     ; #8
        DB      $02,$FB,$23     ; #1
        DB      $02,$59,$24     ; #4
        DB      $02,$1B,$24     ; #2
        DB      $02,$37,$24     ; #3
        DB      $02,$FB,$23     ; #1 again
        DB      $02,$59,$24     ; #4 again
        DB      $02,$1B,$24     ; #2 again
        DB      $02,$37,$24     ; #3 again
        DB      $02,$87,$24     ; #5 again
        DB      $02,$FB,$24     ; #7 again
        DB      $02,$C3,$24     ; #6 again
        DB      $02,$33,$25     ; #8 again
        DB      $00,$B2,$25     ; loop for DIGGERS

; ROTFLY animation loop !!
L25E8:  DB      $07,$00,$83     ; ?? but only 1 valid ??
        ;
        DB      $40,$F2,$23     ; BIRD animation loop ?? duration = 64
        DB      $00,$F2,$23     ; jump to 2 Pteradons loop ??

; ?? TERSE animation loop !! (entry 1 is a loop then a duration ??)
L25F1:  DB      $07,$00,$83     ; ?? also only 1 valid ??
        ;
L25F4:  DB      $00,$B2,$25     ; loop for DIGGERS again
        DB      $40,$B2,$25     ; ?? same as above again ??

; KEY1 4-color buried KEY pattern
L25FA:  DB      $0A             ; 10 = X offset
        DB      $09             ; 9 = Y offset
        DB      $05             ; 5 = Width in bytes
        DB      $12             ; 18 = Height in rows
        ;
        DB      $01,$55,$55,$55,$40 ; . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . .
        DB      $05,$55,$55,$55,$50 ; . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . .
        DB      $15,$55,$5B,$55,$54 ; . 1 1 1 1 1 1 1 1 1 2 3 1 1 1 1 1 1 1 .
        DB      $15,$55,$AB,$55,$54 ; . 1 1 1 1 1 1 1 2 2 2 3 1 1 1 1 1 1 1 .
        DB      $15,$55,$5B,$55,$54 ; . 1 1 1 1 1 1 1 1 1 2 3 1 1 1 1 1 1 1 .
        DB      $15,$55,$AB,$55,$54 ; . 1 1 1 1 1 1 1 2 2 2 3 1 1 1 1 1 1 1 .
        DB      $15,$55,$5B,$55,$54 ; . 1 1 1 1 1 1 1 1 1 2 3 1 1 1 1 1 1 1 .
        DB      $15,$55,$AB,$55,$54 ; . 1 1 1 1 1 1 1 2 2 2 3 1 1 1 1 1 1 1 .
        DB      $15,$55,$5B,$55,$54 ; . 1 1 1 1 1 1 1 1 1 2 3 1 1 1 1 1 1 1 .
        DB      $15,$55,$5B,$55,$54 ; . 1 1 1 1 1 1 1 1 1(2)3 1 1 1 1 1 1 1 .
        DB      $15,$55,$AA,$D5,$54 ; . 1 1 1 1 1 1 1 2 2 2 2 3 1 1 1 1 1 1 .
        DB      $15,$56,$BE,$B5,$54 ; . 1 1 1 1 1 1 2 2 3 3 2 2 3 1 1 1 1 1 .
        DB      $15,$5A,$D5,$AD,$54 ; . 1 1 1 1 1 2 2 3 1 1 1 2 2 3 1 1 1 1 .
        DB      $15,$5A,$D5,$AD,$54 ; . 1 1 1 1 1 2 2 3 1 1 1 2 2 3 1 1 1 1 .
        DB      $15,$56,$BE,$B5,$54 ; . 1 1 1 1 1 1 2 2 3 3 2 2 3 1 1 1 1 1 .
        DB      $15,$55,$AA,$D5,$54 ; . 1 1 1 1 1 1 1 2 2 2 2 3 1 1 1 1 1 1 .
        DB      $05,$55,$55,$55,$50 ; . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . .
        DB      $01,$55,$55,$55,$40 ; . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . .

; start of BONUS patterns and animations
; ST1 4-color "STar" TREASURE for "4-point STAR" from T/F table
L2658:  DB      $06             ; 6 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0D             ; 13 = Height in rows
        ;
        DB      $00,$04,$00,$00 ; . . . . . . 1 . . . . . . . . .
        DB      $00,$04,$00,$00 ; . . . . . . 1 . . . . . . . . .
        DB      $00,$04,$00,$00 ; . . . . . . 1 . . . . . . . . .
        DB      $00,$04,$00,$00 ; . . . . . . 1 . . . . . . . . .
        DB      $00,$15,$00,$00 ; . . . . . 1 1 1 . . . . . . . .
        DB      $00,$51,$40,$00 ; . . . . 1 1 . 1 1 . . . . . . .
        DB      $55,$40,$55,$40 ; 1 1 1 1 1 ._._. 1 1 1 1 1 . . .
        DB      $00,$51,$40,$00 ; . . . . 1 1 . 1 1 . . . . . . .
        DB      $00,$15,$00,$00 ; . . . . . 1 1 1 . . . . . . . .
        DB      $00,$04,$00,$00 ; . . . . . . 1 . . . . . . . . .
        DB      $00,$04,$00,$00 ; . . . . . . 1 . . . . . . . . .
        DB      $00,$04,$00,$00 ; . . . . . . 1 . . . . . . . . .
        DB      $00,$04,$00,$00 ; . . . . . . 1 . . . . . . . . .

; TREASURE "8-point STAR" #2
L2690:  DB      $05             ; 5 = X offset
        DB      $06             ; 6 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $0D             ; 13 = Height in rows
        ;
        DB      $00,$10,$00     ; . . . . . 1 . . . . . .
        DB      $80,$10,$08     ; 2 . . . . 1 . . . . 2 .
        DB      $20,$10,$20     ; . 2 . . . 1 . . . 2 . .
        DB      $08,$10,$80     ; . . 2 . . 1 . . 2 . . .
        DB      $00,$54,$00     ; . . . . 1 1 1 . . . . .
        DB      $01,$65,$00     ; . . . 1 1 2 1 1 . . . .
        DB      $55,$89,$55     ; 1 1 1 1 2_._2 1 1 1 1 1
        DB      $01,$65,$00     ; . . . 1 1 2 1 1 . . . .
        DB      $00,$54,$00     ; . . . . 1 1 1 . . . . .
        DB      $08,$10,$80     ; . . 2 . . 1 . . 2 . . .
        DB      $20,$10,$20     ; . 2 . . . 1 . . . 2 . .
        DB      $80,$10,$08     ; 2 . . . . 1 . . . . 2 .
        DB      $00,$10,$00     ; . . . . . 1 . . . . . .

; TREASURE "full 16-point STAR" #3
L26BB:  DB      $06             ; 6 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0D             ; 13 = Height in rows
        ;
        DB      $00,$0C,$00,$00 ; . . . . . . 3 . . . . . . . . .
        DB      $10,$44,$41,$00 ; . 1 . . 1 . 1 . 1 . . 1 . . . .
        DB      $08,$04,$08,$00 ; . . 2 . . . 1 . . . 2 . . . . .
        DB      $02,$04,$20,$00 ; . . . 2 . . 1 . . 2 . . . . . .
        DB      $10,$15,$00,$40 ; . 1 . . . 1 1 1 . . . . 1 . . .
        DB      $00,$59,$40,$00 ; . . . . 1 1 2 1 1 . . . . . . .
        DB      $D5,$6E,$55,$C0 ; 3 1 1 1 1 2(3)2 1 1 1 1 3 . . .
        DB      $00,$59,$40,$00 ; . . . . 1 1 2 1 1 . . . . . . .
        DB      $10,$15,$00,$40 ; . 1 . . . 1 1 1 . . . . 1 . . .
        DB      $02,$04,$20,$00 ; . . . 2 . . 1 . . 2 . . . . . .
        DB      $08,$04,$08,$00 ; . . 2 . . . 1 . . . 2 . . . . .
        DB      $10,$44,$41,$00 ; . 1 . . 1 . 1 . 1 . . 1 . . . .
        DB      $00,$0C,$00,$00 ; . . . . . . 3 . . . . . . . . .

; THESTAR loops TREASURE "THE STAR" animation table from T/I table
L26F3:  DB      $03,$00,$81     ; 3 byte/words follow
        ;
L26F6:  DB      $01,$58,$26     ; #1 durations = 1
        DB      $01,$90,$26     ; #2
        DB      $01,$BB,$26     ; #3 full 16-point STAR pattern
        DB      $00,$F6,$26     ; 0 plus a word to loop on

; SYM ?? 4-color TREASURE "SYM??" for "CYMBAL" ?? from T/F table
L2702:  DB      $05             ; 5 = X offset
        DB      $04             ; 4 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $09             ; 9 = Height in rows
        ;
        DB      $02,$A0,$00     ; . . . 2 2 2 . . . . . .
        DB      $26,$66,$00     ; . 2 1 2 1 2 1 2 . . . .
        DB      $A9,$5A,$80     ; 2 2 2 1 1 1 2 2 2 . . .
        DB      $96,$65,$80     ; 2 1 1 2 1 2 1 1 2 . . .
        DB      $D5,$D5,$C0     ; 3 1 1 1 3(1)1 1 3 . . .
        DB      $96,$65,$80     ; 2 1 1 2 1 2 1 1 2 . . .
        DB      $A9,$5A,$80     ; 2 2 2 1 1 1 2 2 2 . . .
        DB      $26,$66,$00     ; . 2 1 2 1 2 1 2 . . . .
        DB      $02,$A0,$00     ; . . . 2 2 2 . . . . . .

; TREASURE "CYMBAL" #2
L2721:  DB      $05             ; 5 = X offset
        DB      $04             ; 4 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $09             ; 9 = Height in rows
        ;
        DB      $02,$A0,$00     ; . . . 2 2 2 . . . . . .
        DB      $26,$E6,$00     ; . 2 1 2 3 2 1 2 . . . .
        DB      $AB,$FA,$80     ; 2 2 2 3 3 3 2 2 2 . . .
        DB      $BE,$EF,$80     ; 2 3 3 2 3 2 3 3 2 . . .
        DB      $FF,$FF,$C0     ; 3 3 3 3 3(3)3 3 3 . . .
        DB      $BE,$EF,$80     ; 2 3 3 2 3 2 3 3 2 . . .
        DB      $AB,$FA,$80     ; 2 2 2 3 3 3 2 2 2 . . .
        DB      $26,$E6,$00     ; . 2 1 2 3 2 1 2 . . . .
        DB      $02,$A0,$00     ; . . . 2 2 2 . . . . . .

; TREASURE "CYMBAL" #3
L2740:  DB      $05             ; 5 = X offset
        DB      $04             ; 4 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $09             ; 9 = Height in rows
        ;
        DB      $06,$A4,$00     ; . . 1 2 2 2 1 . . . . .
        DB      $26,$E6,$00     ; . 2 1 2 3 2 1 2 . . . .
        DB      $A7,$F6,$80     ; 2 2 1 3 3 3 1 2 2 . . .
        DB      $BD,$DF,$80     ; 2 3 3 1 3 1 3 3 2 . . .
        DB      $7F,$BF,$40     ; 1 3 3 3 2(3)3 3 1 . . .
        DB      $BD,$DF,$80     ; 2 3 3 1 3 1 3 3 2 . . .
        DB      $A7,$F6,$80     ; 2 2 1 3 3 3 1 2 2 . . .
        DB      $26,$E6,$00     ; . 2 1 2 3 2 1 2 . . . .
        DB      $06,$A4,$00     ; . . 1 2 2 2 1 . . . . .

; THESYM loops TREASURE "THESYM??" for "CYMBAL" ?? animation from T/I table
L275F:  DB      $03,$00,$81     ; 3 more byte-words
        ;
L2762:  DB      $01,$02,$27     ; #1 durations = 1
        DB      $01,$21,$27     ; #2
        DB      $01,$40,$27     ; #3 last CYMBAL ??
        DB      $00,$62,$27     ; loops once more ??

; JL1 4-color TREASURE "JeweL" for "DIAMOND" from T/F table
L276E:  DB      $05             ; 5 = X offset
        DB      $05             ; 5 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $0B             ; 11 = Height in rows
        ;
        DB      $00,$44,$00     ; . . . . 1 . 1 . . . . .
        DB      $01,$65,$00     ; . . . 1 1 2 1 1 . . . .
        DB      $05,$65,$40     ; . . 1 1 1 2 1 1 1 . . .
        DB      $16,$9A,$50     ; . 1 1 2 2 1 2 2 1 1 . .
        DB      $56,$76,$54     ; 1 1 1 2 1 3 1 2 1 1 1 .
        DB      $29,$DD,$A0     ; . 2 2 1 3(1)3 1 2 2 . .
        DB      $56,$76,$54     ; 1 1 1 2 1 3 1 2 1 1 1 .
        DB      $16,$9A,$50     ; . 1 1 2 2 1 2 2 1 1 . .
        DB      $05,$65,$40     ; . . 1 1 1 2 1 1 1 . . .
        DB      $01,$65,$00     ; . . . 1 1 2 1 1 . . . .
        DB      $00,$44,$00     ; . . . . 1 . 1 . . . . .

; TREASURE "DIAMOND" #2
L2793:  DB      $05             ; 5 = X offset
        DB      $05             ; 5 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $0B             ; 11 = Height in rows
        ;
        DB      $00,$CC,$00     ; . . . . 3 . 3 . . . . .
        DB      $13,$EF,$10     ; . 1 . 3 3 2 3 3 . 1 . .
        DB      $0B,$6B,$80     ; . . 2 3 1 2 2 3 2 . . .
        DB      $3E,$99,$F0     ; . 3 3 2 2 1 2 1 3 3 . .
        DB      $F6,$76,$9C     ; 3 3 1 2 1 3 1 2 2 1 3 .
        DB      $29,$ED,$A0     ; . 2 2 1 3(2)3 1 2 2 . .
        DB      $DA,$76,$9C     ; 3 1 2 2 1 3 1 2 2 1 3 .
        DB      $3E,$9A,$F0     ; . 3 3 2 2 1 2 2 3 3 . .
        DB      $0B,$AB,$80     ; . . 2 3 2 2 2 3 2 . . .
        DB      $13,$EF,$10     ; . 1 . 3 3 2 3 3 . 1 . .
        DB      $00,$CC,$00     ; . . . . 3 . 3 . . . . .

; TREASURE "DIAMOND" #3
L27B8:  DB      $05             ; 5 = X offset
        DB      $05             ; 5 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $0B             ; 11 = Height in rows
        ;
        DB      $00,$88,$00     ; . . . . 2 . 2 . . . . .
        DB      $13,$67,$10     ; . 1 . 3 1 2 1 3 . 1 . .
        DB      $07,$57,$40     ; . . 1 3 1 1 1 3 1 . . .
        DB      $3D,$99,$F0     ; . 3 3 1 2 1 2 1 3 3 . .
        DB      $96,$76,$58     ; 2 1 1 2 1 3 1 2 1 1 2 .
        DB      $29,$DD,$A0     ; . 2 2 1 3(1)3 1 2 2 . .
        DB      $96,$76,$58     ; 2 1 1 2 1 3 1 2 1 1 2 .
        DB      $3D,$99,$F0     ; . 3 3 1 2 1 2 1 3 3 . .
        DB      $07,$57,$40     ; . . 1 3 1 1 1 3 1 . . .
        DB      $13,$67,$10     ; . 1 . 3 1 2 1 3 . 1 . .
        DB      $00,$88,$00     ; . . . . 2 . 2 . . . . .

; THEJEWEL loops TREASURE "THE JEWEL" for "DIAMOND" animation table from T/I table
L27DD:  DB      $03,$00,$81     ; 3 entries
        ;
L27E0:  DB      $01,$6E,$27     ; #1 durations = 1
        DB      $01,$93,$27     ; #2
        DB      $01,$B8,$27     ; #3 last DIAMOND
        DB      $00,$E0,$27     ; 0 then loop

; FL 4-color TREASURE "FLower" for "FLOWER" from T/F table
L27EC:  DB      $04             ; 4 = X offset
        DB      $03             ; 3 = Y offset
        DB      $02             ; 2 = Width in bytes
        DB      $07             ; 7 = Height in rows
        ;
        DB      $E8,$AB         ; 3 2 2 . 2 2 2 3
        DB      $94,$96         ; 2 1 1 . 2 1 1 2
        DB      $99,$66         ; 2 1 2 1 1 2 1 2
        DB      $06,$90         ; . . 1 2(2)1 . .
        DB      $99,$66         ; 2 1 2 1 1 2 1 2
        DB      $95,$16         ; 2 1 1 1 . 1 1 2
        DB      $EA,$2B         ; 3 2 2 2 . 2 2 3

; TREASURE "FLOWER" #2
L27FE:  DB      $05             ; 5 = X offset
        DB      $04             ; 4 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $09             ; 9 = Height in rows
        ;
        DB      $D5,$15,$70     ; 3 1 1 1 . 1 1 1 1 3 . .
        DB      $7A,$2A,$D0     ; 1 3 2 2 . 2 2 2 3 1 . .
        DB      $65,$25,$90     ; 1 2 1 1 . 2 1 1 2 1 . .
        DB      $66,$59,$90     ; 1 2 1 2 1 1 2 1 2 1 . .
        DB      $01,$A4,$00     ; . . . 1 2(2)1 . . . . .
        DB      $66,$59,$90     ; 1 2 1 2 1 1 2 1 2 1 . .
        DB      $65,$45,$90     ; 1 2 1 1 1 . 1 1 2 1 . .
        DB      $7A,$8A,$D0     ; 1 3 2 2 2 . 2 2 3 1 . .
        DB      $15,$45,$40     ; . 1 1 1 1 . 1 1 1 . . .

; TREASURE "FLOWER" #3
L281D:  DB      $06             ; 6 = X offset
        DB      $05             ; 5 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $0B             ; 11 = Height in rows
        ;
        DB      $15,$45,$54     ; . 1 1 1 1 . 1 1 1 1 1 .
        DB      $75,$45,$5D     ; 1 3 1 1 1 . 1 1 1 1 3 1
        DB      $56,$8A,$95     ; 1 1 1 2 2 . 2 2 2 1 1 1
        DB      $59,$49,$65     ; 1 1 2 1 1 . 2 1 1 2 1 1
        DB      $59,$96,$65     ; 1 1 2 1 2 1 1 2 1 2 1 1
        DB      $00,$69,$00     ; . . . . 1 2(2)1 . . . .
        DB      $59,$96,$65     ; 1 1 2 1 2 1 1 2 1 2 1 1
        DB      $59,$51,$65     ; 1 1 2 1 1 1 . 1 1 2 1 1
        DB      $56,$A2,$95     ; 1 1 1 2 2 2 . 2 2 1 1 1
        DB      $45,$51,$51     ; 1 . 1 1 1 1 . 1 1 1 . 1
        DB      $15,$51,$54     ; . 1 1 1 1 1 . 1 1 1 1 .

; THEFLOWER loops TREASURE "THE FLOWER" for "FLOWER" animation from T/I table
L2842:  DB      $03,$00,$81     ; 3 entries
        ;
L2845:  DB      $01,$EC,$27     ; #1 duration = 1
        DB      $01,$FE,$27     ; #2
        DB      $01,$1D,$28     ; #3 last FLOWER
        DB      $00,$45,$28     ; repeat to pulse
; end of BONUS patterns and animations !!

; JHOS-F 4-color SAD captured HOSTAGE in-a-box pattern
L2851:  DB      $07             ; 7 = X offset
        DB      $07             ; 7 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $AA,$AA,$AA,$A0 ; 2 2 2 2 2 2 2 2 2 2 2 2 2 2 . .
        DB      $80,$00,$00,$20 ; 2 . . . . . . . . . . . . 2 . .
        DB      $80,$15,$40,$20 ; 2 . . . . 1 1 1 1 . . . . 2 . .
        DB      $80,$55,$50,$20 ; 2 . . . 1 1 1 1 1 1 . . . 2 . .
        DB      $81,$75,$D4,$20 ; 2 . . 1 1 3 1 1 3 1 1 . . 2 . .
        DB      $85,$E5,$B5,$20 ; 2 . 1 1 3 2 1 1 2 3 1 1 . 2 . .
        DB      $87,$A5,$AD,$20 ; 2 . 1 3 2 2 1 1 2 2 3 1 . 2 . .
        DB      $85,$55,$55,$20 ; 2 . 1 1 1 1 1(1)1 1 1 1 . 2 . .
        DB      $85,$7F,$D5,$20 ; 2 . 1 1 1 3 3 3 3 1 1 1 . 2 . .
        DB      $81,$D5,$74,$20 ; 2 . . 1 3 1 1 1 1 3 1 . . 2 . .
        DB      $80,$55,$50,$20 ; 2 . . . 1 1 1 1 1 1 . . . 2 . .
        DB      $80,$15,$40,$20 ; 2 . . . . 1 1 1 1 . . . . 2 . .
        DB      $80,$00,$00,$20 ; 2 . . . . . . . . . . . . 2 . .
        DB      $AA,$AA,$AA,$A0 ; 2 2 2 2 2 2 2 2 2 2 2 2 2 2 . .

; JHOS-S 4-color HAPPY freed HOSTAGE pattern
L288D:  DB      $05             ; 5 = X offset
        DB      $05             ; 5 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ;
        DB      $01,$54,$00     ; . . . 1 1 1 1 . . . . .
        DB      $05,$55,$00     ; . . 1 1 1 1 1 1 . . . .
        DB      $1F,$5F,$40     ; . 1 3 3 1 1 3 3 1 . . .
        DB      $7A,$5A,$D0     ; 1 3 2 2 1 1 2 2 3 1 . .
        DB      $7A,$5A,$D0     ; 1 3 2 2 1 1 2 2 3 1 . .
        DB      $55,$55,$50     ; 1 1 1 1 1(1)1 1 1 1 . .
        DB      $5D,$57,$50     ; 1 1 3 1 1 1 1 3 1 1 . .
        DB      $17,$FD,$40     ; . 1 1 3 3 3 3 1 1 . . .
        DB      $05,$55,$00     ; . . 1 1 1 1 1 1 . . . .
        DB      $01,$54,$00     ; . . . 1 1 1 1 . . . . .

; IJHOS-S 4-color HOLLOW happy HOSTAGE ??
L28AF:  DB      $05             ; 5 = X offset
        DB      $05             ; 5 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ;
        DB      $01,$54,$00     ; . . . 1 1 1 1 . . . . .
        DB      $04,$01,$00     ; . . 1 . . . . 1 . . . .
        DB      $1F,$0F,$40     ; . 1 3 3 . . 3 3 1 . . .
        DB      $7A,$0A,$D0     ; 1 3 2 2 . . 2 2 3 1 . .
        DB      $7A,$0A,$D0     ; 1 3 2 2 . . 2 2 3 1 . .
        DB      $40,$00,$10     ; 1 . . . ._._. . . 1 . .
        DB      $4C,$03,$10     ; 1 . 3 . . . . 3 . 1 . .
        DB      $13,$FC,$40     ; . 1 . 3 3 3 3 . 1 . . .
        DB      $04,$01,$00     ; . . 1 . . . . 1 . . . .
        DB      $01,$54,$00     ; . . . 1 1 1 1 . . . . .

; 4-color SPIDER #1 (of 4) pattern
L28D1:  DB      $0A             ; 10 = X offset
        DB      $FF             ; -1 = Y offset
        DB      $05             ; 5 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ;                                                _?_
        DB      $05,$54,$00,$15,$50 ; . . 1 1 1 1 1 . . . . . . 1 1 1 1 1 . .
        DB      $20,$07,$82,$D0,$08 ; . 2 . . . . 1 3 2 . . 2 3 1 . . . . 2 .
        DB      $81,$56,$96,$95,$52 ; 2 . . 1 1 1 1 2 2 1 1 2 2 1 1 1 1 1 . 2
        DB      $04,$53,$82,$C5,$10 ; . . 1 . 1 1 . 3 2 . . 2 3 . 1 1 . 1 . .
        DB      $21,$40,$00,$01,$46 ; . 2 . 1 1 . . . . . . . . . . 1 1 . 1 2
        DB      $81,$00,$00,$00,$42 ; 2 . . 1 . . . . . . . . . . . . 1 . . 2
        DB      $04,$00,$00,$00,$10 ; . . 1 . . . . . . . . . . . . . . 1 . .
        DB      $04,$00,$00,$00,$10 ; . . 1 . . . . . . . . . . . . . . 1 . .
        DB      $20,$00,$00,$00,$08 ; . 2 . . . . . . . . . . . . . . . . 2 .
        DB      $20,$00,$00,$00,$08 ; . 2 . . . . . . . . . . . . . . . . 2 .

; SPIDER #2 pattern
L2907:  DB      $09             ; 9 = X offset
        DB      $01             ; 1 = Y offset
        DB      $05             ; 5 = Width in bytes
        DB      $0C             ; 12 = Height in rows
        ;
        DB      $25,$00,$00,$00,$00 ; . 2 1 1 . . . . . . . . . . . . . . . .
        DB      $80,$40,$00,$00,$00 ; 2 . . . 1 . . . ._._. . . . . . . . . .
        DB      $15,$10,$00,$55,$40 ; . 1 1 1 . 1 . . . . . . 1 1 1 1 1 . . .
        DB      $80,$5E,$0B,$40,$20 ; 2 . . . 1 1 3 2 . . 2 3 1 . . . . 2 . .
        DB      $80,$5A,$5A,$55,$48 ; 2 . . . 1 1 2 2 1 1 2 2 1 1 1 1 1 . 2 .
        DB      $05,$4E,$0B,$14,$40 ; . . 1 1 1 . 3 2 . . 2 3 . 1 1 . 1 . . .
        DB      $14,$40,$00,$05,$18 ; . 1 1 . 1 . . . . . . . . . 1 1 . 1 2 .
        DB      $10,$50,$00,$01,$08 ; . 1 . . 1 1 . . . . . . . . . 1 . . 2 .
        DB      $80,$10,$00,$00,$40 ; 2 . . . . 1 . . . . . . . . . . 1 . . .
        DB      $80,$20,$00,$00,$40 ; 2 . . . . 2 . . . . . . . . . . 1 . . .
        DB      $00,$20,$00,$00,$20 ; . . . . . 2 . . . . . . . . . . . 2 . .
        DB      $00,$00,$00,$00,$20 ; . . . . . . . . . . . . . . . . . 2 . .

; SPIDER #3 pattern
L2947:  DB      $09             ; 9 = X offset
        DB      $01             ; 1 = Y offset
        DB      $05             ; 5 = Width in bytes
        DB      $0C             ; 12 = Height in rows
        ;
        DB      $25,$00,$00,$05,$80 ; . 2 1 1 . . . . . . . . . . 1 1 2 . . .
        DB      $80,$40,$00,$10,$20 ; 2 . . . 1 . . . ._._. . . 1 . . . 2 . .
        DB      $15,$10,$00,$55,$40 ; . 1 1 1 . 1 . . . . . . 1 1 1 1 1 . . .
        DB      $80,$5E,$0B,$40,$20 ; 2 . . . 1 1 3 2 . . 2 3 1 . . . . 2 . .
        DB      $80,$5A,$5A,$40,$20 ; 2 . . . 1 1 2 2 1 1 2 2 1 . . . . 2 . .
        DB      $05,$4E,$0B,$14,$00 ; . . 1 1 1 . 3 2 . . 2 3 . 1 1 . . . . .
        DB      $14,$40,$00,$05,$00 ; . 1 1 . 1 . . . . . . . . . 1 1 . . . .
        DB      $10,$50,$00,$01,$00 ; . 1 . . 1 1 . . . . . . . . . 1 . . . .
        DB      $80,$10,$00,$00,$40 ; 2 . . . . 1 . . . . . . . . . . 1 . . .
        DB      $80,$20,$00,$00,$40 ; 2 . . . . 2 . . . . . . . . . . 1 . . .
        DB      $00,$20,$00,$00,$20 ; . . . . . 2 . . . . . . . . . . . 2 . .
        DB      $00,$00,$00,$00,$20 ; . . . . . . . . . . . . . . . . . 2 . .

; SPIDER #4 pattern
L2987:  DB      $0A             ; 10 = X offset
        DB      $01             ; 1 = Y offset
        DB      $05             ; 5 = Width in bytes
        DB      $0C             ; 12 = Height in rows
        ;
        DB      $00,$00,$00,$01,$60 ; . . . . . . . . . . . . . . . 1 1 2 . .
        DB      $00,$00,$00,$04,$08 ; . . . . . . . . . ._._. . . 1 . . . 2 .
        DB      $05,$50,$00,$15,$50 ; . . 1 1 1 1 . . . . . . . 1 1 1 1 1 . .
        DB      $20,$17,$82,$D0,$08 ; . 2 . . . 1 1 3 2 . . 2 3 1 . . . . 2 .
        DB      $81,$56,$96,$90,$08 ; 2 . . 1 1 1 1 2 2 1 1 2 2 1 . . . . 2 .
        DB      $04,$13,$82,$D5,$00 ; . . 1 . . 1 . 3 2 . . 2 3 1 1 1 . . . .
        DB      $21,$40,$00,$11,$40 ; . 2 . 1 1 . . . . . . . . 1 . 1 1 . . .
        DB      $85,$00,$00,$50,$40 ; 2 . 1 1 . . . . . . . . 1 1 . . 1 . . .
        DB      $04,$00,$00,$40,$20 ; . . 1 . . . . . . . . . 1 . . . . 2 . .
        DB      $10,$00,$00,$80,$20 ; . 1 . . . . . . . . . . 2 . . . . 2 . .
        DB      $20,$00,$00,$80,$00 ; . 2 . . . . . . . . . . 2 . . . . . . .
        DB      $20,$00,$00,$00,$00 ; . 2 . . . . . . . . . . . . . . . . . .

; animation table for 4 SPIDERS above
L29C7:  DB      $04,$00,$81     ; 4 poses and loop
        ;
L29CA:  DB      $06,$07,$29     ; #2 durations = 6
        DB      $06,$47,$29     ; #3
        DB      $06,$87,$29     ; #4
        DB      $06,$D1,$28     ; #1 last SPIDER pattern
        DB      $00,$CA,$29     ; re-animate

; 4-color Spider EYES #1 (of 2) pattern
L29D9:  DB      $06             ; 6 = X offset
        DB      $01             ; 1 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $03             ; 3 = Height in rows
        ;
        DB      $AA,$00,$AA     ; 2 2 2 2 . . . . 2 2 2 2
        DB      $EF,$82,$FB     ; 3 2 3 3 2 ._._2 3 3 2 3
        DB      $3F,$C3,$FC     ; . 3 3 3 3 . . 3 3 3 3 .

; Spider EYES #2 pattern
L29E6:  DB      $06             ; 6 = X offset
        DB      $01             ; 1 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $03             ; 3 = Height in rows
        ;
        DB      $55,$00,$55     ; 1 1 1 1 . . . . 1 1 1 1
        DB      $DA,$41,$A7     ; 3 1 2 2 1 ._._1 2 2 1 3
        DB      $3F,$C3,$FC     ; . 3 3 3 3 . . 3 3 3 3 .

; animation table for ?? (NOT USED ??)
L29F3:  DB      $00,$00,$81     ; ?? NO entries ?? or ...

; animation table for 2 EYES above (also NOT USED ??)
L29F6:  DB      $02,$00,$81     ; ... 2 entries ??
        ;
L29F9:  DB      $06,$D9,$29     ; #1 Ddurations = 6
        DB      $06,$E6,$29     ; #2
        DB      $00,$F9,$29     ; ?? ZERO to loop ?

; another Spider EYES #3 pattern (used by L831B display)
L2A02:  DB      $06             ; 6 = X offset
        DB      $00             ; 0 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $03             ; 3 = Height in rows
        ;
        DB      $EA,$82,$AB     ; 3 2 2 2 2 ._._2 2 2 2 3
        DB      $39,$82,$6C     ; . 3 2 1 2 . . 2 1 2 3 .
        DB      $0F,$C3,$FC     ; . . 3 3 3 . . 3 3 3 3 .

; 4-color HOLLOW bonus ROTO #1 (of 5 facing RIGHT) pattern
L2A0F:  DB      $06             ; 6 = X offset
        DB      $06             ; 6 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$14,$00     ; . . . . . 1 1 . . . . .
        DB      $00,$28,$00     ; . . . . . 2 2 . . . . .
        DB      $02,$82,$80     ; . . . 2 2 . . 2 2 . . .
        DB      $08,$0F,$E0     ; . . 2 . . . 3 3 3 2 . .
        DB      $20,$3D,$C8     ; . 2 . . . 3 3 1 3 . 2 .
        DB      $20,$37,$C8     ; . 2 . . . 3 1 3 3 . 2 .
        DB      $80,$2A,$AA     ; 2 . . . . 2(2)2 2 2 2 2
        DB      $80,$20,$00     ; 2 . . . . 2 . . . . . .
        DB      $20,$08,$00     ; . 2 . . . . 2 . . . . .
        DB      $20,$02,$00     ; . 2 . . . . . 2 . . . .
        DB      $08,$00,$A0     ; . . 2 . . . . . 2 2 . .
        DB      $02,$82,$80     ; . . . 2 2 . . 2 2 . . .
        DB      $00,$28,$00     ; . . . . . 2 2 . . . . .
        DB      $00,$14,$00     ; . . . . . 1 1 . . . . .

; HOLLOW bonus ROTO #2 (facing RIGHT)
L2A3D:  DB      $07             ; 7 = X offset
        DB      $05             ; 5 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0C             ; 12 = Height in rows
        ;
        DB      $00,$0A,$00,$00 ; . . . . . . 2 2 . . . . . . . .
        DB      $00,$A0,$A0,$00 ; . . . . 2 2 . . 2 2 . . . . . .
        DB      $02,$03,$F8,$00 ; . . . 2 . . . 3 3 3 2 . . . . .
        DB      $08,$0F,$72,$00 ; . . 2 . . . 3 3 1 3 . 2 . . . .
        DB      $08,$0D,$F2,$10 ; . . 2 . . . 3 1 3 3 . 2 . 1 . .
        DB      $60,$0A,$AA,$90 ; 1 2 . . . . 2(2)2 2 2 2 2 1 . .
        DB      $60,$08,$00,$00 ; 1 2 . . . . 2 . . . . . . . . .
        DB      $08,$0A,$00,$00 ; . . 2 . . . 2 2 . . . . . . . .
        DB      $08,$00,$80,$00 ; . . 2 . . . . . 2 . . . . . . .
        DB      $02,$00,$28,$00 ; . . . 2 . . . . . 2 2 . . . . .
        DB      $00,$A0,$A0,$00 ; . . . . 2 2 . . 2 2 . . . . . .
        DB      $00,$0A,$00,$00 ; . . . . . . 2 2 . . . . . . . .

; HOLLOW bonus ROTO #3 (facing RIGHT)
L2A71:  DB      $06             ; 6 = X offset
        DB      $05             ; 5 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $0C             ; 12 = Height in rows
        ;
        DB      $00,$28,$10     ; . . . . . 2 2 . . 1 . .
        DB      $02,$82,$84     ; . . . 2 2 . . 2 2 . 1 .
        DB      $08,$0F,$E0     ; . . 2 . . . 3 3 3 2 . .
        DB      $20,$3D,$C8     ; . 2 . . . 3 3 1 3 . 2 .
        DB      $20,$37,$C8     ; . 2 . . . 3 1 3 3 . 2 .
        DB      $80,$2A,$AA     ; 2 . . . . 2(2)2 2 2 2 2
        DB      $80,$20,$00     ; 2 . . . . 2 . . . . . .
        DB      $20,$08,$00     ; . 2 . . . . 2 . . . . .
        DB      $20,$02,$00     ; . 2 . . . . . 2 . . . .
        DB      $08,$00,$A0     ; . . 2 . . . . . 2 2 . .
        DB      $12,$82,$80     ; . 1 . 2 2 . . 2 2 . . .
        DB      $04,$28,$00     ; . . 1 . . 2 2 . . . . .

; HOLLOW bonus ROTO #4 (facing RIGHT)
L2A99:  DB      $06             ; 6 = X offset
        DB      $05             ; 5 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $0C             ; 12 = Height in rows
        ;
        DB      $04,$28,$00     ; . . 1 . . 2 2 . . . . .
        DB      $12,$82,$80     ; . 1 . 2 2 . . 2 2 . . .
        DB      $08,$0F,$E0     ; . . 2 . . . 3 3 3 2 . .
        DB      $20,$3D,$C8     ; . 2 . . . 3 3 1 3 . 2 .
        DB      $20,$37,$C8     ; . 2 . . . 3 1 3 3 . 2 .
        DB      $80,$2A,$AA     ; 2 . . . . 2(2)2 2 2 2 2
        DB      $80,$20,$00     ; 2 . . . . 2 . . . . . .
        DB      $20,$08,$00     ; . 2 . . . . 2 . . . . .
        DB      $20,$02,$00     ; . 2 . . . . . 2 . . . .
        DB      $08,$00,$A0     ; . . 2 . . . . . 2 2 . .
        DB      $02,$82,$84     ; . . . 2 2 . . 2 2 . 1 .
        DB      $00,$28,$10     ; . . . . . 2 2 . . 1 . .

; HOLLOW bonus ROTO #5 (BIGGER, with NO legs) (and NOT repeated)
L2AC1:  DB      $07             ; 7 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$0A,$00,$00 ; . . . . . . 2 2 . . . . . . . .
        DB      $00,$A0,$A0,$00 ; . . . . 2 2 . . 2 2 . . . . . .
        DB      $0A,$03,$CA,$00 ; . . 2 2 . . . 3 3 . 2 2 . . . .
        DB      $08,$0F,$52,$00 ; . . 2 . . . 3 3 1 1 . 2 . . . .
        DB      $20,$3D,$F0,$80 ; . 2 . . . 3 3 1 3 3 . . 2 . . .
        DB      $20,$3D,$F0,$80 ; . 2 . . . 3 3 1 3 3 . . 2 . . .
        DB      $80,$02,$AA,$A0 ; 2 . . . . . .(2)2 2 2 2 2 2 . .
        DB      $80,$02,$00,$00 ; 2 . . . . . . 2 . . . . . . . .
        DB      $20,$02,$00,$00 ; . 2 . . . . . 2 . . . . . . . .
        DB      $20,$02,$80,$00 ; . 2 . . . . . 2 2 . . . . . . .
        DB      $08,$00,$20,$00 ; . . 2 . . . . . . 2 . . . . . .
        DB      $0A,$00,$0A,$00 ; . . 2 2 . . . . . . 2 2 . . . .
        DB      $00,$A0,$A0,$00 ; . . . . 2 2 . . 2 2 . . . . . .
        DB      $00,$0A,$00,$00 ; . . . . . . 2 2 . . . . . . . .

; animation table for 5 bonus ROTOS (walking) (not used ??)
L2AFD:  DB      $11,$00,$81     ; 17 entries for BONUS
        ;
L2B00:  DB      $01,$C1,$2A     ; #5 this entry NOT repeated ...
        DB      $01,$0F,$2A     ; #1 ... 4 duplicated from these
        DB      $01,$71,$2A     ; #3
        DB      $01,$3D,$2A     ; #2
        DB      $01,$99,$2A     ; #4
        DB      $01,$FB,$23     ; PIN-WHEEL #1 (from DIGGERS above)
        DB      $01,$59,$24     ; PIN-WHEEL #4
        DB      $01,$1B,$24     ; PIN-WHEEL #2
        DB      $01,$37,$24     ; PIN-WHEEL #3
        DB      $01,$FB,$23     ; PIN-WHEEL #1 again ... and these
        DB      $01,$59,$24     ; PIN-WHEEL #4 again
        DB      $01,$1B,$24     ; PIN-WHEEL #2 again
        DB      $01,$37,$24     ; PIN-WHEEL #3 again
        DB      $01,$0F,$2A     ; #1 again
        DB      $01,$71,$2A     ; #3 again
        DB      $01,$3D,$2A     ; #2 again
        DB      $01,$99,$2A     ; #4 again
        DB      $00,$00,$2B     ; for looping bonus ROTO walk

; ?? yet another animation loop for walking ROTOS
L2B36:  DB      $07,$00,$83     ; ?? 7 entries ... NOT!
        ;
L2B39:  DB      $00,$00,$2B     ; ?? table ABOVE THIS is at L2B00 ??
        DB      $40,$00,$2B     ; ?? re-loop twice ?? duration = 64 ??

; 4-color HOLLOW bonus ROTO #1 (of 3 facing LEFT) patterns
L2B3F:  DB      $07             ; 7 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$0A,$00,$00 ; . . . . . . 2 2 . . . . . . . .
        DB      $00,$A0,$A0,$00 ; . . . . 2 2 . . 2 2 . . . . . .
        DB      $0A,$FC,$0A,$00 ; . . 2 2 3 3 3 . . . 2 2 . . . .
        DB      $08,$5F,$02,$00 ; . . 2 . 1 1 3 3 . . . 2 . . . .
        DB      $20,$D7,$C2,$80 ; . 2 . . 3 1 1 3 3 . . 2 2 . . .
        DB      $20,$F5,$C0,$80 ; . 2 . . 3 3 1 1 3 . . . 2 . . .
        DB      $AA,$A8,$00,$20 ; 2 2 2 2 2 2 2_._. . . . . 2 . .
        DB      $00,$08,$00,$20 ; . . . . . . 2 . . . . . . 2 . .
        DB      $00,$20,$00,$80 ; . . . . . 2 . . . . . . 2 . . .
        DB      $00,$80,$00,$80 ; . . . . 2 . . . . . . . 2 . . .
        DB      $0A,$80,$2A,$00 ; . . 2 2 2 . . . . 2 2 2 . . . .
        DB      $01,$AA,$A0,$00 ; . . . 1 2 2 2 2 2 2 . . . . . .
        DB      $01,$00,$00,$00 ; . . . 1 . . . . . . . . . . . .
        DB      $05,$00,$00,$00 ; . . 1 1 . . . . . . . . . . . .

; HOLLOW bonus ROTO #2 (facing LEFT)
L2B7B:  DB      $07             ; 7 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$0A,$00,$00 ; . . . . . . 2 2 . . . . . . . .
        DB      $00,$A0,$A0,$00 ; . . . . 2 2 . . 2 2 . . . . . .
        DB      $0A,$FC,$0A,$00 ; . . 2 2 3 3 3 . . . 2 2 . . . .
        DB      $08,$5F,$02,$00 ; . . 2 . 1 1 3 3 . . . 2 . . . .
        DB      $20,$D7,$C0,$80 ; . 2 . . 3 1 1 3 3 . . . 2 . . .
        DB      $20,$F5,$C0,$80 ; . 2 . . 3 3 1 1 3 . . . 2 . . .
        DB      $AA,$A8,$00,$20 ; 2 2 2 2 2 2 2_._. . . . . 2 . .
        DB      $00,$08,$00,$20 ; . . . . . . 2 . . . . . . 2 . .
        DB      $00,$20,$00,$80 ; . . . . . 2 . . . . . . 2 . . .
        DB      $00,$80,$00,$80 ; . . . . 2 . . . . . . . 2 . . .
        DB      $0A,$80,$02,$00 ; . . 2 2 2 . . . . . . 2 . . . .
        DB      $00,$A9,$A8,$00 ; . . . . 2 2 2 1 2 2 2 . . . . .
        DB      $00,$01,$00,$00 ; . . . . . . . 1 . . . . . . . .
        DB      $00,$05,$00,$00 ; . . . . . . 1 1 . . . . . . . .

; HOLLOW bonus ROTO #3 (facing LEFT)
L2BB7:  DB      $07             ; 7 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$0A,$00,$00 ; . . . . . . 2 2 . . . . . . . .
        DB      $00,$A0,$A0,$00 ; . . . . 2 2 . . 2 2 . . . . . .
        DB      $0A,$FC,$0A,$00 ; . . 2 2 3 3 3 . . . 2 2 . . . .
        DB      $08,$5F,$02,$00 ; . . 2 . 1 1 3 3 . . . 2 . . . .
        DB      $20,$D7,$C0,$80 ; . 2 . . 3 1 1 3 3 . . . 2 . . .
        DB      $20,$F5,$C0,$80 ; . 2 . . 3 3 1 1 3 . . . 2 . . .
        DB      $AA,$A8,$00,$20 ; 2 2 2 2 2 2 2_._. . . . . 2 . .
        DB      $00,$08,$00,$20 ; . . . . . . 2 . . . . . . 2 . .
        DB      $00,$20,$00,$80 ; . . . . . 2 . . . . . . 2 . . .
        DB      $00,$80,$00,$80 ; . . . . 2 . . . . . . . 2 . . .
        DB      $0A,$80,$0A,$00 ; . . 2 2 2 . . . . . 2 2 . . . .
        DB      $00,$AA,$A4,$00 ; . . . . 2 2 2 2 2 2 1 . . . . .
        DB      $00,$00,$04,$00 ; . . . . . . . . . . 1 . . . . .
        DB      $00,$00,$14,$00 ; . . . . . . . . . 1 1 . . . . .

; animation table for 3 WALK patterns (facing LEFT) above
L2BF3:  DB      $03,$00,$81     ; 3 entries
        ;
L2BF6:  DB      $02,$3F,$2B     ; #1 durations = 2
        DB      $02,$7B,$2B     ; #2
        DB      $02,$B7,$2B     ; #3 last facing LEFT pattern
        DB      $00,$F6,$2B     ; loop WALK

; HOLLOW (facing LEFT) ROTO see: previous animation loop ??
L2C02:  DB      $07,$00,$83     ; 7 entries ... NOT!
        ;
L2C05:  DB      $40,$F6,$2B     ; duration = 64 before ??
        DB      $00,$F6,$2B     ; ?? re-loop twice ??

; 4-color DIGGING patterns #1 (of 6 facing LEFT)
L2C0B:  DB      $08             ; 8 = X offset
        DB      $07             ; 7 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $10             ; 16 = Height in rows
        ;
        DB      $7D,$50,$00,$00 ; 1 3 3 1 1 1 . . . . . . . . . .
        DB      $7F,$D5,$54,$00 ; 1 3 3 3 3 1 1 1 1 1 1 . . . . .
        DB      $7F,$D5,$55,$40 ; 1 3 3 3 3 1 1 1 1 1 1 1 1 . . .
        DB      $FF,$55,$55,$50 ; 3 3 3 3 1 1 1 1 1 1 1 1 1 1 . .
        DB      $15,$55,$55,$54 ; . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 .
        DB      $02,$97,$EA,$80 ; . . . 2 2 1 1 3 3 2 2 2 2 . . .
        DB      $0A,$B5,$FA,$A0 ; . . 2 2 2 3 1 1 3 3 2 2 2 2 . .
        DB      $0A,$BD,$7A,$A0 ; . . 2 2 2 3 3 1(1)3 2 2 2 2 . .
        DB      $2A,$AA,$AA,$A8 ; . 2 2 2 2 2 2 2 2 2 2 2 2 2 2 .
        DB      $00,$02,$AA,$A8 ; . . . . . . . 2 2 2 2 2 2 2 2 .
        DB      $00,$0A,$AA,$A0 ; . . . . . . 2 2 2 2 2 2 2 2 . .
        DB      $00,$2A,$AA,$A0 ; . . . . . 2 2 2 2 2 2 2 2 2 . .
        DB      $02,$AA,$AA,$80 ; . . . 2 2 2 2 2 2 2 2 2 2 . . .
        DB      $00,$6A,$A8,$00 ; . . . . 1 2 2 2 2 2 2 . . . . .
        DB      $00,$40,$00,$00 ; . . . . 1 . . . . . . . . . . .
        DB      $01,$40,$00,$00 ; . . . 1 1 . . . . . . . . . . .

; DIGGING pattern #2 (facing LEFT)
L2C4F:  DB      $08             ; 8 = X offset
        DB      $07             ; 7 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $10             ; 16 = Height in rows
        ;
        DB      $7D,$50,$00,$00 ; 1 3 3 1 1 1 . . . . . . . . . .
        DB      $7F,$D5,$54,$00 ; 1 3 3 3 3 1 1 1 1 1 1 . . . . .
        DB      $7F,$D5,$55,$40 ; 1 3 3 3 3 1 1 1 1 1 1 1 1 . . .
        DB      $FF,$55,$55,$50 ; 3 3 3 3 1 1 1 1 1 1 1 1 1 1 . .
        DB      $15,$55,$55,$54 ; . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 .
        DB      $02,$97,$EA,$80 ; . . . 2 2 1 1 3 3 2 2 2 2 . . .
        DB      $0A,$B5,$FA,$A0 ; . . 2 2 2 3 1 1 3 3 2 2 2 2 . .
        DB      $0A,$BD,$7A,$A0 ; . . 2 2 2 3 3 1(1)3 2 2 2 2 . .
        DB      $2A,$AA,$AA,$A8 ; . 2 2 2 2 2 2 2 2 2 2 2 2 2 2 .
        DB      $00,$02,$AA,$A8 ; . . . . . . . 2 2 2 2 2 2 2 2 .
        DB      $00,$0A,$AA,$A0 ; . . . . . . 2 2 2 2 2 2 2 2 . .
        DB      $00,$2A,$AA,$A0 ; . . . . . 2 2 2 2 2 2 2 2 2 . .
        DB      $02,$AA,$AA,$80 ; . . . 2 2 2 2 2 2 2 2 2 2 . . .
        DB      $00,$2A,$68,$00 ; . . . . . 2 2 2 1 2 2 . . . . .
        DB      $00,$00,$40,$00 ; . . . . . . . . 1 . . . . . . .
        DB      $00,$01,$40,$00 ; . . . . . . . 1 1 . . . . . . .

; DIGGING pattern #3 (facing LEFT)
L2C93:  DB      $08             ; 8 = X offset
        DB      $07             ; 7 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $10             ; 16 = Height in rows
        ;
        DB      $7D,$50,$00,$00 ; 1 3 3 1 1 1 . . . . . . . . . .
        DB      $7F,$D5,$54,$00 ; 1 3 3 3 3 1 1 1 1 1 1 . . . . .
        DB      $7F,$D5,$55,$40 ; 1 3 3 3 3 1 1 1 1 1 1 1 1 . . .
        DB      $FF,$55,$55,$50 ; 3 3 3 3 1 1 1 1 1 1 1 1 1 1 . .
        DB      $15,$55,$55,$54 ; . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 .
        DB      $02,$97,$EA,$80 ; . . . 2 2 1 1 3 3 2 2 2 2 . . .
        DB      $0A,$B5,$FA,$A0 ; . . 2 2 2 3 1 1 3 3 2 2 2 2 . .
        DB      $0A,$BD,$7A,$A0 ; . . 2 2 2 3 3 1(1)3 2 2 2 2 . .
        DB      $2A,$AA,$AA,$A8 ; . 2 2 2 2 2 2 2 2 2 2 2 2 2 2 .
        DB      $00,$02,$AA,$A8 ; . . . . . . . 2 2 2 2 2 2 2 2 .
        DB      $00,$0A,$AA,$A0 ; . . . . . . 2 2 2 2 2 2 2 2 . .
        DB      $00,$2A,$AA,$A0 ; . . . . . 2 2 2 2 2 2 2 2 2 . .
        DB      $02,$AA,$AA,$80 ; . . . 2 2 2 2 2 2 2 2 2 2 . . .
        DB      $00,$2A,$A9,$00 ; . . . . . 2 2 2 2 2 2 1 . . . .
        DB      $00,$00,$01,$00 ; . . . . . . . . . . . 1 . . . .
        DB      $00,$00,$05,$00 ; . . . . . . . . . . 1 1 . . . .

; DIGGING pattern #4 (facing LEFT)
L2CD7:  DB      $08             ; 8 = X offset
        DB      $07             ; 7 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $10             ; 16 = Height in rows
        ;
        DB      $BD,$50,$00,$00 ; 2 3 3 1 1 1 . . . . . . . . . .
        DB      $BF,$D5,$54,$00 ; 2 3 3 3 3 1 1 1 1 1 1 . . . . .
        DB      $BF,$D5,$55,$40 ; 2 3 3 3 3 1 1 1 1 1 1 1 1 . . .
        DB      $FF,$55,$55,$50 ; 3 3 3 3 1 1 1 1 1 1 1 1 1 1 . .
        DB      $15,$55,$55,$54 ; . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 .
        DB      $02,$BF,$EA,$80 ; . . . 2 2 3 3 3 3 2 2 2 2 . . .
        DB      $0A,$B7,$FA,$A0 ; . . 2 2 2 3 1 3 3 3 2 2 2 2 . .
        DB      $0A,$BD,$FA,$A0 ; . . 2 2 2 3 3 1(3)3 2 2 2 2 . .
        DB      $2A,$AA,$AA,$A8 ; . 2 2 2 2 2 2 2 2 2 2 2 2 2 2 .
        DB      $00,$02,$AA,$A8 ; . . . . . . . 2 2 2 2 2 2 2 2 .
        DB      $00,$0A,$AA,$A0 ; . . . . . . 2 2 2 2 2 2 2 2 . .
        DB      $00,$2A,$AA,$A0 ; . . . . . 2 2 2 2 2 2 2 2 2 . .
        DB      $02,$AA,$AA,$80 ; . . . 2 2 2 2 2 2 2 2 2 2 . . .
        DB      $00,$1A,$A8,$00 ; . . . . . 1 2 2 2 2 2 . . . . .
        DB      $00,$10,$00,$00 ; . . . . . 1 . . . . . . . . . .
        DB      $00,$50,$00,$00 ; . . . . 1 1 . . . . . . . . . .

; DIGGING pattern #5 (facing LEFT)
L2D1B:  DB      $08             ; 8 = X offset
        DB      $07             ; 7 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $10             ; 16 = Height in rows
        ;
        DB      $BD,$50,$00,$00 ; 2 3 3 1 1 1 . . . . . . . . . .
        DB      $BF,$D5,$54,$00 ; 2 3 3 3 3 1 1 1 1 1 1 . . . . .
        DB      $BF,$D5,$55,$40 ; 2 3 3 3 3 1 1 1 1 1 1 1 1 . . .
        DB      $FF,$55,$55,$50 ; 3 3 3 3 1 1 1 1 1 1 1 1 1 1 . .
        DB      $15,$55,$55,$54 ; . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 .
        DB      $02,$BF,$EA,$80 ; . . . 2 2 3 3 3 3 2 2 2 2 . . .
        DB      $0A,$B7,$FA,$A0 ; . . 2 2 2 3 1 3 3 3 2 2 2 2 . .
        DB      $0A,$BD,$FA,$A0 ; . . 2 2 2 3 3 1(3)3 2 2 2 2 . .
        DB      $2A,$AA,$AA,$A8 ; . 2 2 2 2 2 2 2 2 2 2 2 2 2 2 .
        DB      $00,$02,$AA,$A8 ; . . . . . . . 2 2 2 2 2 2 2 2 .
        DB      $00,$0A,$AA,$A0 ; . . . . . . 2 2 2 2 2 2 2 2 . .
        DB      $00,$2A,$AA,$A0 ; . . . . . 2 2 2 2 2 2 2 2 2 . .
        DB      $02,$AA,$AA,$80 ; . . . 2 2 2 2 2 2 2 2 2 2 . . .
        DB      $00,$0A,$68,$00 ; . . . . . . 2 2 1 2 2 . . . . .
        DB      $00,$00,$40,$00 ; . . . . . . . . 1 . . . . . . .
        DB      $00,$01,$40,$00 ; . . . . . . . 1 1 . . . . . . .

; DIGGING pattern #6 (facing LEFT)
L2D5F:  DB      $08             ; 8 = X offset
        DB      $07             ; 7 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $10             ; 16 = Height in rows
        ;
        DB      $BD,$50,$00,$00 ; 2 3 3 1 1 1 . . . . . . . . . .
        DB      $BF,$D5,$54,$00 ; 2 3 3 3 3 1 1 1 1 1 1 . . . . .
        DB      $BF,$D5,$55,$40 ; 2 3 3 3 3 1 1 1 1 1 1 1 1 . . .
        DB      $FF,$55,$55,$50 ; 3 3 3 3 1 1 1 1 1 1 1 1 1 1 . .
        DB      $15,$55,$55,$54 ; . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 .
        DB      $02,$BF,$EA,$80 ; . . . 2 2 3 3 3 3 2 2 2 2 . . .
        DB      $0A,$B7,$FA,$A0 ; . . 2 2 2 3 1 3 3 3 2 2 2 2 . .
        DB      $0A,$BD,$FA,$A0 ; . . 2 2 2 3 3 1(3)3 2 2 2 2 . .
        DB      $2A,$AA,$AA,$A8 ; . 2 2 2 2 2 2 2 2 2 2 2 2 2 2 .
        DB      $00,$02,$AA,$A8 ; . . . . . . . 2 2 2 2 2 2 2 2 .
        DB      $00,$0A,$AA,$A0 ; . . . . . . 2 2 2 2 2 2 2 2 . .
        DB      $00,$2A,$AA,$A0 ; . . . . . 2 2 2 2 2 2 2 2 2 . .
        DB      $02,$AA,$AA,$80 ; . . . 2 2 2 2 2 2 2 2 2 2 . . .
        DB      $00,$0A,$A9,$00 ; . . . . . . 2 2 2 2 2 1 . . . .
        DB      $00,$00,$01,$00 ; . . . . . . . . . . . 1 . . . .
        DB      $00,$00,$05,$00 ; . . . . . . . . . . 1 1 . . . .

; animation table for 6 DIGGING patterns above (NOT used)
L2DA3:  DB      $09,$00,$81
        ;
L2DA6:  DB      $02,$0B,$2C     ; #1 durations = 2
        DB      $02,$4F,$2C     ; #2
        DB      $02,$93,$2C     ; #3
        DB      $02,$0B,$2C     ; #1 again
        DB      $02,$4F,$2C     ; #2 again
        DB      $02,$93,$2C     ; #3 again
        DB      $02,$D7,$2C     ; #4
        DB      $02,$1B,$2D     ; #5
        DB      $02,$5F,$2D     ; #6
        DB      $00,$A6,$2D     ; and loop ...

; ROTROTY final animation loop for "PAUSE then DIG ROTOS" (from several TERSE)
L2DC4:  DB      $07,$00,$83     ; only 1 or ??
        ;
L2DC7:  DB      $40,$A6,$2D     ; duration = 64 before re-loop
        DB      $00,$A6,$2D     ; and do twice ...

; ROTO and one LAST Remaining ROBBY ROTO (facing LEFT with 2 FEET) pattern
L2DCD:  DB      $08             ; 8 = X offset
        DB      $07             ; 7 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $10             ; 16 = Height in rows
        ;
        DB      $BD,$50,$00,$00 ; 2 3 3 1 1 1 . . . . . . . . . .
        DB      $BF,$D5,$54,$00 ; 2 3 3 3 3 1 1 1 1 1 1 . . . . .
        DB      $BF,$D5,$55,$40 ; 2 3 3 3 3 1 1 1 1 1 1 1 1 . . .
        DB      $FF,$55,$55,$50 ; 3 3 3 3 1 1 1 1 1 1 1 1 1 1 . .
        DB      $15,$55,$55,$54 ; . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 .
        DB      $02,$BF,$EA,$80 ; . . . 2 2 3 3 3 3 2 2 2 2 . . .
        DB      $0A,$B7,$FA,$A0 ; . . 2 2 2 3 1 3 3 3 2 2 2 2 . .
        DB      $0A,$BD,$FA,$A0 ; . . 2 2 2 3 3 1 3 3 2 2 2 2 . .
        DB      $2A,$AA,$AA,$A8 ; . 2 2 2 2 2 2 2 2 2 2 2 2 2 2 .
        DB      $00,$02,$AA,$A8 ; . . . . . . . 2 2 2 2 2 2 2 2 .
        DB      $00,$0A,$AA,$A0 ; . . . . . . 2 2 2 2 2 2 2 2 . .
        DB      $00,$2A,$AA,$A0 ; . . . . . 2 2 2 2 2 2 2 2 2 . .
        DB      $02,$AA,$AA,$80 ; . . . 2 2 2 2 2 2 2 2 2 2 . . .
        DB      $00,$1A,$A9,$00 ; . . . . . 1 2 2 2 2 2 1 . . . .
        DB      $00,$10,$01,$00 ; . . . . . 1 . . . . . 1 . . . .
        DB      $00,$50,$05,$00 ; . . . . 1 1 . . . . 1 1 . . . .
 ; end of Patterns

;**********************************************************
;  More of TERSE FORTH ENGINE code ??
;**********************************************************

; more word Pushers VOLume C and Noise Mode for Left or Right CHANNEL blocks
L2E11:  RST     $20             ; do "(SP)->HL, (HL)->DE->(SP)" !!
        DW      $FFF9           ; VOLC in non-protected Static RAM ??
; ?? NOT used for PMOD Word Pusher offset -7 for ??

; ?? Word ?? for Right SOUND Block ??
L2E14:  RST     $20             ; do "(SP)->HL, (HL)->DE->(SP)" !!
        DW      $FE27           ; again in non-protected Static RAM ??

; ?? Word ?? for Left SOUND Block ??
L2E17:  RST     $20             ; do "(SP)->HL, (HL)->DE->(SP)" !!
        DW      $FE01           ; again in non-protected Static RAM ??
; end of word Pushers

; ?? routine
; note: DE is -7, -14, or -21 quantum from IY for ??
L2E1A:  PUSH    IY
        POP     HL
        ADD     HL,DE
        DEC     (HL)
        JP      NZ,L2EB5
        INC     HL
        LD      A,(HL)
        DEC     HL
        LD      (HL),A
        INC     HL
        INC     HL
        BIT     0,(HL)
        RET     Z
        LD      C,(HL)
        INC     HL
        BIT     2,C
        JR      NZ,L2E92                ; (+$61)
        BIT     3,C
        JR      Z,L2E6E                 ; (+$39)
        INC     HL
        INC     HL
        INC     HL
        XOR     A
        CP      (HL)
        JR      Z,L2E55                 ; (+$19)
        DEC     (HL)
        JR      NZ,L2E55                ; (+$16)
        RES     0,C
        LD      DE,$0006        ; 6 for ??
        OR      A
        SBC     HL,DE
        LD      (HL),$00
        BIT     5,C
        JR      Z,L2E51                 ; (+$04)
        LD      (IY+$10),$01    ; TVMROPT offset 16 for ??
L2E51:  INC     HL
        INC     HL
        LD      (HL),C
        RET

; ?? does ??
L2E55:  DEC     HL
        DEC     HL
        DEC     HL
        RES     3,C
        BIT     1,C
        JR      NZ,L2E63                ; (+$05)
        XOR     A
        SUB     (HL)
        LD      (HL),A
        JR      L2E6E                   ; (+$0b)

; ??
L2E63:  DEC     HL
        LD      (HL),C
        BIT     4,C
        INC     HL
        INC     HL
        JR      Z,L2E6C                 ; (+$01)
        INC     HL
L2E6C:  LD      B,(HL)
        RET

; ??
L2E6E:  LD      A,B
        ADD     A,(HL)
        LD      B,A
        INC     HL
        CP      (HL)
        JR      NC,L2E7B                ; (+$06)
        SET     4,C
        SET     3,C
        JR      L2E8C                   ; (+$11)

L2E7B:  JR      NZ,L2E83                ; (+$06)
        SET     4,C
        SET     3,C
        JR      L2E8C                   ; (+$09)

L2E83:  INC     HL
        CP      (HL)
        JR      C,L2E8B                 ; (+$04)
        RES     4,C
        SET     3,C
L2E8B:  DEC     HL
L2E8C:  DEC     HL
        DEC     HL
        LD      (HL),C
        RET

; L2E90: ??
        JR      L2EB2                   ; (+$20)

; ?? does ??
L2E92:  INC     HL
        PUSH    HL
        LD      A,(HL)
        INC     HL
        SUB     (HL)
        NEG
        INC     A
        LD      E,A
        LD      D,$00
        CALL    L1A4C           ; do SHIFT and limit RANGE for Next Pseudo-RANDOM Number
        LD      A,L
        POP     HL
        ADD     A,(HL)
        LD      B,A
        DEC     HL
        LD      E,(HL)
        DEC     E
        JR      Z,L2EB2                 ; (+$09)
        INC     E
L2EAA:  SUB     E
        JR      NC,L2EAA                ; (-$03)
        ADD     A,E
        SUB     B
        NEG
        LD      B,A
L2EB2:  JP      L2EB8                   ; not JR ??

L2EB5:  INC     HL
        INC     HL
        LD      C,(HL)
L2EB8:  RET

; ?? does ?? routine
L2EB9:  XOR     A
        CP      (IY+$10)        ; TVMROPT offset 16
        JP      NZ,L2F63
        CP      (IY+$0F)
        JP      NZ,L2F63
        INC     (IY+$0F)
        CP      (IY+$0E)        ; TTIMER offset 14 for "Time for TIMER"
        JR      Z,L2ED7                 ; (+$09) if TIMER timed out
        DEC     (IY+$0E)        ; TTIMER offset 14 for "Time for TIMER"
        JR      NZ,L2ED7                ; (+$04) if TIMER still NOT timed out
        LD      (IY+$10),$01    ; TVMROPT offset 16 for ??
L2ED7:  CP      (IY-$15)
        JR      Z,L2EE9                 ; (+$0d)
        LD      B,(IY+$05)
        LD      DE,$FFEB        ; quantum -21 for ??
        CALL    L2E1A           ; do ??
        LD      (IY+$05),B
        XOR     A
L2EE9:  CP      (IY-$07)        ; PMOD offset -7 MINUS ??
        JR      Z,L2F32                 ; (+$44)
        INC     A
        CP      (IY-$07)        ; PMOD offset -7 MINUS ??
        JR      NZ,L2F25                ; (+$31)
        LD      A,(IY+$0D)      ; TTBMAX offset 13
        OR      A
        JR      Z,L2F25                 ; (+$2b)
        LD      A,(IY-$06)      ; RMctr offset -6 for ( hostage guarding state ) Variable MINUS ??
L2EFD:  RLCA
        RLCA
        RLCA
        RLCA
        AND     $0F
        INC     A
        LD      (IY-$0D),A      ; TREECK offset -13 MINUS ??
        LD      A,(IY+$01)
        DEC     A
        LD      A,(IY-$09)      ; FNDPTR offset -9 MINUS ??
        JR      Z,L2F16                 ; (+$06)
        LD      E,A
        RRCA
        RRCA
        RRCA
        RRCA
        OR      E
L2F16:  LD      (IY+$06),A      ; TVMRL offset 6
        LD      (IY-$08),$01    ; FNDPTRH offset -8 MINUS ??
        LD      (IY-$0E),$01    ; MYBOSSH offset -14 MINUS ??
        LD      (IY-$0C),$03    ; TREECKH offset -12 MINUS ??
L2F25:  LD      B,(IY+$0C)      ; TSCALE offset 12
        LD      DE,$FFF9        ; PMOD offset -7 MINUS ??
        CALL    L2E1A           ; do ??
        LD      (IY+$0C),B      ; TSCALE offset 12
        XOR     A
L2F32:  CP      (IY-$0E)        ; MYBOSSH offset -14 MINUS ??
        JR      Z,L2F5F                 ; (+$28)
        LD      A,(IY+$06)      ; TVMRL offset 6
        AND     $0F
        LD      B,A
        LD      DE,$FFF2        ; quantum -14 for ??
        CALL    L2E1A           ; do ??
        LD      L,(IY+$01)
        DEC     L
        LD      A,B
        JR      Z,L2F4F                 ; (+$05)
        RRCA
        RRCA
        RRCA
        RRCA
        OR      B
L2F4F:  LD      (IY+$06),A      ; TVMRL offset 6
        INC     L
        JR      NZ,L2F5E                ; (+$09)
        LD      A,(IY+$07)      ; TVMRH offset 7
        AND     $F0
        OR      B
        LD      (IY+$07),A      ; TVMRH offset 7
L2F5E:  XOR     A
L2F5F:  XOR     A
        LD      (IY+$0F),A
L2F63:  LD      C,(IY+$00)
        PUSH    IY
        POP     HL
        LD      DE,$0005        ; 5 for ??
        ADD     HL,DE
        LD      B,$08
        OTIR
        RET
;
;**********************************************************
; ?? Start of MUSIC code ??
;**********************************************************
; ?? does "INITALIZE some SOUND Block locations"
L2F72:  PUSH    DE              ; store SOUND Block
        LD      HL,$0000        ; 0 for ??
        ADD     HL,DE
        LD      C,(HL)          ; read SNDBX OUTport from SOUND Block
        LD      B,$08
        PUSH    BC              ; store 8 for OUTport count
        LD      HL,$0004        ; 4 for ?? offset
        ADD     HL,DE
        LD      BC,$000B        ; 11 for Byte Count
        PUSH    HL              ; store SOUND Block+4
        PUSH    HL
        POP     DE              ; peek at SOUND Block+4
        LD      (HL),$00        ; clear it
        INC     DE
        LDIR                    ; also clear SOUND Block+5 thru +16
        POP     HL              ; restore SOUND Block+4 (need +5 for VOLN ??)
        POP     BC              ; restore 8 for OUTport Byte Count
        OTIR                    ; OUTput SOUND Block+4 thru +11 ??
        POP     HL              ; restore SOUND Block
        DEC     HL
        PUSH    HL              ; read SOUND Block-1 for ??
        POP     DE
        DEC     DE              ; SOUND Block-2 for ??
        LD      BC,$0014        ; 20 for Byte Count
        LD      (HL),$00        ; clear it
        LDDR                    ; also clear 20 before that for ??
        EXX
        RET

; ?? does "LOAD SNDBX OUTport into proper SOUND Block location"
L2F9C:  LD      HL,$0000        ; 0 offset for SNDBX OUTport in SOUND Block
        ADD     HL,DE
        LD      (HL),A          ; save SNDBX OUTport (reference ONLY !!)
        JP      L2F72                   ; not JR ?? to "INITALIZE some SOUND Block locations"

; ?? does "SET for Right CHANNEL"
L2FA4:  LD      A,$18           ; for Right SNDBX OUTport
        EXX
        LD      DE,$FE27        ; read Word ?? for Right SOUND Block ??
        JR      L2F9C                   ; (-$10) to Load

; SET for Left CHANNEL
L2FAC:  LD      A,$58           ; for Left SNDBX OUTport
        EXX
        LD      DE,$FE01        ; point to WORD Left SOUND Block ?? for ??
        JR      L2F9C                   ; (-$18) to Load

; ?? does SETUP for BOTH CHANNELS from FORTH
L2FB4:  CALL    L2FA4           ; do Initalize for Right CHANNEL
        CALL    L2FAC           ; do Initalize for Left CHANNEL
        JP      (IY)            ; indexed RETurn

; ?? does ?? routine
L2FBC:  LD      A,($E3FF)       ; GAMEOVER read "GAME OVER" (disallows ??) in High WRITE-protected NV-RAM
        OR      A
        JR      Z,L2FD6                 ; (+$14)
        PUSH    HL
        LD      HL,$E3F5        ; for Word ?? in High WRITE-protected NV RAM
        LD      E,(HL)
        INC     E
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        POP     HL
        LD      A,($E3FA)       ; read Byte ?? in High WRITE-protected NV-RAM
        OR      A
        JR      NZ,L2FD6                ; (+$04)
        INC     A
        LD      ($FEEB),A       ; write Byte 1 for ?? in Static RAM
L2FD6:  EX      DE,HL
        LD      HL,($E3F9)      ; read Word ?? (for ??) in High WRITE-protected NV-RAM
        ADD     HL,DE
        EX      AF,AF'
        LD      A,$09
        CP      H
        JR      NC,L2FE4                ; (+$03)
        LD      HL,$0900        ; 2304 for ??
L2FE4:  EX      DE,HL
        LD      HL,$E3F9        ; point to Word ?? (for ??) in High WRITE-protected NV-RAM
        CALL    L0794           ; do Write WORD to High and Low-1 WRITE-protected NVRAM
        LD      E,$0A
        LD      HL,$E3F8        ; point to Word ?? (for ??) in High WRITE-protected NV-RAM
        JP      L07A9           ; to Write BYTE to High and Low WRITE-protected NVRAM

; ?? does ??
L2FF3:  AND     $2F
        XOR     $2F
        JR      Z,L2FFC                 ; (+$03)
        LD      ($FE3A),A       ; write Byte ?? for ?? in Static RAM
L2FFC:  RET

; count ?? in inport SW0 masked with 1 or 2 subroutine
L2FFD:  LD      L,$00
L2FFF:  IN      A,(C)           ; =&(16) for SWitch bank 0 for Game controls
        LD      H,A
        AND     D
        CP      E
        JR      Z,L3009                 ; (+$03)
        INC     L
        LD      B,$01           ; odd way to loop ??
L3009:  DJNZ    L2FFF                   ; (-$0c)
        LD      A,L
        OR      A
        RET

; set LAMPs here subroutine with B = 1 or 3
L300E:  LD      C,$15           ; using SWitch bank 5 for Special controls
        LD      A,($E3F8)       ; read Byte ?? for ?? in High WRITE-protected NV-RAM
        OR      A
        JR      NZ,L301B                ; (+$05) skip if ?? Not Zero
        DEC     B               ; turn Off latch 0 or (0 and 1)
        IN      A,(C)           ; inport =&(21) SW5 for Special controls
        XOR     A
        RET                     ; urn with Z flag Set if ?? was 0

; if ?? Not Zero
L301B:  CP      $0A             ; if ?? = 10 then turn On latch 0 or (0 and 1)
        JR      NZ,L3021                ; (+$02) else don't
        IN      B,(C)           ; inport =&(21) for Special controls
L3021:  OR      A
        RET                     ; urn with Z flag Cleared if ?? not 0

L3023:  LD      A,($E3FF)       ; GAMEOVER read "GAME OVER" (disallows ??) in High WRITE-protected NV-RAM
        OR      A
        JR      Z,L3039                 ; (+$10)
        LD      A,($FE3A)       ; read Byte ?? for ?? in Static RAM
        OR      A
        JR      NZ,L3039                ; (+$0a)
        IN      A,(SW2)         ; =&(18) for SWitch bank 2 for Player 1 4WAY controls
        CALL    L2FF3
        IN      A,(SW1)         ; =&(17) for SWitch bank 1 for Player 2 4WAY controls
        CALL    L2FF3
L3039:  IN      A,(SW0)         ; inport =&(16) SWitch bank 0 for Control Port
        BIT     TILT,A          ; test for bit 4 (aka SLAM SWitch) active Low
        JR      NZ,L305D                ; (+$1e) to test SERVICE switch
; Machine TILTed !!
        CALL    L0843           ; do Two pairs of 0's then a pair of 1's
        LD      HL,$E3FA        ; point to ?? in High WRITE-protected NV-RAM
        LD      A,(HL)
        OR      A
        JR      Z,L304A                 ; (+$01)
        DEC     A
L304A:  LD      E,A
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
; exit here
L304E:  DI                      ; Disable Interrupts
        CALL    L2FA4           ; do setup for Right CHANNEL
        CALL    L2FAC           ; do setup for Left CHANNEL
        LD      A,$A0
L3057:  CPIR
        DEC     A
        JR      NZ,L3057                ; (-$05)
        RST     $00             ; RESET to Start of Robby Roto

; if Not Tilted, is it in Service mode ?
L305D:  BIT     SERVICE,A       ; test for bit 3 (aka TEST SWitch) active Low
        JR      NZ,L3063                ; (+$02) no, carry on
        JR      L304E                   ; (-$15) exit on SERVICE !!

; carry on here
L3063:  LD      BC,$0010        ; word 16 for SW0
        LD      A,($E3F4)       ; read Byte ?? in High WRITE-protected NV-RAM
        XOR     $FF             ; complement ?? same as CPL A ??
        PUSH    AF
        LD      D,$01           ; for ?? mask
        AND     D
        LD      E,A
        CALL    L2FFD           ; do count ?? in inport SW0 masked with 1
        JR      NZ,L3099                ; (+$24)
        LD      HL,$E3F4        ; point to Word ?? in High WRITE-protected NV-RAM
L3078:  LD      A,(HL)
        BIT     0,E
        JR      NZ,L3085                ; (+$08)
        RES     0,A
        LD      E,A
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        JR      L3099                   ; (+$14)

; on ??
L3085:  SET     0,A
        LD      E,A
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        LD      HL,($E3F2)      ; read Word for ?? Slot 1 in High WRITE-protected NV-RAM
        CALL    L2FBC           ; do ??
        LD      HL,$E3F7        ; point to Word ?? in in High WRITE-protected NV-RAM
        LD      E,(HL)
        INC     E
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
; ??
L3099:  LD      BC,$0010        ; word 16 for SW0
        POP     AF
        LD      D,$02           ; for ?? mask
        AND     D
        LD      E,A
        CALL    L2FFD           ; do count ?? in inport SW0 masked with 2
        JR      NZ,L30CA                ; (+$24)
        LD      HL,$E3F4        ; point to Word ?? in High WRITE-protected NV-RAM
        LD      A,(HL)
        BIT     1,E
        JR      NZ,L30B6                ; (+$08)
        RES     1,A
        LD      E,A
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        JR      L30CA                   ; (+$14)

L30B6:  SET     1,A
        LD      E,A
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        LD      HL,($E3EE)      ; read Word ?? Slot 2 in High WRITE-protected NV RAM
        CALL    L2FBC           ; do ??
        LD      HL,$E3F6        ; point to Word ?? in High WRITE-protected NV RAM
        LD      E,(HL)
        INC     E
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
; ?? knows 1 or 2 Coin Slots
L30CA:  LD      HL,$E3F7        ; point to Word ?? in High WRITE-protected NV RAM
        LD      A,(HL)
        OR      A
        JR      Z,L30DD                 ; (+$0c) skip ??
        LD      B,$01
        CALL    L300E           ; do Set LAMPs for 1 Coin Slot ??
        JR      NZ,L30DD                ; (+$05) skip if ??
        LD      E,(HL)
        DEC     E
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
L30DD:  LD      HL,$E3F6        ; point to Word ?? in High WRITE-protected NV RAM
        LD      A,(HL)
        OR      A
        JR      Z,L3101                 ; (+$1d)
        EXX
        LD      HL,($E3F2)      ; point to Word ?? Slot 1 in High WRITE-protected NV RAM
        LD      DE,($E3EE)      ; point to Word ?? Slot 2 in High WRITE-protected NV RAM
        SBC     HL,DE
        EXX
        JR      NZ,L30F5                ; (+$04)
        LD      B,$01           ; for 1 lamp
        JR      L30F7                   ; (+$02)

L30F5:  LD      B,$03           ; for 2 lamps
L30F7:  CALL    L300E           ; do Set LAMPs for 1 or 2 Coin Slots ??
        JR      NZ,L3101                ; (+$05) skip if ??
        LD      E,(HL)
        DEC     E
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
L3101:  LD      HL,$E3F8        ; point to Word ?? in High WRITE-protected NV RAM
        LD      E,(HL)
        DEC     E
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        LD      A,($E3EA)       ; ?? jiffies or seconds ?? in High WRITE-protected NV RAM
        INC     A
        CP      $3C             ; is it 60 yet ?
        JR      NZ,L311D                ; (+$0c) no
        LD      DE,($E3E8)      ; bump ?? seconds or minutes ?? in High WRITE-protected NV RAM
        INC     DE
        LD      HL,$E3E8        ; point to Word ?? in High WRITE-protected NV RAM
        CALL    L0794           ; do Write WORD to High and Low-1 WRITE-protected NVRAM
        XOR     A               ; reset jiffies or seconds ??
L311D:  LD      HL,$E3EA        ; point to ?? jiffies or seconds ?? in High WRITE-protected NV RAM
        LD      E,A
        CALL    L07A9           ; do Write BYTE to High and Low WRITE-protected NVRAM
        RET

; ?? does Alternate enrty into First Interrupt Routine ?? in Static RAM ??
L3125:  PUSH    AF
        PUSH    BC
        PUSH    DE
        PUSH    HL
        EXX
        EX      AF,AF'
        PUSH    AF
        PUSH    BC
        PUSH    DE
        PUSH    HL
        PUSH    IY
        PUSH    IX
        LD      A,($FE3A)       ; read Byte ?? for ?? in Static RAM
        OR      A
        JR      Z,L3147                 ; (+$0e)
        LD      IY,$FE27        ; point to WORD Right SOUND Block ?? for IndexY ??
        CALL    L2EB9
        LD      IY,$FE01        ; point to WORD Left SOUND Block ?? for IndexY ??
        CALL    L2EB9
L3147:  CALL    L3023
        JP      L1395           ; to ?? continue First Interrupt Routine ?? in Static RAM ??

; OUTput outport &((??))=L ?? (used to set SOUND segments in ATTRACT mode !!)
; with B = 5, 6, 7, 8, 1, 3, or 2 for OUTport $18-B or $58-B for TONMO thru VOLN
L314D:  LD      DE,($FE38)      ; (LEFT is $FE01, RIGHT is $FE27) ?? in Static RAM
        LD      C,L             ; byte L = DATA to write
        LD      HL,$0000        ; 0 for ?? (to get CHANNEL block Right or Left)
        ADD     HL,DE           ; points at CHANNEL+$00 with an $18 or $58 in it
        LD      A,(HL)          ; read ?? for SNDBX or SNDBX+$40 (not used !!)
        SUB     B
        LD      L,C             ; swap A and C thru L
        LD      C,A
        LD      A,L
        OUT     (C),A           ; output DATA to SNDBX (or SNDBX+$40) - B given
        RET

; ?? does "read $FE38 again in Static RAM then PUSH it for CHANNEL block" from Terse
L315E:  LD      HL,($FE38)      ; (LEFT is $FE01, RIGHT is $FE27) ?? in Static RAM again
        PUSH    HL              ; address of CHANNEL block
        JP      (IY)            ; indexed RETurn

; ?? 8 for SETting SOUND PORTS from TERSE (during ATTRACT mode and ??)
; with DATA byte from Top of System stack then SAVE it offset in Static RAM ??
;
; ?? does SET and SAVE a (Right or Left CHANNEL) TONMO sound port
L3164:  EXX
        POP     HL              ; get DATA into L
        LD      B,$08           ; for setting TONMO
        CALL    L314D
        LD      HL,$000C        ; 12 offset for saving old TONMO ??
        ADD     HL,DE           ; from DE (ALWAYS ($FE38) ?? in Static RAM)
        LD      (HL),A
        EXX
        JP      (IY)            ; indexed RETurn

; ?? does SET and SAVE a VOLN sound port
L3173:  EXX
        POP     HL              ; see above
        LD      B,$01           ; for setting VOLN
        CALL    L314D
        LD      HL,$0005        ; 5 offset for saving old VOLN ??
        ADD     HL,DE
        LD      (HL),A
        EXX
        JP      (IY)            ; indexed RETurn

; ?? does ?? then SET and SAVE a VOLAB sound port
L3182:  EXX
        POP     HL
        LD      A,($E3FF)       ; GAMEOVER read "GAME OVER" (disallows Volume changes) in High WRITE-protected NV RAM
        OR      A
        JR      Z,L3195                 ; (+$0b)
        LD      A,$0E
        AND     L
        RRA
        LD      H,A
        LD      A,$E0
        AND     L
        RRA
        OR      H
        LD      L,A
L3195:  LD      B,$02           ; for setting VOLAB
        CALL    L314D
        LD      HL,$0006        ; 6 offset for saving old VOLAB ??
        ADD     HL,DE
        LD      (HL),A
        EXX
        JP      (IY)            ; indexed RETurn

; ?? does ?? then SET and SAVE a VOLC sound port
L31A2:  EXX
        POP     HL
        LD      A,($E3FF)       ; GAMEOVER read "GAME OVER" (disallows Volume changes)) in High WRITE-protected NV RAM
        OR      A
        JR      Z,L31B4                 ; (+$0a)
        LD      A,L
        AND     $F0
        LD      H,A
        LD      A,$0E
        AND     L
        RRA                     ; divide ?? by 2
        OR      H
        LD      L,A
L31B4:  LD      B,$03           ; for setting VOLC
        CALL    L314D
        LD      HL,$0007        ; 7 offset for saving old VOLC ??
        ADD     HL,DE
        LD      (HL),A
        EXX
        JP      (IY)            ; indexed RETurn

; ?? does SET and SAVE a VIBRA sound port
L31C1:  EXX
        POP     HL
        LD      B,$04           ; for setting VIBRA
        CALL    L314D
        LD      HL,$0008        ; 8 offset for saving old VIBRA ??
        ADD     HL,DE
        LD      (HL),A
        EXX
        JP      (IY)            ; indexed RETurn

; ?? does SET and SAVE a TONEA sound port
L31D0:  EXX
        POP     HL
        LD      B,$07           ; for setting TONEA
        CALL    L314D
        LD      HL,$000B        ; 11 offset for saving old TONEA ??
        ADD     HL,DE
        LD      (HL),A
        EXX
        JP      (IY)            ; indexed RETurn

; does SET and SAVE a TONEB sound port
L31DF:  EXX
        POP     HL
        LD      B,$06           ; for setting TONEB
        CALL    L314D
        LD      HL,$000A        ; 10 offset for saving old TONEB ??
        ADD     HL,DE
        LD      (HL),A
        EXX
        JP      (IY)            ; indexed RETurn

; ?? does SET and SAVE a TONEC sound port
L31EE:  EXX
        POP     HL
        LD      B,$05           ; for setting TONEC
        CALL    L314D
        LD      HL,$0009        ; 9 offset for saving old TONEC ??
        ADD     HL,DE
        LD      (HL),A
        EXX
        JP      (IY)            ; indexed RETurn
; end of setting and saving SOUND PORTS from TERSE

; ?? does ?? (only place to set TONE, and does ALL 3 !!)
L31FD:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L31EE           ; set TONEC sound port
        ;
        DW      L31DF           ; set TONEB sound port
        ;
        DW      L31D0           ; set TONEA sound port
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does
L3206:  LD      HL,($FE38)      ; address of L or R SOUND block ??
        LD      DE,$0001        ; 1 for ??
        ADD     HL,DE
        POP     DE
        LD      (HL),E
        JP      (IY)            ; indexed RETurn

; ?? does
L3211:  LD      HL,$0002        ; 2 for ??
        LD      DE,($FE38)      ; address of L or R SOUND block ??
        ADD     HL,DE
        LD      (HL),C
        INC     HL
        LD      (HL),B
        LD      HL,$0010        ; TVMROPT 16 for ??
        ADD     HL,DE
        LD      (HL),$00
        RET

; ?? does
L3223:  CALL    L3211
        CALL    L2F72           ; ?? do "INITALIZE some SOUND Block locations"
        POP     BC
        JP      (IY)            ; indexed RETurn

; ?? does
L322C:  EXX
        LD      DE,($FE38)      ; address of L or R SOUND block ??
        CALL    L2F72           ; ?? do "INITALIZE some SOUND Block locations"
        JP      (IY)            ; indexed RETurn

; ?? does
L3236:  CALL    L3211
        POP     BC
        JP      (IY)            ; indexed RETurn

; ?? does
L323C:  EXX
        POP     BC
        LD      HL,($FE38)      ; address of L or R SOUND block ??
        LD      DE,$000E        ; TTIMER offset 14 for ??
        ADD     HL,DE
        LD      (HL),C
        EXX
        CALL    L3211
        POP     BC
        JP      (IY)            ; indexed RETurn

; ?? FAKE a TerseJUMP using TOP of System Stack as NEW TersePC
L324D:  POP     BC              ; obliterate OLD Terse Program Counter !!
        JP      (IY)            ; indexed RETurn

; ?? does
L3250:  LD      HL,($FE38)      ; address of L or R SOUND block ??
        LD      DE,$0004        ; 4 for ??
        ADD     HL,DE
        LD      (HL),$01
        JP      (IY)            ; indexed RETurn

; ?? does
L325B:  LD      HL,($FE38)      ; address of L or R SOUND block ??
        LD      DE,$0004        ; 4 for ??
        ADD     HL,DE
        LD      (HL),$00
        JP      (IY)            ; indexed RETurn

; ?? does
L3266:  POP     DE
        LD      HL,($FE38)      ; address of L or R SOUND block ??
        ADD     HL,DE
        LD      (HL),$00
        INC     HL
        INC     HL
        RES     0,(HL)
        JP      (IY)            ; indexed RETurn

; ?? does
L3273:  POP     DE
        LD      HL,($FE38)      ; address of L or R SOUND block ??
        ADD     HL,DE
        POP     DE
        LD      (HL),E
        INC     HL
        INC     HL
        SET     0,(HL)
        JP      (IY)            ; indexed RETurn

; ?? does "POP a Sound Block VOLC, VIBRA, TONEC, TONEB, TONEA, and TONMO"
L3280:  POP     DE
        LD      HL,($FE38)      ; address of L or R SOUND block ??
        ADD     HL,DE
        LD      DE,$0005        ; 5 for VOLC ??
        ADD     HL,DE
        LD      A,$06           ; suck 6 values
L328B:  POP     DE
        LD      (HL),E
        DEC     HL              ; port - 1
        DEC     A
        JR      NZ,L328B                ; (-$06)
        JP      (IY)            ; indexed RETurn

; ?? does
L3293:  POP     DE
        LD      HL,($FE38)      ; address of L or R SOUND block ??
        ADD     HL,DE
        LD      DE,$0006        ; 6 for VOLAB ??
        ADD     HL,DE
        POP     DE
        LD      (HL),E
        JP      (IY)            ; indexed RETurn

; ?? does
L32A0:  LD      DE,$000D        ; 13 for ??
        LD      HL,($FE38)      ; address of L or R SOUND block ??
        ADD     HL,DE
        LD      (HL),$01
        JP      (IY)            ; indexed RETurn

; ?? does
L32AB:  PUSH    IY
        PUSH    DE
        POP     IY
        LD      A,L
        CP      (IY+$04)        ; TSTAT offset 4
        JR      C,L32C9                 ; (+$13)
        PUSH    DE
        EXX
        POP     DE
        CALL    L2F72           ; ?? do "INITALIZE some SOUND Block locations"
        LD      (IY+$10),$01    ; TVMROPT offset 16 for ??
        LD      (IY+$04),L      ; TSTAT offset 4
        LD      (IY+$02),C      ; TRC offset 2 (?/ or TOPAPCL offset 2 ??)
        LD      (IY+$03),B      ; TD offset 3 (?? or TOPAPCH offset 3 ??)
L32C9:  POP     IY
        RET

; ?? does
L32CC:  POP     DE
        POP     HL
        CALL    L32AB
        LD      C,(IX+$00)
        INC     IX
        LD      B,(IX+$00)
        INC     IX
        JP      (IY)            ; indexed RETurn

; ?? does ??
L32DD:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L2E14           ; do Word Pusher for $FE27 (in non-protected Static RAM)           ;
        ;
        DW      L32CC
        ;
        DW      L3223
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L32E8:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L3223
        ;
        DW      L00B0           ; ... TerseRETurn

; SHUTUP does "SHUT UP all sounds"
L32F3:  RST     $08             ; begin ASSEMBLED TerseCODE ...C
        ;
        DW      L2FB4           ; do SETUP for BOTH Channels
        ;
        DW      L32DD
        ;
        DW      L32E8
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does
L32FC:  LD      A,($FE37)       ; read Byte ?? for ?? in Static RAM
        OR      A
        JR      Z,L330D                 ; (+$0b)
        PUSH    BC
        LD      BC,($FE29)      ; read Word Right SOUND Block+2 for ??
        LD      HL,$FE27        ; store address of Right SOUND block ??
        LD      ($FE38),HL      ; write Word ?? into ?? in Static RAM
L330D:  JP      (IY)            ; indexed RETurn

; ?? does
L330F:  LD      A,($FE11)       ; read Byte ?? for Left SOUND Block+16 ??
        OR      A
        JR      Z,L3320                 ; (+$0b)
        PUSH    BC
        LD      BC,($FE03)      ; read WORD Left SOUND Block+2 ?? for ??
        LD      HL,$FE01        ; store address of Left SOUND block ??
        LD      ($FE38),HL      ; write Word ?? into ?? in Static RAM
L3320:  JP      (IY)            ; indexed RETurn

; ?? does ??
L3322:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ; BEGIN loop
L3325:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE3A           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; _IF False skip
        DW      L03CD,L3333     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L32FC
        ;
        DW      L330F
        ; _THEN continue
L3333:  DW      L1660           ; SYNC do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; END or loop to BEGIN if False
        DW      L03CD,L3325     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn

; PUP does ??
L333D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L215C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3125           ; point to ?? Alternate entry into First Interrupt routine
        ;
        DW      L00BC           ; SUI3V "pushWORD to System stack"
        DW      $FEF8           ; for Word ?? (an Interrupt Vector !!) in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDD2           ; for Word ?? for ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1A             ; 26 for ??
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDD2           ; for Word ?? for ?? in Static RAM
        ;
        DW      L3322
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE3A           ; Word ?? in Static RAM
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      L2FB4           ; do SETUP for BOTH Channels
        ;
        DW      L32DD
        ;
        DW      L32E8
        ;
        DW      L053B           ; EI do "Enable Interrupt"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "PUSH TONE A location"
L336B:  LD      HL,$FDCE        ; TONEA point to "TONE A" in Static RAM
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; ?? does ??
L3371:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
L3372:  DW      L315E           ; read address of ?? CHANNEL block then PUSH it
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; IF False skip
        DW      L03CD,L337E     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L3223
        ; THEN carry on
L337E:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $58             ; 88 as data for TONEA
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $59             ; 89 as data for TONEB
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5A             ; 90 as data for TONEC
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L00BC           ; TONMO "pushWORD to System stack"
        DW      $FDCF           ; for "TONe Master Oscillator" in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L336B           ; ?? do "PUSH TONE A location"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; TONMO "pushWORD to System stack"
        DW      $FDCF           ; for "TONe Master Oscillator" in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L336B           ; ?? do "PUSH TONE A location"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F5           ; 6 "BYTE Pusher"
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack" for VIBRA and TONEC
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $2A             ; 42 as data for VOLC
        ;
        DW      L31A2           ; set VOLC sound port = 10 and NM = 2 ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $AA             ; 170 for both VOLume A and VOLume B = 10
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0529           ; -1 (hex $FFFF) "WORD Pusher"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L04FD           ; 10 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF2
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L32A0
        ;
        DW      L3236
        ;
        DW      L00B0           ; ... TerseRETurn

; STARTEXCITE does ??
L33D9:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDD0           ; for Word ?? for ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L0509           ; 96 ?? "BYTE Pusher" for ??
        ;
        DW      L00BC           ; TONMO "pushWORD to System stack"
        DW      $FDCF           ; for "TONe Master Oscillator" in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L336B           ; ?? do "PUSH TONE A location"
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      L00B0           ; ... TerseRETurn

; walk-s does ?? routine
L33F0:  PUSH    BC
        LD      BC,L3372        ; point to ??
        LD      DE,$FE27        ; read Word ?? for Right SOUND Block ??
        LD      L,$00
        CALL    L32AB
        POP     BC
        RET

; WALK-S does ?? from Terse
L33FE:  CALL    L33F0           ; walk-s do ??
        JP      (IY)            ; indexed RETurn

; ?? does ??
L3403:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L33D9           ; STARTEXCITE do ??
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L336B           ; ?? do "PUSH TONE A location"
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L2FB4           ; do SETUP for BOTH Channels
        ;
        DW      L33FE           ; WALK-S do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L337E           ; poimt at ??
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3422:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
L3423:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $58             ; for TONEA = 88
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $59             ; for TONEB = 89
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5A             ; for TONEC = 90
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1C             ; for TONMO = 28
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L04FD           ; 10 "BYTE Pusher" for ??
        ;
        DW      L3173           ; set VOLN sound port
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L0511           ; 16 "BYTE Pusher" for ??
        ;
        DW      L0509           ; 96 ?? "BYTE Pusher" for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L04FD           ; 10 "BYTE Pusher" for ??
        ;
        DW      L0517           ; 46 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEB           ; quantum -21 for ??
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1B             ; 27 for VOLC = 11 and NM = 1 ??
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $BB             ; 187 for both VOLume A and VOLume B = 11
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0529           ; -1 (hex $FFFF) "WORD Pusher"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L04FF           ; 11 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF2
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L32A0
        ;
        DW      L3236
        ;
        DW      L00B0           ; ... TerseRETurn

; dig-s does ?? routine
L347B:  PUSH    BC
        LD      BC,L3423        ; 13347 for ?? (or L3422 + 1 ??)
        LD      DE,$FE27        ; read Word ?? for Right SOUND Block ??
        LD      L,$00
        CALL    L32AB
        POP     BC
        RET

; DIG-S does ?? from Terse ??
L3489:  CALL    L347B           ; dig-s do ??
        JP      (IY)            ; indexed RETurn

; ?? does ??
L348E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L3489           ; DIG-S do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3422           ; point to ??
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L34A5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L050B           ; 35 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDD0           ; for Word ?? for ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L02F4           ; do "Pop HL, (HL*2 + SP - 2)->DE, Push DE to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0519           ; 48 "BYTE Pusher" for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3293
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L34CE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0529           ; -1 (hex $FFFF) "WORD Pusher"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0E             ; 14 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF2
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $EE             ; 238 for both VOLume A and VOLume B = 14
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3E             ; 62 for VOLume C = 14 and NM = 3
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L34EE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDD0           ; for Word ?? for ?? in Static RAM
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0442           ; 1+B! do "Pop HL, ADD 1 to (HL)"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L016B           ; 2* do "Double Top of System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDD1           ; for Word ?? for ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3507:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L34EE
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ; ?? entry point for FAKE TerseJUMP ??
L3510:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $70             ; for TONE A = 112
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $68             ; for TONE B = 104
        ;
        DW      L0509           ; 96 "BYTE Pusher" for TONE C = 96
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L3173           ; set VOLN sound port
        ; BEGIN loop
L351E:  DW      L34CE
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $22             ; 34 for ??
        ;
        DW      L34A5
        ;
        DW      L3236
        ;
        DW      L34CE
        ;
        DW      L0519           ; 48 "BYTE Pusher" for ??
        ;
        DW      L34A5
        ;
        DW      L3236
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDD1           ; for Word ?? for ?? in Static RAM
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0448           ; 1-B! do "Pop HL, SUBtract 1 from (HL)"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; END or loop to BEGIN if False
        DW      L03CD,L351E     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L322C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3371           ; point to ??
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; JAW-S does ??
L354D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L2FB4           ; do SETUP for BOTH Channels
        ;
        DW      L3507
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L2E14           ; do Word Pusher for $FE27 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3510           ; point to ?? label
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3560:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; TONMO "pushWORD to System stack"
        DW      $FDCF           ; for "TONe Master Oscillator" in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for ??
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0517           ; 46 "BYTE Pusher" for ??
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; IF False skip to THEN
        DW      L03CD,L3579     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L0509           ; 96 "BYTE Pusher" for ??
        ; THEN
L3579:  DW      L00BC           ; TONMO "pushWORD to System stack"
        DW      $FDCF           ; for "TONe Master Oscillator" in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3581:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
L3582:  DW      L336B           ; ?? do "PUSH TONE A location"
        ;
        DW      L0448           ; 1-B! do "Pop HL, SUBtract 1 from (HL)"
        ;
        DW      L3560
        ;
        DW      L0519           ; 48 "BYTE Pusher" for ??
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1F             ; for TONE A = 31
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $32             ; for TONE B = 50
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $54             ; for TONE C = 84
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L0519           ; 48 "BYTE Pusher" for ??
        ;
        DW      L3173           ; set VOLN sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3F             ; 63 for ??
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L051D           ; 255 "BYTE Pusher" for both VOLA and VOLB = 15
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L050F           ; 33 "BYTE Pusher" for ??
        ;
        DW      L052F           ; -3 (hex $FFFD) "WORD Pusher"
        ;
        DW      L0507           ; 15 "BYTE Pusher" for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $71             ; 113 for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3293
        ;
        DW      L3236
        ;
        DW      L34EE
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3510           ; point to ?? label
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L35C7:  PUSH    AF
        PUSH    BC
        PUSH    DE
        PUSH    HL
        EXX
        EX      AF,AF'
        PUSH    AF
        PUSH    BC
        PUSH    DE
        PUSH    HL
        LD      BC,L3582        ; point to ??
        LD      DE,$FE01        ; point to WORD Left SOUND Block ?? for ??
        LD      L,$02
        CALL    L32AB
        POP     HL
        POP     DE
        POP     BC
        POP     AF
        EXX
        EX      AF,AF'
        POP     HL
        POP     DE
        POP     BC
        POP     AF
        RET

; DRUG-S does ??
L35E7:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L336B           ; ?? do "PUSH TONE A location"
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L3560
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $61             ; for TONEMO = 97
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L050F           ; 33 "BYTE Pusher" for ??
        ;
        DW      L052C           ; -2 (hex $FFFE) "WORD Pusher"
        ;
        DW      L0507           ; 15 "BYTE Pusher" for ??
        ;
        DW      L0509           ; 96 "BYTE Pusher" for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3293
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3E             ; for TONE A = 62
        ;
        DW      L050D           ; 41 "BYTE Pusher" for TONE B = 41
        ;
        DW      L0503           ; 13 "BYTE Pusher" for TONE C = 13
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $16             ; for VOLume C = 22
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $66             ; 102 for both VOLume A and VOLume B = 6
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $39             ; for Noise VOLume = 57 ??
        ;
        DW      L3173           ; set VOLN sound port
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L052C           ; -2 (hex $FFFE) "WORD Pusher"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $39             ; 57 for ??
        ;
        DW      L0507           ; 15 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEB           ; quantum -21 for ??
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L3236
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L3223
        ;
        DW      L00B0           ; ... TerseRETurn (broken ??)

; CAPT-S does ??
L3646:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L336B           ; ?? do "PUSH TONE A location"
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L051B           ; 64 "BYTE Pusher" for ??
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L050B           ; 35 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF0
        ;
        DW      L0511           ; 16 "BYTE Pusher" for ??
        ;
        DW      L051B           ; 64 "BYTE Pusher" for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3293
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L0511           ; 16 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEB           ; quantum -21 for ??
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $42             ; for TONE A = 66
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $37             ; for TONE B = 55
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5E             ; for TONE C = 94
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $18             ; for VOLume C = 8 and NM = 1 ??
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $88             ; for both VOLume A and VOLume B = 8
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L3236
        ;
        DW      L3223
        ;
        DW      L00B0           ; ... TerseRETurn

; KEY-S does ??
L369C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
L36A3:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $8C             ; for VIBRAtion = 140 ??
        ;
        DW      L31C1           ; set VIBRA sound port
        ;
        DW      L0511           ; 16 "BYTE Pusher" for ??
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L050D           ; 41 "BYTE Pusher" for TONE A = 41
        ;
        DW      L0513           ; 126 "BYTE Pusher" for TONE B = 126 (hex $7E)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $31             ; for TONE C = 49
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for ??
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $66             ; 102 for both VOLume A and VOLume B = 6
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L0509           ; 96 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L3223
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L36C6:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L369C           ; KEY-S do ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E14           ; do Word Pusher for $FE27 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L36A3           ; point to ??
        ;
        DW      L324D
        ;
        DW      L00B0           ; ... TerseRETurn

; TREA-S does ??
L36DB:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L051B           ; 64 "BYTE Pusher" for ??
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L0513           ; 126 (hex $7E) "BYTE Pusher" for ??
        ;
        DW      L0515           ; 49 "BYTE Pusher" for ??
        ;
        DW      L050D           ; 41 "BYTE Pusher" for ??
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L04FD           ; 10 "BYTE Pusher" for ??
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $AA             ; 170 for both VOLume A and VOLume B = 10
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $48             ; for VIBRAtion = 72 ??
        ;
        DW      L31C1           ; set VIBRA sound port
        ;
        DW      L04FD           ; 10 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L050B           ; 35 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF8
        ;
        DW      L0511           ; 16 "BYTE Pusher" for ??
        ;
        DW      L051B           ; 64 "BYTE Pusher" for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3293
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L31C1           ; set VIBRA sound port
        ;
        DW      L3236
        ;
        DW      L3223
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3722:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L2E14           ; do Word Pusher for $FE27 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
L3729:  DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L050B           ; 35 "BYTE Pusher" for ??
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $34             ; 52 for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $84             ; 132 for VIBRAtion register ??
        ;
        DW      L31C1           ; set VIBRA sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3293
        ;
        DW      L050D           ; 41 "BYTE Pusher" for ??
        ;
        DW      L0513           ; 126 (hex $7E) "BYTE Pusher" for ??
        ;
        DW      L0515           ; 49 "BYTE Pusher" for ??
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L04FB           ; 9 "BYTE Pusher" for VOLume C = 9 and NM = 0
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $99             ; 153 for both VOLume A and VOLume B = 9
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L3236
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L31C1           ; set VIBRA sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $19             ; 25 for VOLume C = 9 and NM = 1
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for Noise VOLume = 3
        ;
        DW      L3173           ; set VOLN sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L052F           ; -3 (hex $FFFD) "WORD Pusher"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $34             ; 52 for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L3236
        ;
        DW      L00B0           ; ... TerseRETurn

; GRAB-S does ??
L377E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L3722
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3729           ; point to ??
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3793:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E14           ; do Word Pusher for $FE27 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
L379A:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $58             ; 88 as data for TONEMO
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L050B           ; 35 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF8
        ;
        DW      L0511           ; 16 "BYTE Pusher" for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $58             ; 88 for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L050D           ; 41 "BYTE Pusher" for ??
        ;
        DW      L0513           ; 126 (hex $7E) "BYTE Pusher" for ??
        ;
        DW      L0515           ; 49 "BYTE Pusher" for ??
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $09             ; for VOLume C = 9 and NM = 0
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $99             ; 153 for both VOLume A and VOLume B = 9
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3293
        ;
        DW      L3236
        ;
        DW      L3223
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L37D0:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L3793
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L379A           ; point to ??
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L37E5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E14           ; do Word Pusher for $FE27 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
L37EC:  DW      L0511           ; 16 "BYTE Pusher" for ??
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L050F           ; 33 "BYTE Pusher" for ??
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0511           ; 16 "BYTE Pusher" for ??
        ;
        DW      L0519           ; 48 "BYTE Pusher" for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $82             ; for VIBRAtion = 130 ??
        ;
        DW      L31C1           ; set VIBRA sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3293
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3E             ; for TONE A = 62
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $46             ; for TONE B = 70
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $64             ; for TONE C = 100
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $2B             ; 43 for VOLume C = 3 and NM = 4 ??
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $BB             ; 187 for both VOLume A and VOLume B = 11
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L3236
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L2FB4           ; do SETUP for BOTH Channels
        ;
        DW      L3223
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L382C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L37E5
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L37EC           ; point to ??
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; RODAN-S does ??
L3841:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; for TONE A = 80
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $18             ; for TONE B = 24
        ;
        DW      L050B           ; 35 "BYTE Pusher" for TONE C = 35
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3293
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $54             ; for TONMO = 84
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L050B           ; 35 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF2
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $54             ; 84 for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $34             ; for VOLumr Noise = 52 ??
        ;
        DW      L3173           ; set VOLN sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $88             ; for both VOLume A and VOLume B = 8
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $18             ; for VOLume C = 8 and NM = 1 ??
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L3236
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; for TONMO = 20
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L050B           ; 35 "BYTE Pusher" for ??
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $F4             ; 244 for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3293
        ;
        DW      L3236
        ;
        DW      L3223
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L38A5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L2E14           ; do Word Pusher for $FE27 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $BB             ; 187 for both VOLume A and VOLume B = 11
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3B             ; 59 for both VOLume C = 11 and NM = 3
        ;
L38B2:  DW      L31A2           ; set VOLC sound port
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $84             ; 132 for TONEMO
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $80             ; 128 for ??
        ;
        DW      L051B           ; 64 "BYTE Pusher" for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFFA
        ;
        DW      L0519           ; 48 "BYTE Pusher" for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $84             ; 132 for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $18             ; for VOLume N = 24 ??
        ;
        DW      L3173           ; set VOLN sound port
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L0529           ; -1 (hex $FFFF) "WORD Pusher"
        ;
        DW      L04FB           ; 9 "BYTE Pusher" for ??
        ;
        DW      L0507           ; 15 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF2
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L3236
        ;
        DW      L3223
        ;
        DW      L00B0           ; ... TerseRETurn

; CARRY-S does ??
L38F5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L2FB4           ; do SETUP for BOTH Channels
        ;
        DW      L38A5
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L051D           ; 255 (or -1) "BYTE Pusher" for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3F             ; 63 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L38B2           ; point to ??
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3911:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L2E14           ; do Word Pusher for $FE27 (in non-protected Static RAM)
        ;
        DW      L32CC
        ; ?? entry point for FAKE TerseJUMP ??
L3918:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $48             ; for TONMO = 72 ??
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $46             ; for VIBRAtion = 70 ??
        ;
        DW      L31C1           ; set VIBRA sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0529           ; -1 (hex $FFFF) "WORD Pusher"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $2B             ; 43 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $48             ; 72 for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $80             ; for TONE A = 128
        ;
        DW      L051B           ; 64 "BYTE Pusher" for TONE B = 64
        ;
        DW      L051F           ; 32 "BYTE Pusher" for TONE C = 32
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $CC             ; 204 for both VOLume A and VOLume B = 12
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $2C             ; 44 for VOLume C = 12 and NM = 2 ??
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L0505           ; 14 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; TONEB "pushWORD to System stack"
        DW      $FDCD           ; for "TONE B locatiom=n" in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; BEGIN loop
L394F:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1A             ; 26 for ??
        ;
        DW      L323C
        ;
        DW      L315E           ; read address of ?? CHANNEL block then PUSH it
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $08             ; 8 for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L31C1           ; set VIBRA sound port
        ;
        DW      L00BC           ; TONEB "pushWORD to System stack"
        DW      $FDCD           ; for "TONE B locatiom=n" in Static RAM
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0448           ; 1-B! do "Pop HL, SUBtract 1 from (HL)"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; END or loop to BEGIN if False
        DW      L03CD,L394F     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $2B             ; for TONMO = 43
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L050B           ; 35 "BYTE Pusher" for ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $2B             ; 43 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $90             ; 144 for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3293
        ;
        DW      L3236
        ;
        DW      L3223
        ;
        DW      L00B0           ; ... TerseRETurn

; MAGIC-S does ??
L3998:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L2FB4           ; do SETUP for BOTH Channels
        ;
        DW      L3911
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3918           ; point to ??
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; DROP-S does "SECOND CHECK FOR FREED HOSTAGES"
L39AF:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L2E14           ; do Word Pusher for $FE27 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L0513           ; 126 (hex $7E) "BYTE Pusher" for TONE A = 126
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $54             ; for TONE B = 84
        ;
        DW      L0515           ; 49 "BYTE Pusher" for TONE C = 49
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $88             ; for both VOLume A and VOLume B = 8
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $28             ; for VOLume C = 40
        ;
        DW      L31A2           ; set VOLC sound port
        ;
L39C9:  DW      L0501           ; 12 "BYTE Pusher" for ??
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L050B           ; 35 "BYTE Pusher" for ??
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0501           ; 12 "BYTE Pusher" for ??
        ;
        DW      L0509           ; 96 "BYTE Pusher" for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3293
        ;
        DW      L3236
        ;
        DW      L322C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3371           ; point to ??
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L39F1:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L2E14           ; do Word Pusher for $FE27 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
L39F8:  DW      L0513           ; 126 (hex $7E) "BYTE Pusher" for TONE A = 126
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $54             ; for TONE B = 84
        ;
        DW      L0515           ; 49 "BYTE Pusher" for TONE C = 49
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $88             ; for both VOLume A and VOLume B = 8
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $28             ; for VOLume C = 40
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3293
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $28             ; for TONMO = 40
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L050B           ; 35 "BYTE Pusher" for ??
        ;
        DW      L052F           ; -3 (hex $FFFD) "WORD Pusher"
        ;
        DW      L0501           ; 12 "BYTE Pusher" for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $28             ; 40 for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L3236
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L39C9           ; point to ??
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; ENTER-S does ??
L3A31:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L39F1
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L39F8           ; point to ??
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3A46:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E14           ; do Word Pusher for $FE27 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
L3A4D:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $18             ; for TONE A = 24
        ;
        DW      L0519           ; 48 "BYTE Pusher" for TONE B = 48
        ;
        DW      L0509           ; 96 "BYTE Pusher" for TONE C = 96
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for Noise VOLume = 8
        ;
        DW      L3173           ; set VOLN sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; for TONEMO = 32
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 for BYTEPL ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0529           ; -1 (hex $FFFF) "WORD Pusher"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L0501           ; 12 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF2
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $CC             ; 204 for both VOLume A and VOLume B = 12
        ;
        DW      L3182           ; set VOLAB sound port
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3C             ; for VOLume C = 60
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L3236
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3A91:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L2FB4           ; do SETUP for BOTH Channels
        ;
        DW      L3A46
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3A4D           ; point to ??
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3AA8:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L3A91
        ;
        DW      L32FC
        ;
        DW      L330F
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0300           ; 768 for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ; TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L330F
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3ABD:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; TONEC "pushWORD to System stack"
        DW      $FDCC           ; for "TONE C location" in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L2E14           ; do Word Pusher for $FE27 (in non-protected Static RAM)
        ;
        DW      L32CC
        ; BEGIN loop
L3ACA:  DW      L1A55           ; do Un-RANGED for Pseudo-RANDOM Number 0 - 255
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $7F1F           ; 32543 for ?? in Screen RAM
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L02D4           ; SWAB do "SWAp Bytes in Top word of System stack"
        ;
        DW      L1A55           ; do Un-RANGED for Pseudo-RANDOM Number 0 - 255
        ;
        DW      L31FD           ; set ALL 3 TONES to (SP), (SP+2), (SP+4)
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L3164           ; set TONMO sound port
        ;
        DW      L00BC           ; VIBRA "pushWORD to System stack"
        DW      $FDCB           ; for "VIBRAto location" in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L3206
        ;
        DW      L0217           ; -DUP do "DUPlicate Top of System stack IF Not Zero"
        ; _IF False to ELSE #1
        DW      L03CD,L3B12     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0155           ; 1- do "DECrement Top of System stack"
        ; __IF False to ELSE #2
        DW      L03CD,L3B03     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0501           ; 12 "BYTE Pusher" for ??
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L0511           ; 16 "BYTE Pusher" for Noise VOLume = 16
        ;
        DW      L0519           ; 48 "BYTE Pusher" for VOLume C = 0 and NM = 3
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $BB             ; 187 for both VOLume A and VOLume B = 11
        ; __Jump to THEN #2
        DW      L03C5,L3B0E     ; TerseJUMP to "SET all 3 Byte VOLumes, then ..."
        ; __ELSE #2
L3B03:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $18             ; 24 for ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for Noise VOLume = 4
        ;
        DW      L0519           ; 56 "BYTE Pusher" for VOLume C = 8 and NM = 3
        ;
        DW      L0503           ; 13 "BYTE Pusher" for VOLume A = 13 and VOLume B = 0
        ; __THEN #2 and Jump to THEN #1
L3B0E:  DW      L03C5,L3B1F     ; TerseJUMP to "SET all 3 Byte VOLumes, then ..."
        ; _ELSE #1
L3B12:  DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $28             ; for Noise VOLume = 40 ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3F             ; 63 for VOLume C = 15 and NM = 3 ??
        ;
        DW      L051D           ; 255 "BYTE Pusher" for both VOLA and VOLB = 15
        ; _THEN #1 also entry point do "SET VOLumes for Noise, C and NM, and A and B combined, then ..."
L3B1F:  DW      L3182           ; set VOLAB sound port
        ;
        DW      L31A2           ; set VOLC sound port
        ;
        DW      L3173           ; set VOLN sound port
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0529           ; -1 (hex $FFFF) "WORD Pusher"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L315E           ; read address of ?? CHANNEL block then PUSH it
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $06             ; 6 for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF2
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L050F           ; 33 "BYTE Pusher" for ??
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L02F4           ; do "Pop HL, (HL*2 + SP - 2)->DE, Push DE to System stack"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $95             ; 149 for ??
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3280           ; ?? do "POP a Sound Block from VOLC down to TONMO"
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L2E11           ; VOLC do Word Pusher for $FFF9 (in non-protected Static RAM)
        ;
        DW      L3293
        ;
        DW      L3236
        ;
        DW      L00BC           ; TONEC "pushWORD to System stack"
        DW      $FDCC           ; for "TONE C location" in Static RAM
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0448           ; 1-B! do "Pop HL, SUBtract 1 from (HL)"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; END or loop to BEGIN if False
        DW      L03CD,L3ACA     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L2FB4           ; do SETUP for BOTH Channels
        ;
        DW      L3223
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3B71:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L016B           ; 2* do "Double Top of System stack"
        ;
        DW      L3ABD
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L323C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3ACA           ; point to ??
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; SUCK-S does ??
L3B88:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L2FB4           ; do SETUP for BOTH Channels
        ;
        DW      L00BC           ; VIBRA "pushWORD to System stack"
        DW      $FDCB           ; for "VIBRAto location" in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L3B71
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3B97:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L2FB4           ; do SETUP for BOTH Channels
        ;
        DW      L00BC           ; VIBRA "pushWORD to System stack"
        DW      $FDCB           ; for "VIBRAto location" in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L3ABD
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L2E17           ; do Word Pusher for $FE01 (in non-protected Static RAM)
        ;
        DW      L32CC
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3ACA           ; point to ??
        ;
        DW      L324D           ; FAKE a TerseJUMP to (TOP of System Stack)
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3BB2:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L3B97
        ;
        DW      L32FC
        ;
        DW      L330F
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3BBB:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; VIBRA "pushWORD to System stack"
        DW      $FDCB           ; for "VIBRAto location" in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L3B71
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
L3BC6:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; VIBRA "pushWORD to System stack"
        DW      $FDCB           ; for "VIBRAto location" in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L3B71
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "INPut L,(SW0) and Ones ComPLment L, then mask it with (SP)"
L3BD3:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0511           ; 16 "BYTE Pusher" for =&(16) aka Game SW0 read
        ;
        DW      L02E3           ; INP do "Pop BC, INPort L,(C) byte, Push 0,L word"
        ;
        DW      L051D           ; 255 (or -1) "BYTE Pusher" for $FF do ...
        ;
        DW      L0236           ; XOR do "word (SP) XOR (SP+2)" ... Ones ComPLement
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)" mask switch(es) !!
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "SPECIAL read of INput (SP+2),(SP)" always SW5 INPUT port 21 !!
; NOTE: x bit 0 set for Incandescent Lamp turned ON !!
; bits 1 thru 3 = 0 for COIN Counter #1 bulb
;               = 1 for COIN Counter #2 bulb
;               = 2 for COIN Counter #3 (not used ??)
; (Color Sparkles = 3, = 4 and = 5 are NOT used !!)
;               = 6 for LED Status #1
;               = 7 for LED Status #2
L3BE0:  EXX
        POP     BC
        POP     DE
        LD      B,E             ; set up "0000nnnxB" (see NOTE above !!)
        IN      B,(C)           ; always ignore $FF returned !!
        EXX
        JP      (IY)            ; indexed RETurn

; ?? does "save 1 or 2 as ??, VGER-OUT, turn OFF LEDs #1 and #2, then SHUTUP"
L3BE9:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FE           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ;
        DW      L221F           ; VGER-OUT do ??
        ;
        DW      L0501           ; 12 "BYTE Pusher" decodes as 6 for LED #1 OFF
        ;
        DW      L00C5           ; SW5 "pushBYTE to System stack"
        DB      $15             ; for INPUT port 21 !!
        ;
        DW      L3BE0           ; ?? do "SPECIAL read INput (SP+2),(SP) to set Lamps" !!
        ;
        DW      L0505           ; 14 "BYTE Pusher" decodes as 7 for LED #2 OFF
        ;
        DW      L00C5           ; SW5 "pushBYTE to System stack"
        DB      $15             ; for INPUT port 21 !!
        ;
        DW      L3BE0           ; ?? do "SPECIAL read INput (SP+2),(SP) to set Lamps" !!
        ;
        DW      L32F3           ; SHUTUP does "SHUT UP all sounds"
        ;
        DW      L00B0           ; ... TerseRETurn

; TRY-PA does ??
L3C04:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; VSEN "pushWORD to System stack"
        DW      $FDB1           ; for Word ?? for ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1A             ; 26 for ??
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDB0           ; for Word ?? for ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L0501           ; 12 "BYTE Pusher" decodes as 6 for LED #1 OFF
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDAF           ; for ?? Word "COIN Counter ?? lamp ??" in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; BEGIN loop
L3C20:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3F5           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; _IF False #1 to THEN #1
        DW      L03CD,L3C46     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEEB           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; __IF False #2 skip to THEN #2
        DW      L03CD,L3C3C     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3F5           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L07CE           ; 1-WPB! do "DECREMENT WRITE-protectedBYTE in (SP)"
        ; __THEN #2
L3C3C:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE3A           ; for Word ?? in Static RAM
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      L32F3           ; SHUTUP does "SHUT UP all sounds"
        ;
        DW      L3BB2
        ; _THEN #1
L3C46:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FA           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L01D2           ; do "TEST (SP) Less or Equal (SP+2) return in (SP)"
        ; _IF False #3 to THEN #3
        DW      L03CD,L3CCF     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDB0           ; for Word ?? for ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; __IF False #4 to THEN #4
        DW      L03CD,L3CA1     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDAF           ; for ?? Word "COIN Counter ?? lamp ??" in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack" to toggle Lamp OFF or ON ??
        ;
        DW      L0236           ; XOR do "word (SP) XOR (SP+2)" for COIN Counter lamp !!
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDAF           ; for ?? Word "COIN Counter ?? lamp ??" in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00C5           ; SW5 "pushBYTE to System stack"
        DB      $15             ; for INPUT port 21 !!
        ;
        DW      L3BE0           ; ?? do "SPECIAL read INput (SP+2),(SP) to set Lamps" !!
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $60             ; 96 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDB0           ; for Word ?? for ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FA           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L01D2           ; do "TEST (SP) Less or Equal (SP+2) return in (SP)"
        ; ___IF False #5 to THEN #5
        DW      L03CD,L3C9D     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDAF           ; for ?? Word "COIN Counter ?? lamp ??" in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for set COIN Counter lamp #1 !!
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ;
        DW      L00C5           ; SW5 "pushBYTE to System stack"
        DB      $15             ; for INPUT port 21 !!
        ;
        DW      L3BE0           ; ?? do "SPECIAL read INput (SP+2),(SP) to set Lamps" !!
        ; ___THEN #5 do Jump to THEN #3 ??
L3C9D:  DW      L03C5,L3CCF     ; TerseJUMP to ??
        ; __THEN #4
L3CA1:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L3BD3           ; ?? does "INPut L,(SW0) and Ones ComPLment, then mask with (SP)"
        ; __IF False #6 skip to THEN #6
        DW      L03CD,L3CAE     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L3BE9           ; ?? do "save 1 as ??, VGER-OUT, turn OFF both LEDs, then SHUTUP"
        ; __THEN #6
L3CAE:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FA           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L01D2           ; do "TEST (SP) Less or Equal (SP+2) return in (SP)"
        ; __IF False #7 to THEN #7
        DW      L03CD,L3CC9     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $40             ; 64 for ??
        ;
        DW      L3BD3           ; ?? does "INPut L,(SW0) and Ones ComPLment, then mask with (SP)"
        ; ___IF False #8 skip to THEN #8
        DW      L03CD,L3CC9     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L3BE9           ; ?? does "save 2 as ??, VGER-OUT, turn OFF both LEDs, then SHUTUP"
        ; __THEN #7 and THEN #8 combined
L3CC9:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FDB0           ; for Word ?? for ?? in Static RAM
        ;
        DW      L0448           ; 1-B! do "Pop HL, SUBtract 1 from (HL)"
        ; _THEN #3 and THEN #5 together
L3CCF:  DW      L1660           ; SYNC do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; END or loop to BEGIN if False
        DW      L03CD,L3C20     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn

; end of ??
;**********************************************************
;
; more Patterns !! (still 1 = YELLOW; 2 = RED; 3 = DARK Blue)
;
;**********************************************************
; 4-color TEETH of DEATH #1 (of 4) pattern
L3CD9:  DB      $07             ; 7 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$AA,$A0,$00 ; . . . . 2 2 2 2 2 2 . . . . . .
        DB      $02,$FF,$F8,$00 ; . . . 2 3 3 3 3 3 3 2 . . . . .
        DB      $0A,$DF,$7A,$00 ; . . 2 2 3 1 3 3 1 3 2 2 . . . .
        DB      $29,$FF,$F6,$80 ; . 2 3 1 3 3 3 3 3 3 1 2 2 . . .
        DB      $AD,$FF,$F7,$A0 ; 2 2 3 1 3 3 3 3 3 3 1 3 2 2 . .
        DB      $9F,$FF,$FF,$60 ; 2 1 3 3 3 3 3 3 3 3 3 3 1 2 . .
        DB      $BF,$FF,$FF,$E0 ; 2 3 3 3 3 3 3(3)3 3 3 3 3 2 . .
        DB      $BE,$AA,$AB,$E0 ; 2 3 3 2 2 2 2 2 2 2 2 3 3 2 . .
        DB      $A7,$AA,$AD,$A0 ; 2 2 1 3 2 2 2 2 2 2 3 1 2 2 . .
        DB      $2F,$EA,$BF,$80 ; . 2 3 3 3 2 2 2 2 3 3 3 2 . . .
        DB      $27,$FA,$FD,$80 ; . 2 1 3 3 3 2 2 3 3 3 1 2 . . .
        DB      $0B,$7F,$DE,$00 ; . . 2 3 1 3 3 3 3 1 3 2 . . . .
        DB      $02,$75,$D8,$00 ; . . . 2 1 3 1 1 3 1 2 . . . . .
        DB      $00,$AA,$A0,$00 ; . . . . 2 2 2 2 2 2 . . . . . .

; TEETH of DEATH #2
L3D15:  DB      $07             ; 7 = X offset
        DB      $04             ; 4 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ;
        DB      $02,$AA,$A8,$00 ; . . . 2 2 2 2 2 2 2 2 . . . . .
        DB      $0A,$FF,$FA,$00 ; . . 2 2 3 3 3 3 3 3 2 2 . . . .
        DB      $2D,$DF,$77,$80 ; . 2 3 1 3 1 3 3 1 3 1 3 2 . . .
        DB      $9D,$FF,$F7,$60 ; 2 1 3 1 3 3 3 3 3 3 1 3 1 2 . .
        DB      $BF,$FF,$FF,$E0 ; 2 3 3 3 3 3 3(3)3 3 3 3 3 2 . .
        DB      $BE,$AA,$AB,$E0 ; 2 3 3 2 2 2 2 2 2 2 2 3 3 2 . .
        DB      $A7,$AA,$AD,$A0 ; 2 2 1 3 2 2 2 2 2 2 3 1 2 2 . .
        DB      $2D,$FA,$F7,$80 ; . 2 3 1 3 3 2 2 3 3 1 3 2 . . .
        DB      $09,$DA,$76,$00 ; . . 2 1 3 1 2 2 1 3 1 2 . . . .
        DB      $02,$AA,$A8,$00 ; . . . 2 2 2 2 2 2 2 2 . . . . .

; TEETH of DEATH #3
L3D41:  DB      $07             ; 7 = X offset
        DB      $02             ; 2 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $06             ; 6 = Height in rows
        ;
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .
        DB      $29,$FF,$F6,$80 ; . 2 2 1 3 3 3 3 3 3 1 2 2 . . .
        DB      $BD,$DF,$77,$E0 ; 2 3 3 1 3 1 3(3)1 3 1 3 3 2 . .
        DB      $B7,$FF,$FD,$E0 ; 2 3 1 3 3 3 3 3 3 3 3 1 3 2 . .
        DB      $27,$9A,$6D,$80 ; . 2 1 3 2 1 2 2 1 2 3 1 2 . . .
        DB      $2A,$AA,$AA,$80 ; . 2 2 2 2 2 2 2 2 2 2 2 2 . . .

; TEETH of DEATH #4
L3D5D:  DB      $07             ; 7 = X offset
        DB      $01             ; 1 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $04             ; 4 = Height in rows
        ;
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .
        DB      $AA,$6A,$9A,$A0 ; 2 2 2 2 1 2 2(2)2 1 2 2 2 2 . .
        DB      $AB,$7F,$DE,$A0 ; 2 2 2 3 1 3 3 3 3 1 3 2 2 2 . .
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .

; animation table for 4 TEETH of DEATH patterns above
L3D71:  DB      $06,$00,$81     ; 6 BOUNCING ?? entries
        ;
L3D74:  DB      $02,$D9,$3C     ; #1 (not duplicated)
        DB      $02,$15,$3D     ; #2
        DB      $02,$41,$3D     ; #3
        DB      $06,$5D,$3D     ; #4 (not duplicated)
        DB      $02,$41,$3D     ; #3 again
        DB      $02,$15,$3D     ; #2 again
        DB      $00,$74,$3D     ; and 1 to loop on

; 4-color TEETH 2 DIE #1 (of 4) pattern
L3D89:  DB      $07             ; 7 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$AA,$A0,$00 ; . . . . 2 2 2 2 2 2 . . . . . .
        DB      $02,$DF,$78,$00 ; . . . 2 3 1 3 3 1 3 2 . . . . .
        DB      $0A,$FF,$FA,$00 ; . . 2 2 3 3 3 3 3 3 2 2 . . . .
        DB      $29,$FF,$F6,$80 ; . 2 2 1 3 3 3 3 3 3 1 2 2 . . .
        DB      $AF,$FF,$FF,$A0 ; 2 2 3 3 3 3 3 3 3 3 3 3 2 2 . .
        DB      $9F,$FF,$FF,$60 ; 2 1 3 3 3 3 3 3 3 3 3 3 1 2 . .
        DB      $BF,$FF,$FF,$E0 ; 2 3 3 3 3 3 3(3)3 3 3 3 3 2 . .
        DB      $BE,$AA,$AB,$E0 ; 2 3 3 2 2 2 2 2 2 2 2 3 3 2 . .
        DB      $A7,$AA,$AD,$A0 ; 2 2 1 3 2 2 2 2 2 2 3 1 2 2 . .
        DB      $2F,$EA,$BF,$80 ; . 2 3 3 3 2 2 2 2 3 3 3 2 . . .
        DB      $27,$FA,$FD,$80 ; . 2 1 3 3 3 2 2 3 3 3 1 2 . . .
        DB      $0B,$FF,$FE,$00 ; . . 2 3 3 3 3 3 3 3 3 2 . . . .
        DB      $02,$75,$D8,$00 ; . . . 2 1 3 1 1 3 1 2 . . . . .
        DB      $00,$AA,$A0,$00 ; . . . . 2 2 2 2 2 2 . . . . . .

; TEETH 2 DIE #2
L3DC5:  DB      $07             ; 7 = X offset
        DB      $04             ; 4 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ;
        DB      $02,$AA,$A8,$00 ; . . . 2 2 2 2 2 2 2 2 . . . . .
        DB      $0A,$DF,$7A,$00 ; . . 2 2 3 1 3 3 1 3 2 2 . . . .
        DB      $2D,$FF,$F7,$80 ; . 2 3 1 3 3 3 3 3 3 1 3 2 . . .
        DB      $9F,$FF,$FF,$60 ; 2 1 3 3 3 3 3 3 3 3 3 3 1 2 . .
        DB      $BF,$FF,$FF,$E0 ; 2 3 3 3 3 3 3(3)3 3 3 3 3 2 . .
        DB      $BE,$AA,$AB,$E0 ; 2 3 3 2 2 2 2 2 2 2 2 3 3 2 . .
        DB      $A7,$AA,$AD,$A0 ; 2 2 1 3 2 2 2 2 2 2 3 1 2 2 . .
        DB      $2F,$FA,$FF,$80 ; . 2 3 3 3 3 2 2 3 3 3 3 2 . . .
        DB      $09,$DA,$76,$00 ; . . 2 1 3 1 2 2 1 3 1 2 . . . .
        DB      $02,$AA,$A8,$00 ; . . . 2 2 2 2 2 2 2 2 . . . . .

; TEETH 2 DIE #3
L3DF1:  DB      $07             ; 7 = X offset
        DB      $02             ; 2 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $06             ; 6 = Height in rows
        ;
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .
        DB      $29,$DF,$76,$80 ; . 2 2 1 3 1 3 3 1 3 1 2 2 . . .
        DB      $AF,$FF,$FF,$A0 ; 2 2 3 3 3 3 3(3)3 3 3 3 2 2 . .
        DB      $AE,$AA,$AB,$A0 ; 2 2 3 2 2 2 2 2 2 2 2 3 2 2 . .
        DB      $2B,$9A,$6E,$80 ; . 2 2 3 2 1 2 2 1 2 3 2 2 . . .
        DB      $2A,$AA,$AA,$80 ; . 2 2 2 2 2 2 2 2 2 2 2 2 . . .

; ?TEETH 2 DIE #4
L3E0D:  DB      $07             ; 7 = X offset
        DB      $01             ; 1 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $04             ; 4 = Height in rows
        ;
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .
        DB      $AA,$AA,$AA,$A0 ; 2 2 2 2 2 2 2(2)2 2 2 2 2 2 . .
        DB      $AB,$DF,$7E,$A0 ; 2 2 2 3 3 1 3 3 1 3 3 2 2 2 . .
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .

; animation table for 4 TEETH 2 DIE patterns above
L3E21:  DB      $06,$00,$81     ; 6 more entries
        ;
L3E24:  DB      $02,$89,$3D     ; #1 (not duplicated)
        DB      $02,$C5,$3D     ; #2
        DB      $02,$F1,$3D     ; #3
        DB      $06,$0D,$3E     ; #4 (not duplicated)
        DB      $02,$F1,$3D     ; #3 again
        DB      $02,$C5,$3D     ; #2 again
        DB      $00,$24,$3E     ; and 1 more to loop on

; 4-cokor TEETH ?? DYING #1 (of 4) patterns
L3E39:  DB      $07             ; 7 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$AA,$A0,$00 ; . . . . 2 2 2 2 2 2 . . . . . .
        DB      $02,$9F,$68,$00 ; . . . 2 2 1 3 3 1 2 2 . . . . .
        DB      $0A,$FF,$FA,$00 ; . . 2 2 3 3 3 3 3 3 2 2 . . . .
        DB      $29,$FF,$F6,$80 ; . 2 2 1 3 3 3 3 3 3 1 2 2 . . .
        DB      $2F,$FF,$FF,$80 ; . 2 3 3 3 3 3 3 3 3 3 3 2 . . .
        DB      $9F,$FF,$FF,$60 ; 2 1 3 3 3 3 3 3 3 3 3 3 1 2 . .
        DB      $BF,$FF,$FF,$E0 ; 2 3 3 3 3 3 3(3)3 3 3 3 3 2 . .
        DB      $BE,$AE,$AB,$E0 ; 2 3 3 2 2 2 3 2 2 2 2 3 3 2 . .
        DB      $A7,$AB,$AD,$A0 ; 2 2 1 3 2 2 2 3 2 2 3 1 2 2 . .
        DB      $2F,$AB,$AF,$80 ; . 2 3 3 2 2 2 3 2 2 3 3 2 . . .
        DB      $27,$EE,$BD,$80 ; . 2 1 3 3 2 3 2 2 3 3 1 2 . . .
        DB      $0A,$FA,$FA,$00 ; . . 2 2 3 3 2 2 3 3 2 2 . . . .
        DB      $02,$65,$98,$00 ; . . . 2 1 2 1 1 2 1 2 . . . . .
        DB      $00,$AA,$A0,$00 ; . . . . 2 2 2 2 2 2 . . . . . .

; TEETH ?? DYING #2
L3E75:  DB      $07             ; 7 = X offset
        DB      $04             ; 4 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ;
        DB      $02,$AA,$A8,$00 ; . . . 2 2 2 2 2 2 2 2 . . . . .
        DB      $0A,$DF,$7A,$00 ; . . 2 2 3 1 3 3 1 3 2 2 . . . .
        DB      $29,$FF,$F6,$80 ; . 2 2 1 3 3 3 3 3 3 1 2 2 . . .
        DB      $AF,$FF,$FF,$A0 ; 2 2 3 3 3 3 3 3 3 3 3 3 2 2 . .
        DB      $BF,$FF,$FF,$E0 ; 2 3 3 3 3 3 3(3)3 3 3 3 3 2 . .
        DB      $AE,$AE,$AB,$A0 ; 2 2 3 2 2 2 3 2 2 2 2 3 2 2 . .
        DB      $A7,$AB,$AD,$A0 ; 2 2 1 3 2 2 2 3 2 2 3 1 2 2 . .
        DB      $2B,$FA,$FE,$80 ; . 2 2 3 3 3 2 2 3 3 3 2 2 . . .
        DB      $09,$DA,$76,$00 ; . . 2 1 3 1 2 2 1 3 1 2 . . . .
        DB      $02,$AA,$A8,$00 ; . . . 2 2 2 2 2 2 2 2 . . . . .

; TEETH ?? DYING #3
L3EA1:  DB      $07             ; 7 = X offset
        DB      $03             ; 3 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $08             ; 8 = Height in rows
        ;
        DB      $02,$AA,$A8,$00 ; . . . 2 2 2 2 2 2 2 2 . . . . .
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .
        DB      $2A,$DF,$7A,$80 ; . 2 2 2 3 1 3 3 1 3 2 2 2 . . .
        DB      $AF,$FF,$FF,$A0 ; 2 2 3 3 3 3 3(3)3 3 3 3 2 2 . .
        DB      $AE,$AE,$AB,$A0 ; 2 2 3 2 2 2 3 2 2 2 2 3 2 2 . .
        DB      $2B,$9A,$6E,$80 ; . 2 2 3 2 1 2 2 1 2 3 2 2 . . .
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .
        DB      $00,$AA,$A0,$00 ; . . . . 2 2 2 2 2 2 . . . . . .

; TEETH ?? DYING #4
L3EC5:  DB      $07             ; 7 = X offset
        DB      $02             ; 2 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $06             ; 6 = Height in rows
        ;
        DB      $00,$2A,$80,$00 ; . . . . . 2 2 2 2 . . . . . . .
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .
        DB      $AA,$AF,$AA,$A0 ; 2 2 2 2 2 2 3(3)2 2 2 2 2 2 . .
        DB      $AB,$DF,$7E,$A0 ; 2 2 2 3 3 1 3 3 1 3 3 2 2 2 . .
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .
        DB      $00,$AA,$A0,$00 ; . . . . 2 2 2 2 2 2 . . . . . .

; animation table for 4 TEETH ?? DYING patterns above
L3EE1:  DB      $06,$00,$81     ; 6 more entries more
        ;
L3EE4:  DB      $02,$39,$3E     ; #1 (not duplicated)
        DB      $02,$75,$3E     ; #2
        DB      $02,$A1,$3E     ; #3
        DB      $06,$C5,$3E     ; #4 (not duplicated)
        DB      $02,$A1,$3E     ; #3 again
        DB      $02,$75,$3E     ; #2 again
        DB      $00,$E4,$3E     ; and 1 more to loop on more

; 4-color TEETH HOLLOW #1 (of 4) patterns
L3EF9:  DB      $06             ; 6 = X offset
        DB      $05             ; 5 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $0C             ; 12 = Height in rows
        ;
        DB      $00,$82,$00     ; . . . . 2 . . 2 . . . .
        DB      $00,$00,$00     ; . . . . . . . . . . . .
        DB      $08,$00,$20     ; . . 2 . . . . . . 2 . .
        DB      $00,$00,$00     ; . . . . . . . . . . . .
        DB      $80,$00,$02     ; 2 . . . . . . . . . . 2
        DB      $00,$00,$00     ; . . . . . ._._. . . . .
        DB      $00,$00,$00     ; . . . . . . . . . . . .
        DB      $20,$00,$08     ; . 2 . . . . . . . . 2 .
        DB      $00,$00,$00     ; . . . . . . . . . . . .
        DB      $20,$00,$08     ; . 2 . . . . . . . . 2 .
        DB      $00,$00,$00     ; . . . . . . . . . . . .
        DB      $02,$28,$80     ; . . . 2 . 2 2 . 2 . . .

; TEETH HOLLOW #2
L3F21:  DB      $06             ; 6 = X offset
        DB      $03             ; 3 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $08             ; 8 = Height in rows
        ;
        DB      $00,$82,$00     ; . . . . 2 . . 2 . . . .
        DB      $08,$00,$20     ; . . 2 . . . . . . 2 . .
        DB      $80,$00,$02     ; 2 . . . . . . . . . . 2
        DB      $00,$00,$00     ; . . . . . ._._. . . . .
        DB      $00,$00,$00     ; . . . . . . . . . . . .
        DB      $20,$00,$08     ; . 2 . . . . . . . . 2 .
        DB      $00,$00,$00     ; . . . . . . . . . . . .
        DB      $08,$82,$20     ; . . 2 . 2 . . 2 . 2 . .

; TEETH HOLLOW #3
L3F3D:  DB      $04             ; 4 = X offset
        DB      $01             ; 1 = Y offset
        DB      $02             ; 2 = Width in bytes
        DB      $04             ; 4 = Height in rows
        ;
        DB      $88,$22         ; 2 . 2 . . 2 . 2
        DB      $00,$00         ; . . . ._._. . .
        DB      $00,$00         ; . . . . . . . .
        DB      $08,$20         ; . . 2 . . 2 . .

; TEETH HOLLOW #4
L3F49:  DB      $02             ; 2 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $02             ; 2 = Height in rows
        ;
        DB      $00             ; . ._._.
        DB      $82             ; 2 . . 2

; animation table for 4 TEETH HOLLOW patterns above
L3F4F:  DB      $06,$00,$81     ; 6 more HOLLOW entries
        ;
L3F52:  DB      $02,$F9,$3E     ; #1 (not duplicated)
        DB      $02,$21,$3F     ; #2
        DB      $02,$3D,$3F     ; #3
        DB      $06,$49,$3F     ; #4 (not duplicated)
        DB      $02,$3D,$3F     ; #3 again
        DB      $02,$21,$3F     ; #2 again
        DB      $00,$52,$3F     ; and 1 more HOLLOW to loop on

; ?? MAZE Data somehow !!
L3F67:  DB      $03,$23,$62,$83,$02,$82 ; ?? words ??
        DB      $22,$42,$72,$32,$00,$00,$00 ; no !!
        DB      $00,$00,$00,$00,$00,$01,$32,$32
        DB      $33,$00,$00,$12,$33,$13,$30,$00
        DB      $01,$33,$12,$33,$00,$00,$11,$27
        DB      $52,$20,$00,$00,$2A,$AA,$00,$00
        DB      $23,$72,$84,$02 ; wrong !!
        DB      $52,$22,$82,$21,$53,$00,$00,$00
        DB      $00,$00,$00,$00,$00,$01,$32,$33
        DB      $13,$00,$00,$13,$33,$33,$30,$00
        DB      $00,$31,$03,$21,$00,$00,$17,$15
        DB      $27,$30,$00,$00,$AA,$AA,$AA,$00
        DB      $22,$34,$63,$02,$51,$21,$51,$81
        DB      $52,$00,$00,$00,$00,$00,$01,$30
        DB      $00,$01,$33,$37,$F2,$00,$05,$AF
        DB      $30,$77,$00,$00,$0B,$A1,$72,$B3
        DB      $00,$00,$03,$35,$33,$20,$00,$00
        DB      $02,$20,$20,$00,$FF,$FF,$FF,$FF
        DB      $DA,$FF,$FF,$FF,$FF,$FF
; got some Unused TEST code here ?? also NEWVECT JAYVECT 1+ U! (not used ??)
        DB      $23,$AB         ; ' FLSHT 3FF6 U! ( LINK TO FLASHER )
        DB      $92,$8C         ; ' PATTY 3FF8 U! (all TEST code ??)
        DB      $1F,$BC         ; ' ROTO 3FFA U! (not TEST Pattern ??)
        DB      $08,$C9         ; BN^ constant $3FFC (used twice ??)
        DB      $D3,$D2         ; CT^ constant $3FFE (used once ??)
; end of got some code at $3FF6 ?? (must have changed in the mean time !!)

; L4000: start of Screen RAM



; --------------------------------------------------------------------------------



; Disassembly of the file "Robby Roto 8000.bin"
;
; CPU Type: Z80 Created with dZ80 2.0 by R.C.D.
;
; on Saturday, 24 of August 2013 at 12:58 AM
; Revisited on Saturday, 9 of June 2018 by RCD
;                                                         #   #     #     #
; Restarted on or about 10/13/2018 by Richard C Degler    #   #     #     #
; when TERSE Forth source code found in ROTO.4th.txt !!   # # #   # # #   # # #
; Added "CVGLIB.H" and moved Game Play down below END         #     #     #   #
;                                                             #     #     #   #

        ORG     $8000

; Color TROLL pattern #1 (of 2) with 4 byte headers
; note: hot-spot(s) marked by (2)
L8000:  DB      $08             ; 8 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$0A,$80,$00 ; . . . . . . 2 2 2 . . . . . . .
        DB      $00,$AA,$A8,$00 ; . . . . 2 2 2 2 2 2 2 . . . . .
        DB      $03,$FE,$FF,$00 ; . . . 3 3 3 3 2 3 3 3 3 . . . .
        DB      $0A,$EE,$EE,$80 ; . . 2 2 3 2 3 2 3 2 3 2 2 . . .
        DB      $02,$AA,$AA,$00 ; . . . 2 2 2 2 2 2 2 2 2 . . . .
        DB      $00,$AF,$E8,$00 ; . . . . 2 2 3 3 3 2 2 . . . . .
        DB      $00,$0B,$80,$00 ; . . . . . . 2 3(2). . . . . . .
        DB      $02,$A9,$AA,$00 ; . . . 2 2 2 2 1 2 2 2 2 . . . .
        DB      $28,$07,$42,$80 ; . 2 2 . . . 1 3 1 . . 2 2 . . .
        DB      $88,$A9,$A2,$20 ; 2 . 2 . 2 2 2 1 2 2 . 2 . 2 . .
        DB      $00,$E0,$A0,$00 ; . . . . 3 2 . . 2 2 . . . . . .
        DB      $0A,$A0,$28,$00 ; . . 2 2 2 2 . . . 2 2 . . . . .
        DB      $00,$00,$2C,$00 ; . . . . . . . . . 2 3 . . . . .
        DB      $00,$00,$2A,$80 ; . . . . . . . . . 2 2 2 2 . . .

; Color TROLL pattern #2
L803C:  DB      $07             ; 7 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$2A,$00,$00 ; . . . . . 2 2 2 . . . . . . . .
        DB      $02,$AA,$A0,$00 ; . . . 2 2 2 2 2 2 2 . . . . . .
        DB      $0F,$FB,$FC,$00 ; . . 3 3 3 3 2 3 3 3 3 . . . . .
        DB      $2B,$7B,$7A,$00 ; . 2 2 3 1 3 2 3 1 3 2 2 . . . .
        DB      $0A,$AA,$A8,$00 ; . . 2 2 2 2 2 2 2 2 2 . . . . .
        DB      $02,$BF,$A0,$00 ; . . . 2 2 3 3 3 2 2 . . . . . .
        DB      $00,$2E,$00,$00 ; . . . . . 2 3(2). . . . . . . .
        DB      $0A,$A6,$A8,$00 ; . . 2 2 2 2 1 2 2 2 2 . . . . .
        DB      $A0,$15,$02,$80 ; 2 2 . . . 1 1 1 . . . 2 2 . . .
        DB      $88,$A6,$88,$80 ; 2 . 2 . 2 2 1 2 2 . 2 . 2 . . .
        DB      $00,$A2,$C0,$00 ; . . . . 2 2 . 2 3 . . . . . . .
        DB      $02,$82,$A8,$00 ; . . . 2 2 . . 2 2 2 2 . . . . .
        DB      $03,$80,$00,$00 ; . . . 3 2 . . . . . . . . . . .
        DB      $2A,$80,$00,$00 ; . 2 2 2 2 . . . . . . . . . . .

; animation table for 2 TROLL patterns above
L8078:  DB      $02,$00,$81     ; 2 slow entries; byte 0; byte -2 for ??
        ;
L807B:  DB      $06,$00,$80     ; #1 duration = 6s
        DB      $06,$3C,$80     ; #2
        DB      $00,$7B,$80     ; and s-l-o-w loop

; animation table for SAME patterns above
L8084:  DB      $02,$00,$81     ; 2 fast TROLL entries ??
        ;
L8087:  DB      $03,$00,$80     ; #1 durations = 3
        DB      $03,$3C,$80     ; #2
        DB      $00,$87,$80     ; and fast(er) TROLL loop

; end of TROLL patterns

; { BLOCK 0212 }
; ( GAME PARAMETERS !!!! )
; XC? NOT IFTRUE ." CROSS COMPILER TURNED OFF!!!!!" IFEND
; ASM .REL ( START SAVING BYTES )
; XC? C= SCON ( SCORING ON FLAG )
; SCON NOT IFTRUE ." SCORING IS OFF DUMMY" IFEND
; 4 C= PRTBM ( PLAYER-REVEALER-HOSTAGE MAX TIME BASE )
; 8 C= INILT
; 8 C= JMLZ ( LEAP ZONE ) 256 C= PSLW
; 16 C= H-P-D ( HOSTAGE TO PLAYER DISTANCE )
; 12 C= H-H-D ( HOSTAGE TO HOSTAGE DISTANCE )
; 9 C= M-L-S ( MINIMUM LEADER SPACING )
; 127 C= MAXASSM ( MAX ASSIMILATION DISTANCE )
; -->
;
; ?? another COPY BYTES (NOT used ??)
L8090:  EXX
        POP     DE
        POP     BC
        POP     HL
        LDIR
        EXX
        JP      (IY)            ; indexed RETurn

; TERSE Forth ROLL does "ROTate in REVERSE" (anti-ROTate ??)
L8099:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L02ED           ; ROT do "Pop DE, Pop HL, EX (SP),HL then Push DE, Push (Old SP) to New System stack"
        ;
        DW      L02ED           ; ROT do "Pop DE, Pop HL, EX (SP),HL then Push DE, Push (Old SP) to New System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; ??
L80A0:  LD      A,R
        LD      L,A
        LD      H,$00
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; ?? not used ??
L80A6:  PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        SET     CMDIR,(IY+$24) ; set CMDIR bit 0 of VLOGICSTAT offset 36
        POP     IY
        JP      (IY)            ; indexed RETurn

; ?? (only fron ZGO, ?? and IGO !!)
L80B6:  LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        RES     5,(IY+$10)      ; TBNOVECT bit 5 of TVMROPT offset 16
        LD      (IY+$07),H      ; TVMRH offset 7
        LD      (IY+$06),L      ; TVMRL offset 6
        POP     HL
        LD      (IY+$09),H      ; TSURH offset 9
        LD      (IY+$08),L      ; TSUR(L) offset 8
        LD      (IY+$12),$00    ; TCHGSTAT offset 18
        LD      (IY+$13),$00    ; TCHGSTAT2 offset 19
        LD      (IY+$02),C      ; TRC offset 2 (?? or TOPAPCL offset 2 ??)
        LD      (IY+$03),B      ; TD offset 3 (?? or TOPAPCH offset 3 ??)
        AND     A
        JR      Z,L80E6                 ; (+$0a)
        LD      (IY+$0C),$01    ; TSCALE offset 12
        SET     2,(IY+$04)      ; TBMISSLE bit 2 of TSTAT offset 4
        JR      L80FB                   ; (+$15) to JumP to restore

; ??
L80E6:  CP      (IY+$0C)        ; TSCALE offset 12
        JR      NZ,L80EF                ; (+$04)
        LD      (IY+$0C),$01    ; TSCALE offset 12
L80EF:  CP      (IY+$0D)        ; TTBMAX offset 13
        JR      NZ,L80F8                ; (+$04)
        LD      (IY+$0D),$FF    ; TTBMAX offset 13
L80F8:  CALL    L11A5           ; vm-que-in do "increment ?? and point to 2 word table #2 for ?? then ??"
L80FB:  JP      L15FB           ; to restore
; end of ?? (only fron ZGO, ?? and IGO !!)

; TERSE Forth ZGO does ??
L80FE:  XOR     A
        LD      HL,L18C0        ; point to mastervmr routine
        JR      L80B6                   ; (-$4e) to ??

; ?? (not used ??)
L8104:  XOR     A
        POP     HL
        JR      L80B6                   ; (-$52) to ??

; TERSE Forth IGO does ??
L8108:  LD      A,$01
        LD      HL,L18C0        ; point to mastervmr routine
        JR      L80B6                   ; (-$59) to ??

; ?? does ??
L810F:  LD      L,(IX+$1C)      ; VX offset 28
        LD      H,(IX+$1D)      ; VXH offset 29
        LD      E,(IY+$1C)      ; VX offset 28
        LD      D,(IY+$1D)      ; VXH offset 29
        AND     A
        SBC     HL,DE
        JP      P,L8124
        CALL    L053E           ; do Two's COMPLEMENT of HL
L8124:  AND     A
        SBC     HL,BC
        JP      P,L8149
        LD      L,(IX+$1E)      ; VY offset 30
        LD      H,(IX+$1F)      ; VYH offset 31
        LD      E,(IY+$1E)      ; VY offset 30
        LD      D,(IY+$1F)      ; VYH offset 31
        AND     A
        SBC     HL,DE
        JP      P,L813F
        CALL    L053E           ; do Two's COMPLEMENT of HL
L813F:  AND     A
        SBC     HL,BC
        JP      P,L8149
        LD      A,$01
        AND     A
        RET

; ??
L8149:  XOR     A
        RET

; PRXC does ??
L814B:  PUSH    DE
        PUSH    HL
        CALL    L810F
        POP     HL
        POP     DE
        RET

; TERSE Forth V^ does "ADD offset to Vector ADDRess"
L8153:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        POP     DE              ; restore offset
        ADD     HL,DE
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; TERSE Forth V@ does "PUSH (offset PLUS Vector ADDRess)"
L815B:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        POP     DE
        ADD     HL,DE
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; TERSE Forth V! does "STORE (SP+2) into (SP) offset Vector ADDRess"
L8166:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        POP     DE
        ADD     HL,DE
        POP     DE
        LD      (HL),E
        INC     HL
        LD      (HL),D
        JP      (IY)            ; indexed RETurn

; TERSE Forth VB@ does ??
L8171:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        POP     DE
        ADD     HL,DE
        LD      E,(HL)
        LD      D,$00
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; TERSE Forth VB! does ??
L817C:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        POP     DE
        ADD     HL,DE
        POP     DE
        LD      (HL),E
        JP      (IY)            ; indexed RETurn

; ??
L8185:  POP     HL
        POP     DE
        ADD     HL,DE
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; ??
L818B:  POP     HL
        POP     DE
        ADD     HL,DE
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; ??
L8194:  POP     HL
        POP     DE
        ADD     HL,DE
        POP     DE
        LD      (HL),E
        INC     HL
        LD      (HL),D
        JP      (IY)            ; indexed RETurn

; TERSE Forth OVB@ does ??
L819D:  POP     HL
        POP     DE
        ADD     HL,DE
        LD      E,(HL)
        LD      D,$00
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; TERSE Forth OVB does !??
L81A6:  POP     HL
        POP     DE
        ADD     HL,DE
        POP     DE
        LD      (HL),E
        JP      (IY)            ; indexed RETurn

; NULPAT 0-color BLANK Pattern (used by various TERSE FORTH code)
L81AD:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $01             ; 1 = Height in rows
        ;
        DB      $00             ;_._ hotspot for BLANK

; 8-byte Bit Number to Mask table
L81B2:  DB      $01,$02,$04,$08,$10,$20,$40,$80

; TERSE Forth BIT^ does "Bit in A to Mask Translation" subroutine
L81BA:  PUSH    DE
        PUSH    HL
        LD      E,A             ; only BIT number 0 - 7 is useful
        LD      D,$00
        LD      HL,L81B2        ; point to Bit Number to Mask table
        ADD     HL,DE
        LD      A,(HL)
        POP     HL
        POP     DE
        RET                     ; RETurns MASK in A

;**********************************************************
;
; MIXED Patterns !! (. = 0; X = Monochrome else = 4-colors)
;
;**********************************************************
;
; gr-p Monochrome RBOX (Rounded corners on a full BOX) for ?? pattern
L81C7:  DB      $09             ; 9 = X offset
        DB      $09             ; 9 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $12             ; 18 = Height in rows
        ;
        DB      $3F,$FF,$00     ; . . X X X X X X X X X X X X X X . . . . . . . .
        DB      $7F,$FF,$80     ; . X X X X X X X X X X X X X X X X . . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X(X)X X X X X X X X . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
        DB      $7F,$FF,$80     ; . X X X X X X X X X X X X X X X X . . . . . . .
        DB      $3F,$FF,$00     ; . . X X X X X X X X X X X X X X . . . . . . . .

; ex-p Monochrome EXIT SIGN pattern with hot-spot marked by _._
L8201:  DB      $09             ; 9 = X offset
        DB      $02             ; 2 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $05             ; 5 = Height in rows
        ;
        DB      $F4,$57,$C0     ; X X X X . X . . . X . X . X X X X X . . . . . .
        DB      $82,$91,$00     ; X . . . . . X . X . . X . . . X . . . . . . . .
        DB      $E1,$11,$00     ; X X X . . . . X ._._. X . . . X . . . . . . . .
        DB      $82,$91,$00     ; X . . . . . X . X . . X . . . X . . . . . . . .
        DB      $F4,$51,$00     ; X X X X . X . . . X . X . . . X . . . . . . . .

; rv-p Monochrome FILLED CIRCLE pattern
L8214:  DB      $08             ; 8 = X offset
        DB      $08             ; 8 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $10             ; 16 = Height in rows
        ;
        DB      $0F,$F0,$00     ; . . . . X X X X X X X X . . . . . . . . . . . .
        DB      $1F,$F8,$00     ; . . . X X X X X X X X X X . . . . . . . . . . .
        DB      $3F,$FC,$00     ; . . X X X X X X X X X X X X . . . . . . . . . .
        DB      $7F,$FE,$00     ; . X X X X X X X X X X X X X X . . . . . . . . .
        DB      $FF,$FF,$00     ; X X X X X X X X X X X X X X X X . . . . . . . .
        DB      $FF,$FF,$00     ; X X X X X X X X X X X X X X X X . . . . . . . .
        DB      $FF,$FF,$00     ; X X X X X X X X X X X X X X X X . . . . . . . .
        DB      $FF,$FF,$00     ; X X X X X X X X X X X X X X X X . . . . . . . .
        DB      $FF,$FF,$00     ; X X X X X X X X(X)X X X X X X X . . . . . . . .
        DB      $FF,$FF,$00     ; X X X X X X X X X X X X X X X X . . . . . . . .
        DB      $FF,$FF,$00     ; X X X X X X X X X X X X X X X X . . . . . . . .
        DB      $FF,$FF,$00     ; X X X X X X X X X X X X X X X X . . . . . . . .
        DB      $7F,$FE,$00     ; . X X X X X X X X X X X X X X . . . . . . . . .
        DB      $3F,$FC,$00     ; . . X X X X X X X X X X X X . . . . . . . . . .
        DB      $1F,$F8,$00     ; . . . X X X X X X X X X X . . . . . . . . . . .
        DB      $0F,$F0,$00     ; . . . . X X X X X X X X . . . . . . . . . . . .

; Monochrome ENTRY/EXIT HOLE pattern
L8248:  DB      $0D             ; 13 = X offset
        DB      $15             ; 21 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0C             ; 12 = Height in rows
        ;
        DB      $FF,$FF,$FF,$C0
        DB      $7F,$FF,$FF,$80
        DB      $7F,$FF,$FF,$80
        DB      $3F,$FF,$FF,$00
        DB      $3F,$FF,$FF,$00
        DB      $1F,$FF,$FE,$00
        DB      $1F,$FF,$FE,$00
        DB      $0F,$FF,$FC,$00
        DB      $0F,$FF,$FC,$00
        DB      $0F,$FF,$FC,$00
        DB      $07,$FF,$F8,$00
        DB      $07,$FF,$F8,$00
;
; X X X X X X X X X X X X X X X X X X X X X X X X X X . . . . . .
; . X X X X X X X X X X X X X X X X X X X X X X X X . . . . . . .
; . X X X X X X X X X X X X X X X X X X X X X X X X . . . . . . .
; . . X X X X X X X X X X X X X X X X X X X X X X . . . . . . . .
; . . X X X X X X X X X X X X X X X X X X X X X X . . . . . . . .
; . . . X X X X X X X X X X X X X X X X X X X X . . . . . . . . .
; . . . X X X X X X X X X X X X X X X X X X X X . . . . . . . . .
; . . . . X X X X X X X X X X X X X X X X X X . . . . . . . . . .
; . . . . X X X X X X X X X X X X X X X X X X . . . . . . . . . .
; . . . . X X X X X X X X X X X X X X X X X X . . . . . . . . . .
; . . . . . X X X X X X X X X X X X X X X X . . . . . . . . . . .
; . . . . . X X X X X X X X X X X X X X X X . . . . . . . . . . .

; { BLOCK 0250 }
;   v ] ORORTERN STUFF )
; DATA DOR0
;  9 B, 14 B, 3 B, 2 B,
; HEX
;  -1 , 0C0 B, -1 , 0C0 B,
; DECIMAL
;
; DOR0 Monochrome "DOOR closed" pattern
L827C:  DB      $09             ; 9 = X offset
        DB      $0E             ; 14 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $02             ; 2 = Height in rows
        ;
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
        DB      $FF,$FF,$C0     ; X X X X X X X X X X X X X X X X X X . . . . . .
;                          _?_ (hotspot from L8248!)

; DATA DOR1
;  9 B, 19 B, 3 B, 7 B,
; BINPAT
; ~ 00000100 00001000 00000000 ^
; ~ 00001100 00001100 00000000 ^
; ~ 00011000 00000110 00000000 ^
; ~ 00110000 00000011 00000000 ^
; ~ 01100000 00000001 10000000 ^
; ~ 11000000 00000000 11000000 ^
; ~ 10000000 00000000 01000000 ^
;
; DOR1 Monochrome "DOORS opening" pattern
L8286:  DB      $09             ; 9 = X offset
        DB      $13             ; 19 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $07             ; 7 = Height in rows
        ;
        DB      $04,$08,$00     ; . . . . . X . . . . . . X . . . . . . . . . . .
        DB      $0C,$0C,$00     ; . . . . X X . . . . . . X X . . . . . . . . . .
        DB      $18,$06,$00     ; . . . X X . . . . . . . . X X . . . . . . . . .
        DB      $30,$03,$00     ; . . X X . . . . . . . . . . X X . . . . . . . .
        DB      $60,$01,$80     ; . X X . . . . . . . . . . . . X X . . . . . . .
        DB      $C0,$00,$C0     ; X X . . . . . . ._._. . . . . . X X . . . . . .
        DB      $80,$00,$40     ; X . . . . . . . . . . . . . . . . X . . . . . .

; DATA DOR2
;  9 B, 21 B, 3 B, 9 B,
; HEX
;  C0 B, 0 B, C0 B, C0 B, 0 B, C0 B, C0 B, 0 B, C0 B,
;  C0 B, 0 B, C0 B, C0 B, 0 B, C0 B, C0 B, 0 B, C0 B,
;  C0 B, 0 B, C0 B, C0 B, 0 B, C0 B, C0 B, 0 B, C0 B,
; DECIMAL
; -->
;
; { BLOCK 0251 }
;         000 3333 3000 0000 ^
; ~ 0000 0000 0333 0000 0000 ^
; ~ 0000 0000 0000 0000 0000 ^
; ~ 0000 0000 0000 0000 0000 ^
; ~ 0000 0000 0000 0000 0000 ^
; ~ 0000 0000 0000 0000 0000 ^ STK>
;                                                  (hotspot from L827C!)
; DOR2 Monochrome "DOORS are OPEN" pattern
L829F:  DB      $09             ; 9 = X offset
        DB      $15             ; 21 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $09             ; 9 = Height in rows
        ;
        DB      $C0,$00,$C0     ; X X . . . . . . . . . . . . . . X X . . . . . .
        DB      $C0,$00,$C0     ; X X . . . . . . . . . . . . . . X X . . . . . .
        DB      $C0,$00,$C0     ; X X . . . . . . . . . . . . . . X X . . . . . .
        DB      $C0,$00,$C0     ; X X . . . . . . . . . . . . . . X X . . . . . .
        DB      $C0,$00,$C0     ; X X . . . . . . . . . . . . . . X X . . . . . .
        DB      $C0,$00,$C0     ; X X . . . . . . ._._. . . . . . X X . . . . . .
        DB      $C0,$00,$C0     ; X X . . . . . . . . . . . . . . X X . . . . . .
        DB      $C0,$00,$C0     ; X X . . . . . . . . . . . . . . X X . . . . . .
        DB      $C0,$00,$C0     ; X X . . . . . . . . . . . . . . X X . . . . . .
;                                                 (hotspot from L8286!)
; end of { BLOCKs 0250 & 0251 } !!
; COLOR patterns (1 = YELLOW; 2 = Red; 3 = DARK blue)
;
; MAGM 4-color "Remaining MAGIC Spells" (facing left) pattern
L82BE:  DB      $05             ; 5 = X offset
        DB      $05             ; 5 = Y offset
        DB      $03             ; 3 = Width in bytes
        DB      $0B             ; 11 = Height in rows
        ;
        DB      $00,$A0,$00     ; . . . . 2 2 . . . . . .
        DB      $0A,$0A,$00     ; . . 2 2 . . 2 2 . . . .
        DB      $23,$70,$80     ; . 2 . 3 1 3 . . 2 . . .
        DB      $23,$5C,$80     ; . 2 . 3 1 1 3 . 2 . . .
        DB      $AA,$80,$20     ; 2 2 2 2 2 . . . . 2 . .
        DB      $00,$80,$20     ; . . . . 2_._. . ._2_. . (hotspot from L829F!)
        DB      $02,$00,$80     ; . . . 2 . . . . 2 . . .
        DB      $2A,$00,$80     ; . 2 2 2 . . . . 2 . . .
        DB      $02,$AA,$00     ; . . . 2 2 2 2 2 . . . .
        DB      $01,$01,$00     ; . . . 1 . . . 1 . . . .
        DB      $05,$05,$00     ; . . 1 1 . . 1 1 . . . .

; 4-color Player ONE Pattern
L82E3:  DB      $03             ; 3 = X offset
        DB      $06             ; 6 = Y offset
        DB      $02             ; 2 = Width in bytes
        DB      $0C             ; 12 = Height in rows
        ;
        DB      $FF,$FF         ; 3 3 3 3 3 3 3 3
        DB      $FD,$7F         ; 3 3 3 1 1 3 3 3
        DB      $F5,$7F         ; 3 3 1 1 1 3 3 3
        DB      $F5,$7F         ; 3 3 1 1 1 3 3 3
        DB      $FD,$7F         ; 3 3 3 1 1 3 3 3
        DB      $FD,$7F         ; 3 3 3 1 1 3 3 3
        DB      $FD,$7F         ; 3 3 3(1)1 3 3 3
        DB      $FD,$7F         ; 3 3 3 1 1 3 3 3
        DB      $FD,$7F         ; 3 3 3 1 1 3 3 3
        DB      $D5,$57         ; 3 1 1 1 1 1 1 3
        DB      $D5,$57         ; 3 1 1 1 1 1 1 3
        DB      $FF,$FF         ; 3 3 3 3 3 3 3 3

; 4-color Player TWO Pattern
L82FF:  DB      $03             ; 3 = X offset
        DB      $06             ; 6 = Y offset
        DB      $02             ; 2 = Width in bytes
        DB      $0C             ; 12 = Height in rows
        ;
        DB      $FF,$FF         ; 3 3 3 3 3 3 3 3
        DB      $F5,$5F         ; 3 3 1 1 1 1 3 3
        DB      $D5,$57         ; 3 1 1 1 1 1 1 3
        DB      $D7,$D7         ; 3 1 1 3 3 1 1 3
        DB      $FF,$D7         ; 3 3 3 3 3 1 1 3
        DB      $FF,$5F         ; 3 3 3 3 1 1 3 3
        DB      $FD,$7F         ; 3 3 3(1)1 3 3 3
        DB      $F5,$FF         ; 3 3 1 1 3 3 3 3
        DB      $D7,$FF         ; 3 1 1 3 3 3 3 3
        DB      $D5,$57         ; 3 1 1 1 1 1 1 3
        DB      $D5,$57         ; 3 1 1 1 1 1 1 3
        DB      $FF,$FF         ; 3 3 3 3 3 3 3 3

; display table Spider EYES #3 pattern on OTHER ROM
L831B:  DB      $01,$00,$81     ; only 1 entry !! (NOT USED anyway)
        ;
L831E:  DB      $FF,$02,$2A     ; s-l-o-w Spider EYES duration = 255
        DB      $00,$1E,$83     ; loop to here

; Spa 2-word SPIDERS and EYES animation table(s) ?? with 0 entries ??
L8324:  DB      $00,$00,$85     ; 0; 0; -6 for 1 word + word entry ??
        ;
        DW      L29CA           ; word SPIDERS animation loop
        DW      L831E           ; word Spider EYES #3 display loop

; Spa-r IDENTICAL ?? 2-word SPIDERS and EYES animation table
L832B:  DB      $00,$00,$85     ; for SPIDERS and Spider EYES #3 animation
        ;
        DW      L29CA           ; word SPIDERS animation loop
        DW      L831E           ; word Spider EYES #3 display loop

; Zwa 2-word TROLLS animation table
L8332:  DB      $00,$00,$85     ; for s-l-o-w TROLL and EYES animation
        ;
        DW      L807B           ; word s-l-o-w TROLL animation loop
        DW      L29F9           ; word Spider EYES animation loop+3

; Zwa-s 2-word fast(er) TROLLS animation table
L8339:  DB      $00,$00,$85     ; for fast(er) TROLL and EYES animation
        ;
        DW      L8087           ; word fast(er) TROLL animation loop
        DW      L29F9           ; word EYES animation loop

; Jaw 2-word JAWS animation table
L8340:  DB      $00,$00,$85     ; for TEETH 2 DIE and TEETH HOLLOW animation
        ;
        DW      L3E24           ; word TEETH 2 DIE animation loop
        DW      L3F52           ; word TEETH HOLLOW animation loop

; P-RTY ?? 4-Word VARIOUS ROTOS animation loop
L8347:  DB      $00,$00,$87     ; now -8 for word + word + word + word entry ??
        ;
        DW      L2DC7           ; word final DIGGING ROTOS animation loop
        DW      L25F4           ; word DIGGERS animation loop #2 (or #3)
        DW      L2C05           ; word HOLLOW (facing LEFT) ROTO loop
        DW      L2B39           ; word yet another walking ROTOS animation loop
; end of patterns (and animation tables)

; { BLOCK 0210 }
; ( MONSTER AND TREASURE STUFF )
; XC? NOT IFTRUE VPTR @ HEX FFF0 VPTR ! IFEND <STKD
; RAMMARK
; { : M$ } VPTR @ MONSURP - VPTR ! { ; }
; M#L BR= MONV1 M$ M#L BR= MONV2 M$
; XC? IFTRUE M#L BR= MONV3 M$ M#L BR= MONV4 M$
;  M#L BR= JAWSV M$ IFEND
; M#L BR= ARV ( ARROW VECTOR ) M#L BR= CHRV ( CHAM REV VECT )
; VLENGTH BR= SCV
; M#L BR= SFXV
; 5 30 * 4 + C= ARWL ARWL BA= ARWP
; RAMLEN C= vs1l VARHERE C= vs1s
; M#L MONSURP + C= M#B
;
; : I:M M#B * MONV1 SWAP - ;
;
; came with TERSE FORTH code !!
;
; I:M does "Monster and treasure stuff"
L8352:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; M#B "pushWORD to System stack"
        DW      $020A           ; constant 522 for ("Size of a MONster Vector" + MONSURP) ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L00BC           ; MONV1 "pushWORD to System stack"
        DW      $FD51           ; for "MONster Vector" #1 base in Static RAM
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00B0           ; ... TerseRETurn

; : MON#? MONV1 SWAP - M#B / ;
; STK> XC? NOT IFTRUE VPTR @ H. VPTR ! IFEND
; -->
;
; MON#? does ??
L8363:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; MONV1 "pushWORD to System stack"
        DW      $FD51           ; for "MONster Vector" #1 base in Static RAM
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00BC           ; M#B "pushWORD to System stack"
        DW      $020A           ; constant 522 for ("Size of a MONster Vector" + MONSURP) ??
        ;
        DW      L041E           ; / do "word (SP) DIVide by (SP+2), Push QUOTIENT, Discard REMAINDER"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0210 } !!

; { BLOCK 0226 }
; ( HOSTAGE AND PLAYER STATE VARIABLES )
; ( THE HOSTAGE STATE VARIABLE )
; 0 SC= HSFREE ( HOSTAGE FREE )
; NC= HSATP ( HOSTAGE ATTACHED TO PLAYER )
; NC= HSATM ( HOSTAGE ATTACHED TO MONSTER )
; NC= HSLPF ( HOSTAGE LEAVING PLAYFIELD )
; NC= HSRES DROP ( HOSTAGE COMPLETELY RESCUED )
; ( ASSIMILATION STATE VARIABLE )
; 0 SC= ASNOT ( NOT ASSIMILATED )
; NC= ASSIM DROP  ( FULLY ASSIMILATED )
; ( PLAYERS ASSIMILATION STATE VARIABLE )
; 0 SC= ASCOOL ( PLAYER NOT ONTOP OF HOSTAGES )
; NC= ASONTOP DROP ( PLAYER IS ON TOP OF HOSTAGES )
; -->
; end of ( HOSTAGE AND PLAYER STATE VARIABLES ) !!

; { BLOCK 0284 }
; ( MONSTER AND TREASURE STUFF )
; RAMMARK
; ( M#L BR= ARV )
; V#L BR= PLYRV
; V#L BR= REVV
; M#L BR= KEY
; XC? IFTRUE M#L BR= TRSV IFEND
; DECIMAL
; -->
; end of { BLOCK 0284 } !!

; { BLOCK 0178 }
; ( HOSTAGE VECTORS )
; V#L BR= HOSV1
; XC? IFTRUE V#L BR= HOSV2
;  V#L BR= HOSV3 IFEND
; RAMLEN C= vs2l  VARHERE C= vs2s
;
; XC? IFTRUE 3 C= TOTAL-HOSTAGES
;  TABLE HOSTAB HOSV1 , HOSV2 , HOSV3 , 0 ,
; OTHERWISE 1 C= TOTAL-HOSTAGES TABLE HOSTAB HOSV1 , 0 , IFEND
;
; HOSTAB 3-word aka "HOStage vector TABle"
L8374:  DW      $EFB1           ; HOSV1 for "HOStage Vector" #1 in Static RAM
        DW      $EF51           ; HOSV2 for "HOStage Vector" #2 in Static RAM
        DW      $EEF1           ; HOSV3 for "HOStage Vector" #3 in Static RAM
        DW      $0000           ; NULL for end of table

; ( ******* )
; ( MORE NEAT VECTOR STUFF )
; : ZAP:VECT 0 vs1s vs1l FILL
;  0 vs2s vs2l FILL ;
; -->
;
; ZAP:VECT does "more neat VECTor stuff"
L837C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; vs1s "pushWORD to System stack (not ARWP ??)
        DW      $F18D           ; constant -3699 (for vs1 Start) in Static RAM
        ;
        DW      L00BC           ; vs1l "pushWORD to System stack"
        DW      $0C22           ; constant 3106 for (for vs1 Length) ??
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; vs2s "pushWORD to System stack" !! double definition !!
        DW      $EEF1           ; also ?? for HOSV3 "HOStage Vector" #3 base in Static RAM ??
        ;
        DW      L00BC           ; vs2l "pushWORD to System stack"
        DW      $029C           ; 668 for vs2l ??
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of ( MORE NEAT VECTOR STUFF ) !!

; { BLOCK 0121 }
; ( RANDOM # WITHOUT REPLACEMENT )
; XC? NOT IFTRUE
;  ;S
; IFEND
; HEX
; F= lur
; CODE URND
; <ASSEMBLE
;  H POP,
;  D POP,
;  B PUSH,
;  M A MOV,
;  E CMP,
;  0<>, IF,
;   E M MOV,
;  LABEL lur
;   H PUSH,
;   M C MOV,
;   H INX,
;   0 M MVI,
;   H INX,
;   C A MOV,
;   RRC,
;   RRC,
;   RRC,
;   1F ANI,
;   A B MOV,
;   C A MOV,
;   7 ANI,
;   0<>, IF,
;    B INR,
;   THEN,
;   BEGIN,
;    0 M MVI,
;    H INX,
;   LOOP,
;   H POP,
;  THEN,
;  H INX,
;  M A MOV,
;  H DCX,
;  M CMP,
;  lur JRNC,
;  M E MOV,
;  0 D MVI,
;  H PUSH,
;  rnd CALL,
;  L C MOV, ( C= CAND )
;  H POP, ( HL= TBL )
;  A XRA,
;  EXAF,
; -->
;
; { BLOCK 0141 }
; ( MORE NIFTY RND WITHOUT REPLACEMENT )
;  BEGIN,
;   C A MOV,
;   RRC,
;   RRC,
;   RRC,
;   1F ANI,
;   2 ADI,
;   A E MOV,
;   0 D MVI,
;   C A MOV,
;   7 ANI,
;   BIT^ CALL,
;   A B MOV,
;   H PUSH,
;   D DAD,
;   M A MOV,
;   B ANA,
;  0<>, WHILE,
;   H POP,
;   EXAF,
;   A INR,
;   0=, IF,
;    lur JMPR,
;   THEN,
;   EXAF,
;   C A MOV,
;   A INR,
;   M CMP,
;   0=, IF,
;    A XRA,
;   THEN,
;   A C MOV,
;  REPEAT,
;  M A MOV,
;  B ORA,
;  A M MOV,
;  H POP,
;  H INX,
;  M INR,
;  C L MOV,
;  0 H MVI,
;  B POP,
;  H PUSH,
; NEXT
; ASSEMBLE>
; DECIMAL
; -->
;
; URND does "Unsigned RaNDom # without replacement"
L8397:  POP     HL
        POP     DE
        PUSH    BC
        LD      A,(HL)
        CP      E
        JR      Z,L83B8                 ; (+$1a) IF 0<> False skip to THEN
        LD      (HL),E
L839F:  PUSH    HL              ; lur loop
        LD      C,(HL)
        INC     HL
        LD      (HL),$00
        INC     HL
        LD      A,C
        RRCA
        RRCA
        RRCA
        AND     $1F
        LD      B,A
        LD      A,C
        AND     $07
        JR      Z,L83B2                 ; (+$01) IF 0<> False skip
        INC     B
L83B2:  LD      (HL),$00        ; BEGIN loop #1 for B times
        INC     HL
        DJNZ    L83B2                   ; (-$05) LOOP to BEGIN #1
        POP     HL
L83B8:  INC     HL              ; THEN
        LD      A,(HL)
        DEC     HL
        CP      (HL)
        JR      NC,L839F                ; (-$1f) if ?? to lur
        LD      E,(HL)
        LD      D,$00
        PUSH    HL
        CALL    L1A4C           ; rnd do "SHIFT and limit RANGE for Next Pseudo-RANDOM Number"
        LD      C,L             ; ( C= CAND )
        POP     HL              ; ( HL= TBL )
        XOR     A
        EX      AF,AF'
; ( MORE NIFTY RND WITHOUT REPLACEMENT )
L83C9:  LD      A,C             ; BEGIN loop #2
        RRCA
        RRCA
        RRCA
        AND     $1F
        ADD     A,$02
        LD      E,A
        LD      D,$00
        LD      A,C
        AND     $07
        CALL    L81BA           ; BIT^ do "Bit in A to Mask Translation"
        LD      B,A
        PUSH    HL
        ADD     HL,DE
        LD      A,(HL)
        AND     B
        JR      Z,L83F2                 ; (+$11) WHILE 0<> False to loop Exit
        POP     HL
        EX      AF,AF'
        INC     A
        JR      NZ,L83E8                ; (+$02) IF 0= False skip
        JR      L839F                   ; (-$49) to lur

; THEN skip ??
L83E8:  EX      AF,AF'
        LD      A,C
        INC     A
        CP      (HL)
        JR      NZ,L83EF                ; (+$01) IF 0= False skip
        XOR     A
L83EF:  LD      C,A
        JR      L83C9                   ; (-$29) REPEAT to BEGIN #2

; (loop Exit does ??)
L83F2:  LD      A,(HL)
        OR      B
        LD      (HL),A
        POP     HL
        INC     HL
        INC     (HL)
        LD      L,C
        LD      H,$00
        POP     BC
        PUSH    HL
        JP      (IY)            ; indexed RETurn
; end of ( RANDOM # WITHOUT REPLACEMENT ) !!

; { BLOCK 0288 }
; ( VARIABLES ) DECIMAL
; V= Vpf ( PLAYER FAST VELOCITY ) V= Vps ( PLAYER SLOW VELOCITY )
; BV= DIRFLAG ( PLAYER DIRECTION FLAG )
; BV= O-M ( OBJECT-MOVING - PLAYER MOVING DOWN CHAMBER )
; BV= SPEEDE ( NON ACCELERATING SPEED VALUE )
; BV= SMARTS V= SMTMR ( MONSTER SMARTNESS FACTOR AND TIMER )
; BV= P-S ( PLAYER STATE VARIABLE )
;
; CODE P.S
;  P-S H LXI,
;  H PUSH,
; NEXT
;
; P.S does "Get Rlayer State variable-address"
L83FF:  LD      HL,$EEE6        ; P-S point to ( Player State ) Byte-Variable in Static RAM
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; 0 SC= PLEM NC= PLIC NC= PLMV NC= PLDOA NC= PLESC DROP
; V= SMTMRV ( SMARTS TIMER RESETER )
; V= T-P ( TOTAL-PATHS )
; BV= MACT ( MAGIC COLOR COUNTER ) BV= BKC ( BACKGROUND COLOR )
; -->
;
; end of { BLOCK 0288 } !!

; { BLOCK 0243 }
; ( MORE VARIABLES )
; SCON IFTRUE
;  9 BA= AP1S 9 BA= AP2S IFEND
; 0 SC= KYSHOW NC= KYOPEN DROP
; V= FOUNDIT BV= THATSALL
; BV= GO-C ( GAME OVER FLASH COUNTER )
; ( VARIABLES FOR MATRIX GENERATOR )
; V= GMNRP V= GMRC V= GMD V= GMNRC
; V= RCX V= RCY V= NRCX V= NRCY
; V= RPX V= RPDX V= RPY V= RPDY BV= RPD BV= RPMD
; BV= RPDIR ( DIRECTION CHOSEN )
; V= RPCOL ( REPAINT COLOR ) V= WALCO ( WALL COLOR )
; DECIMAL
; -->
;
; { BLOCK 0195 }
; ( CLEARED EACH NEW GAME STUFF )
; RAMMARK
; 2 BA= f#a : F#A NERDUP f#a ;
;
; F#A does "get CURRENT ??"
L8405:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ;
        DW      L00CD           ; f#a "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $EEDE           ; for Word ?? 2-Byte Array base in Static RAM
        ;
        DW      L00B0           ; ... TerseRETurn

; ( RANDOM #'S ALREADY USED )
; XC? IFTRUE
;  20 BA= ?m : ?M NERDUP IF 10 ?m ELSE 0 ?m THEN ;
; IFEND
;
; ?M does "get ( randoM # already used ) by CURRENT Player"
L840E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ; IF False to ELSE
        DW      L03CD,L8420     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; 10 do "pushBYTE to System stack" on PLAYER 2
        DB      $0A             ; for (plus half of a 20-Byte Array)
        ;
        DW      L00CD           ; ?m "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $EECA           ; for ( randoM #'s already used ) 20-Byte Array base
        ; (done so Jump to THEN)
        DW      L03C5,L8426     ; TerseJUMP to THEN
        ; ELSE
L8420:  DW      L00DD           ; 0 do "Push WORD 0 to System stack" (plus none) on PLAYER 1
        ;
        DW      L00CD           ; ?m "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $EECA           ; for ( randoM #'s already used ) 20-Byte Array base
        ; THEN
L8426:  DW      L00B0           ; ... TerseRETurn

; RAMLEN C= ngL VARHERE C= ngS
; -->
;
; end of { CLEARED EACH NEW GAME STUFF } !!

; { BLOCK 0110 }
; ( MEMORIZOR OF STUFF )
; XC? IFTRUE 9 C= NMZS
;  NMZS NNODES * C= NMS NMS BA= NMZ IFEND
; 6 C= vNS 5 C= v# vNS v# * C= vAL
; vAL BA= VM1 XC? IFTRUE vAL BA= VM2
;  : XVSA NERDUP IF VM2 ELSE VM1 THEN ;
; OTHERWISE : XVSA VM1 ; IFEND
;
; XVSA does ?? (more than just Push VM1 so VM2 exists !!)
L8428:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ; IF False to ELSE
        DW      L03CD,L8437     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00CD           ; VM2 "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E503           ; for ?? vAL sized 30-Word Byte Array base in NV RAM
        ; (done so Jump to THEN)
        DW      L03C5,L843B     ; TerseJUMP to ??
        ; ELSE
L8437:  DW      L00CD           ; VM1 "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E521           ; for ?? vAL sized 30-Word Byte Array base in NV RAM
        ; THEN
L843B:  DW      L00B0           ; ... TerseRETurn

;  2 BA= frh : FREDH NERDUP frh ; ( FREED HOS CTR )
;
; FREDH does "get FREeD Hostage counter"
L843D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ;
        DW      L00CD           ; frh "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E501           ; for Word ( FReed Hos ctr ) 2-Byte Array base in NV RAM
        ;
        DW      L00B0           ; ... TerseRETurn

; 2 A= mzp ( ACTIVE MAZE PTR )
; : MZP NERDUP mzp ;
; ." RAM END **** "
; VPTR @ H. -->
;
; MZP does "get CURRENT MaZe Pointer"
L8446:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ;
        DW      L00D8           ; mzp "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E4FD           ; for ( active MaZe Pointer ) Array base in NON-protected NV RAM ??
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { MEMORIZOR OF STUFF } !!

; { BLOCK 0194 }
; ( SPECIAL VECTOR GETTERS AND PUTTERS )
; CODE PUSH:CCR
;  0 H MVI,
;  H D MOV,
;  Y PUSHX,
;  vaddr LIYD,
;  NOWC Y L LDX,
;  NOWR Y E LDX,
;  Y POPX,
;  H PUSH,
;  D PUSH,
; NEXT
;
; PUSH:CCR does "special vector getters and putters"
L844F:  LD      H,$00
        LD      D,H
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      L,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      E,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        POP     IY
        PUSH    HL
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; CODE PUSH:CCRD
;  0 H MVI,
;  H D MOV,
;  Y PUSHX,
;  vaddr LIYD,
;  NOWC Y L LDX,
;  NOWR Y E LDX,
;  NOWD Y A LDX,
;  Y POPX,
;  H PUSH,
;  D PUSH,
;  A E MOV,
;  D PUSH,
; NEXT
;
; PUSH:CCRD does ?? (not used ??)
L8464:  LD      H,$00
        LD      D,H
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      L,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      E,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      A,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        POP     IY
        PUSH    HL
        PUSH    DE
        LD      E,A
        PUSH    DE
        JP      (IY)            ; indexed RETurn

; CODE COGO ( exchage BC with VCOR )
;  vaddr LHLD,
;  VCOR D LXI,
;  D DAD,
;  M A MOV,
;  C M MOV,
;  A C MOV,
;  H INX,
;  M A MOV,
;  B M MOV,
;  A B MOV,
; NEXT
;
; COGO does "exchage BC with VCOR (my CORoutine cell)" and another COGO returns !!
L847E:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0057        ; VCOR offset 87 for ( my Vector CORoutine cell )
        ADD     HL,DE
        LD      A,(HL)
        LD      (HL),C
        LD      C,A
        INC     HL
        LD      A,(HL)
        LD      (HL),B
        LD      B,A
        JP      (IY)            ; indexed RETurn (to my CORoutine cell instead !!)

; : SETCO 1+ VCOR V! ;
;
; DECIMAL
; -->
;
; SETCO does "SET (SP)+1 as my COroutine"
L848E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L00C5           ; VCOR "pushBYTE to System stack"
        DB      $57             ; offset 87 for ( my Vector CORoutine cell )
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { SPECIAL VECTOR GETTERS AND PUTTERS } !!

; { BLOCK 0112 }
; ( MORE STUFF )
; : Rip INTR VB@ NOWR VB! INTC VB@ NOWC VB! ;
;
; Rip does ?? "MORE STUFF"
L8498:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; INTR "pushBYTE to System stack"
        DB      $3C             ; offset 60 for ( INiTiaL Row )
        ;
        DW      L8171           ; VB@ do ??
        ;
        DW      L00C5           ; NOWR "pushBYTE to System stack"
        DB      $3E             ; offset 62 for ( CURRENT Row )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00C5           ; INTC "pushBYTE to System stack"
        DB      $3D             ; offset 61 for ( INiTiaL Column )
        ;
        DW      L8171           ; VB@ do ??
        ;
        DW      L00C5           ; NOWC "pushBYTE to System stack"
        DB      $3F             ; offset 63 for ( CURRENT Column )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; : Snm NOWR VB! NOWC VB! ;
;
; Snm does ??
L84AF:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; NOWR "pushBYTE to System stack"
        DB      $3E             ; offset 62 for ( CURRENT Row )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00C5           ; NOWC "pushBYTE to System stack"
        DB      $3F             ; offset 63 for ( CURRENT Column )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; : Sim DUP ROLL INTR OVB! INTC OVB! ;
;
; L84BC: Sim does ?? (not used ??)
        RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L8099           ; ROLL do "ROTate in REVERSE !!"
        ;
        DW      L00C5           ; INTR "pushBYTE to System stack"
        DB      $3C             ; offset 60 for ( INiTiaL Row )
        ;
        DW      L81A6           ; OVB do ??           ; OVB do ??
        ;
        DW      L00C5           ; INTC "pushBYTE to System stack"
        DB      $3D             ; offset 61 for ( INiTiaL Column )
        ;
        DW      L81A6           ; OVB do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; : ON:TARGET? PUSH:CCR INTR VB@ = SWAP INTC VB@ = AND ;
;
; ON:TARGET? does ??
L84CD:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L844F           ; PUSH:CCR do ??
        ;
        DW      L00C5           ; INTR "pushBYTE to System stack"
        DB      $3C             ; offset 60 for ( INiTiaL Row )
        ;
        DW      L8171           ; VB@ do ??
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L00C5           ; INTC "pushBYTE to System stack"
        DB      $3D             ; offset 61 for ( INiTiaL Column )
        ;
        DW      L8171           ; VB@ do ??
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L00B0           ; ... TerseRETurn

; : POA MYFLAG V^ FLAG!-ON ;
;
; POA does ??
L84E4:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; MYFLAG "pushBYTE to System stack"
        DB      $54             ; offset 84 for ( build in neato FLAG )
        ;
        DW      L8153           ; V^ do "ADD offset to Vector ADDRess"
        ;
        DW      L1B4C           ; FLAG!-ON do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; : Src START-COL START-ROW ;
;
; Src does ??
L84EE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; START-COL "pushBYTE to System stack"
        DB      $05             ; constant 5 for "START COLumn"
        ;
        DW      L00C5           ; START-ROW "pushBYTE to System stack"
        DB      $05             ; constant 5 for "START ROW"
        ;
        DW      L00B0           ; ... TerseRETurn

; more of { BLOCK 0112 }
; CODE GRCD
;  XTIX,
;  Y PUSHX,
;  vaddr LIYD,
;  NOWD X A LDX,
;  A NOWD Y STX,
;  NOWR X A LDX,
;  A NOWR Y STX,
;  NOWC X A LDX,
;  A NOWC Y STX,
;  Y POPX,
;  X POPX,
; NEXT
;
; GRCD does ??
L84F7:  EX      (SP),IX
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      A,(IX+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        LD      (IY+$40),A      ; NOWD offset 64 for ( CURRENT Direction )
        LD      A,(IX+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      (IY+$3E),A      ; NOWR offset 62 for ( CURRENT Row )
        LD      A,(IX+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      (IY+$3F),A      ; NOWC offset 63 for ( CURRENT Column )
        POP     IY
        POP     IX
        JP      (IY)            ; indexed RETurn

; : EMOV DIVG ZERODXDYAXAY ;
;
; EMOV does ??
L8517:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L1D2F           ; ZERODXDYAXAY do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; alert: 4 routines are duplicated following ??
;
; SUBR FREEZE
;  F-F H LXI,
;  M INR,
;  RET,
;
; FREEZE does "INCrement F-F for Freeze Flag"
L851E:  LD      HL,$EEC5        ; F-F point to ( Freeze Flag ) Byte-Variable
        INC     (HL)
        RET

; SUBR FREEZE?
;  F-F LDA,
;  A ANA,
;  RET,
;
; FREEZE? does "TEST F-F for Freeze Flag"
L8523:  LD      A,($EEC5)       ; F-F read ( Freeze Flag ) Byte-Variable in Static RAM
        AND     A
        RET

; CODE FREEZETH
;  FREEZE CALL,
; NEXT
;
; L8528: FREEZETH (not used ??) does "INCrement F-F for Freeze Flag" from Forth
        CALL    L851E           ; FREEZE do "INCrement F-F for Freeze Flag"
        JP      (IY)            ; indexed RETurn

; CODE UNFREEZE
; .ABS
;  F-F H LXI,
;  M DCR,
;  0<, IF,
;   0 M MVI,
;  THEN,
; .REL
; NEXT
; -->
;
; UNFREEZE does "DECrement F-F for Freeze Flag MIN Zero"
L852D:  LD      HL,$EEC5        ; F-F point to ( Freeze Flag ) Byte-Variable in Static RAM
        DEC     (HL)
        JP      P,L8536         ; IF 0< False skip
        LD      (HL),$00        ; not below 0 !!
L8536:  JP      (IY)            ; indexed RETurn
; end of { BLOCK 0112 } !!

; alert: 4 DUPLICATED ROUTINES below
; { BLOCK 0105 }
;   z   O EEND UNFREEZE ROUTINES )
; SUBR FREEZE
;  F-F H LXI,
;  M INR,
;  RET,
;
; SUBR FREEZE?
;  F-F LDA,
;  A ANA,
;  RET,
;
; CODE FREEZETH
;  FREEZE CALL,
; NEXT
;
; CODE UNFREEZE
; .ABS
;  F-F H LXI,
;  M DCR,
;  0<, IF,
;   0 M MVI,
;  THEN,
; .REL
; NEXT
; -->
;
; end of { BLOCK 0105 } full of DUPLICATED routines !!

; { BLOCK 0191 }
; ( 16 BIT INTEGER DIVIDE ROUTINE: M N UN/ Q R )
; DECIMAL
; FORWARD .ZERO FORWARD i5 FORWARD i6
; FORWARD i1 FORWARD i2 FORWARD i3 FORWARD i4
; SUBR unsdiv
; <ASSEMBLE
;  L C MOV,
;  H B MOV,
;  D A MOV,
;  0 H LXI,
;  E ORA,
; .ZERO JRZ,
;  B A MOV,
;  16 B MVI,
; LABEL i1
;  C RALR,
;  RAL,
;  H DADC,
;  D DSBC,
; LABEL i2
;  CMC,
;  i5 JRNC,
; LABEL i3
;  i1 DJNZ,
;  i6 JMPR,
; LABEL i4
;  C RALR,
;  RAL,
;  H DADC,
;  A ANA,
;  D DADC,
;  i3 JRC,
;  i2 JRZ,
; LABEL i5
;  i4 DJNZ,
;  D DAD,
;  A ANA,
; ( MAKE IT POS )
; LABEL i6
;  C RALR,
;  RAL,
;  A D MOV,
;  C E MOV,
; LABEL .ZERO
;  RET,
; ASSEMBLE>
;
; unsdiv does "UNSigned 16-bit integer DIVide" ( M N UN/ Q R ) routine
L8538:  LD      C,L
        LD      B,H
        LD      A,D
        LD      HL,$0000        ; 0 for ??
        OR      E
        JR      Z,L8567                 ; (+$26) if ?? to .ZERO
        LD      A,B
        LD      B,$10           ; fabricate count DO, LOOP, for 16 times IN TOTAL !!
; i1 label for Top loop up to 16 loops
L8544:  RL      C
        RLA
        ADC     HL,HL
        SBC     HL,DE
; i2 label
L854B:  CCF
        JR      NC,L855E                ; (+$10) if ?? to i5 (drop to Bottom loop !!)
; i3 label
L854E:  DJNZ    L8544                   ; (-$0c) to i1 for LOOP, as MANY as 16 times
        JR      L8562                   ; (+$10) to i6 (when ALL 16 used in Top loop)

; i4 label for Bottom loop
L8552:  RL      C
        RLA
        ADC     HL,HL
        AND     A
        ADC     HL,DE
        JR      C,L854E                 ; (-$0e) if ?? to i3 (back to Top loop !!)
        JR      Z,L854B                 ; (-$13) if ?? to i2 (back to Top loop too)
; i5 label
L855E:  DJNZ    L8552                   ; (-$0e) to i4 for LOOP, any REMAINING times
        ADD     HL,DE
        AND     A
; i6 label ( MAKE IT POS )
L8562:  RL      C               ; ... or fall through after Bottom loop
        RLA
        LD      D,A
        LD      E,C
L8567:  RET                     ; .ZERO label

; SUBR UNSDIV
;  H PUSH,
;  D DSBC,
;  CY, IF,
;   0 D LXI,
;   H POP,
;  ELSE,
;   H POP,
;   unsdiv CALL,
;  THEN,
;  RET,
;
; UNSDIV does "?? then unsdiv ( M N UN/ Q R )" ??
L8568:  PUSH    HL
        SBC     HL,DE
        JR      NC,L8573                ; (+$06) IF CY False skip to ELSE
        LD      DE,$0000        ; 0 for ??
        POP     HL
        JR      L8577                   ; (+$04) to THEN

; ELSE ??
L8573:  POP     HL
        CALL    L8538           ; unsdiv do "UNSigned Word DIVide"
L8577:  RET                     ; THEN

; CODE UN/
;  EXX,
;  D POP,
;  H POP,
;  UNSDIV CALL,
;  H PUSH,
;  D PUSH,
;  EXX,
; NEXT
; DECIMAL
; -->
;
; L8578: (not used ??) UN/ does "?? then unsdiv: M N UN/ Q R" from Terse
        EXX
        POP     DE
        POP     HL
        CALL    L8568           ; UNSDIV do "?? then unsdiv" ( M N UN/ Q R )
        PUSH    HL
        PUSH    DE
        EXX
        JP      (IY)            ; indexed RETurn
; end of { 16 BIT INTEGER DIVIDE ROUTINE: M N UN/ Q R } !!

; { BLOCK 0190 }
; ( COMPUTE DELTA FOR 1 COORDINATE - CLEAR VECTOR )
; ( FIRST A NEGATION SUBROUTINE )
; SUBR CMPHL
;  H A MOV,
;  CMA,
;  A H MOV,
;  L A MOV,
;  CMA,
;  A L MOV,
;  H INX,
;  RET,
;
; CMPHL does "first a NEGation subroutine"
L8583:  LD      A,H
        CPL
        LD      H,A
        LD      A,L
        CPL
        LD      L,A
        INC     HL
        RET

; ( IN: HL=TARGET, DE=TIME, BC=START )
; SUBR CDELTA
;  B PUSH,
;  A ANA,
;  B DSBC,
;  CY~, IF,
;   UNSDIV CALL,
;  ELSE,
;   CMPHL CALL,
;   UNSDIV CALL,
;   CMPHL CALL,
;   XCHG,
;   CMPHL CALL,
;   XCHG,
;  THEN,
;  B POP,
;  B DAD,
;  RET,
;
; CDELTA does "Compute DELTA for 1 coordinate" and CLEAR VECTOR ??
; note ( IN: HL=TARGET, DE=TIME, BC=START )
L858B:  PUSH    BC
        AND     A
        SBC     HL,BC
        JR      C,L8596                 ; (+$05) IF CY~ False skip to ELSE
        CALL    L8568           ; UNSDIV do "?? then unsdiv" ( M N UN/ Q R )
        JR      L85A4                   ; (+$0e) skip to THEN

; ELSE ??
L8596:  CALL    L8583           ; CMPHL do "first a NEGation subroutine"
        CALL    L8568           ; UNSDIV do "?? then unsdiv" ( M N UN/ Q R )
        CALL    L8583           ; CMPHL do "first a NEGation subroutine"
        EX      DE,HL
        CALL    L8583           ; CMPHL do "first a NEGation subroutine"
        EX      DE,HL
L85A4:  POP     BC              ; THEN
        ADD     HL,BC
        RET
; end of ( COMPUTE DELTA FOR 1 COORDINATE - CLEAR VECTOR ) !!

; ( NEW SQUARE ROOT ROUTINE )
; F= sqrtl
; SUBR sqrt
; <ASSEMBLE
;  1 A MVI,
;  1 B LXI,
;  1 D LXI,
; LABEL sqrtl
;  A ANA,
;  D DSBC,
;  RZ,
;  RC,
;  D DAD,
;  B INX,
;  B INX,
;  XCHG,
;  B DAD,
;  A INR,
;  XCHG,
;  sqrtl JMPR,
; ASSEMBLE>
; DECIMAL
; -->
;
; sqrt does "new SQuare RooT" routine
L85A7:  LD      A,$01
        LD      BC,$0001
        LD      DE,$0001
L85AF:  AND     A               ; sqrtl label
        SBC     HL,DE
        RET     Z               ; if ?? RETurn
        RET     C               ; if ?? RETurn also
        ADD     HL,DE
        INC     BC
        INC     BC
        EX      DE,HL
        ADD     HL,BC
        INC     A
        EX      DE,HL
        JR      L85AF                   ; (-$0e) to sqrtl
; end of { BLOCK 0190 } !!

; { BLOCK 0183 }
; ( ROUTINE TO VECTOR BETWEEN CURRENT POSITION AND DEST
; IN TIME GIVEN IN VECTOR )
; CODE A->DEST/TIME
;  B PUSH,
;  Y PUSHX,
;  vaddr LIYD,
;  VXH Y B LDX,
;  VX Y C LDX,
;  VDESTXH Y H LDX,
;  VDESTX Y L LDX,
;  TTIMERH Y D LDX,
;  TTIMER Y E LDX,
;  D PUSH,
;  CDELTA CALL,
;  H VXH Y STX,
;  L VX Y STX,
;  D VDXH Y STX,
;  E VDX Y STX,
;  VYH Y B LDX,
;  VY Y C LDX,
;  VDESTYH Y H LDX,
;  VDESTY Y L LDX,
;  D POP,
;  CDELTA CALL,
;  H VYH Y STX,
;  L VY Y STX,
;  D VDYH Y STX,
;  E VDY Y STX,
;  Y POPX,
;  B POP,
; NEXT
; DECIMAL
; -->
;
; A->DEST/TIME does "vector between current position and DEST in TIME given in vector"
L85BD:  PUSH    BC
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      B,(IY+$1D)      ; VXH offset 29
        LD      C,(IY+$1C)      ; VX offset 28
        LD      H,(IY+$32)      ; VDESTXH offset 50
        LD      L,(IY+$31)      ; VDESTX offset 49
        LD      D,(IY+$0F)      ; TTIMERH offset 15
        LD      E,(IY+$0E)      ; TTIMER offset 14
        PUSH    DE
        CALL    L858B           ; CDELTA do "Compute DELTA for 1 coordinate"
        LD      (IY+$1D),H      ; VXH offset 29
        LD      (IY+$1C),L      ; VX offset 28
        LD      (IY+$27),D      ; VDXH offset 39
        LD      (IY+$26),E      ; VDX offset 38
        LD      B,(IY+$1F)      ; VYH offset 31
        LD      C,(IY+$1E)      ; VY offset 30
        LD      H,(IY+$34)      ; VDESTYH offset 52
        LD      L,(IY+$33)      ; VDESTY offset 51
        POP     DE
        CALL    L858B           ; CDELTA do "Compute DELTA for 1 coordinate"
        LD      (IY+$1F),H      ; VYH offset 31
        LD      (IY+$1E),L      ; VY offset 30
        LD      (IY+$29),D      ; VDYH offset 41
        LD      (IY+$28),E      ; VDY offset 40
        POP     IY
        POP     BC
        JP      (IY)            ; indexed RETurn
; end of ( ROUTINE TO VECTOR BETWEEN CURRENT POSITION AND DEST IN TIME GIVEN IN VECTOR ) !!

; { BLOCK 0302 }
; ( POSITION COMPUTERS )
; <STKD
; : C-c COLSIZE * COLSIZE 2 / + 159 - ;
;
; C-c does "Compute Column"
L8607:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; COLSIZE "pushBYTE to System stack"
        DB      $1D             ; constant 29 for "COLumn SIZE"
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L00C5           ; COLSIZE "pushBYTE to System stack"
        DB      $1D             ; constant 29 for "COLumn SIZE" again
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L041E           ; / do "word (SP) DIVide by (SP+2), Push QUOTIENT, Discard REMAINDER"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $9F             ; 159 for ??
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00B0           ; ... TerseRETurn

; : R-c ROWSIZE * ROWSIZE 2 / + 103 - ;
;
; R-c does "Compute Row"
L861D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; ROWSIZE "pushBYTE to System stack"
        DB      $1D             ; constant 29 for "ROW SIZE";
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L00C5           ; ROWSIZE "pushBYTE to System stack"
        DB      $1D             ; constant 29 for "ROW SIZE"; again
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L041E           ; / do "word (SP) DIVide by (SP+2), Push QUOTIENT, Discard REMAINDER"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $67             ; 103 for ??
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00B0           ; ... TerseRETurn

; : COMP:XY R-c ROWDEV 2 / ROWDEV RND - + SWAP
; C-c COLDEV 2 / COLDEV RND - + SWAP ;
;
; STK>
; -->
;
; COMP:XY does "COMPute X and Y position"
L8633:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L861D           ; R-c do "Compute Row"
        ;
        DW      L00C5           ; ROWDEV "pushBYTE to System stack"
        DB      $08             ; constant 8 for ??
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L041E           ; / do "word (SP) DIVide by (SP+2), Push QUOTIENT, Discard REMAINDER"
        ;
        DW      L00C5           ; ROWDEV "pushBYTE to System stack"
        DB      $08             ; constant 8 for ?? Range ??
        ;
        DW      L1A5B           ; RND does "SHIFT and limit RANGE for Next Pseudo-RANDOM Number"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L8607           ; C-c do "Compute Column"
        ;
        DW      L00C5           ; COLDEV "pushBYTE to System stack"
        DB      $08             ; constant 8 for ??
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L041E           ; / do "word (SP) DIVide by (SP+2), Push QUOTIENT, Discard REMAINDER"
        ;
        DW      L00C5           ; COLDEV "pushBYTE to System stack"
        DB      $08             ; constant 8 for ?? Range ??
        ;
        DW      L1A5B           ; RND does "SHIFT and limit RANGE for Next Pseudo-RANDOM Number"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of ( POSITION COMPUTERS ) !!

; { BLOCK 0197 }
; ( NODE ZAMMERS )
; ( SUBR node^ D= ROW E= COL C= DISP, OUT HL= ^ )
; SUBR node^
;  D PUSH,
;  D A MOV,
;  RLC,
;  A L MOV,
;  RLC,
;  RLC,
;  L ADD,
;  D ADD,
;  E ADD,
;  A E MOV,
;  0 D MVI,
;  E L MOV,
;  D H MOV,
;  D DAD,
;  D DAD, ( HL= A*3 )
;  XCHG,
;  H DAD,
;  H DAD,
;  H DAD,  ( A*8 )
;  XCHG,
;  D DAD,
;  D DAD,
;  D DAD,
;  C E MOV,
;  0 D MVI,
;  D DAD, ( ADD DISPLACEMENT )
;  0 NODEMAT D LXI,
;  D DAD,
;  D POP,
;  RET,
;
; node^ does "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
L865E:  PUSH    DE
        LD      A,D
        RLCA                    ; ROW times 2
        LD      L,A
        RLCA
        RLCA                    ; times 8 now
        ADD     A,L             ; ... 10
        ADD     A,D             ; * 11 total
        ADD     A,E             ; plus COLumn
        LD      E,A
        LD      D,$00
        LD      L,E             ; save as Word A for ??
        LD      H,D
        ADD     HL,DE           ; times 2
        ADD     HL,DE           ; ( HL= A*3 )
        EX      DE,HL
        ADD     HL,HL
        ADD     HL,HL
        ADD     HL,HL           ; ( A*8 )
        EX      DE,HL
        ADD     HL,DE           ; ... 11
        ADD     HL,DE           ; ?? 19
        ADD     HL,DE           ; 27 for NODSIZ ??
        LD      E,C
        LD      D,$00
        ADD     HL,DE           ; ( ADD DISPLACEMENT )
        LD      DE,$E792        ; NODEMAT point to "NODE MATrix" NM-S Byte Array in NV RAM
        ADD     HL,DE
        POP     DE
        RET

; CODE NODE^
;  EXX,
;  B POP,
;  H POP,
;  D POP,
;  L D MOV,
;  node^ CALL,
;  H PUSH,
;  EXX,
; NEXT
;
; NODE^ does "NODE Zammer ( COL ROW DISP --- ^ )" from Terse
; note: E= (SP+4) for COL, L= (SP+2) for ROW, C= (SP) for DISP, OUT (SP)= HL ^ ??"
L8680:  EXX
        POP     BC              ; DISPlacement into node ??
        POP     HL
        POP     DE
        LD      D,L
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        PUSH    HL
        EXX
        JP      (IY)            ; indexed RETurn

; SUBR noded^
;  node^ CALL,
;  D PUSH,
;  MPL0 D LXI,
;  D DAD,
;  D POP,
;  RET,
;
; noded^ does ??
L868C:  CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        PUSH    DE
        LD      DE,$0008        ; MPL0 constant 8 for ??
        ADD     HL,DE
        POP     DE
        RET

; SUBR noder^
;  node^ CALL,
;  D PUSH,
;  RVMD D LXI,
;  D DAD,
;  D POP,
;  RET,
; -->
;
; noder^ does ??
L8696:  CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        PUSH    DE
        LD      DE,$0014        ; RVMD constant 20 for ??
        ADD     HL,DE
        POP     DE
        RET
; end of { NODE ZAMMERS } !!

; { BLOCK 0103 }
; ( TEST GROTTO DRAWN AND SET GROTTO DRAWN )
; CODE S-GD
;  H POP,
;  D POP,
;  L D MOV,
;  B PUSH,
;  NODMSK C MVI,
;  node^ CALL,
;  NMDRW M SET,
;  B POP,
; NEXT
;
; S-GD does "Set Grotto Drawn"
L86A0:  POP     HL
        POP     DE
        LD      D,L
        PUSH    BC
        LD      C,$18           ; NODMSK constant 24 for ??
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        SET     0,(HL)          ; NMDRW bit number 0 for ??
        POP     BC
        JP      (IY)            ; indexed RETurn

; CODE G-D?
;  H POP,
;  D POP,
;  L D MOV,
;  B PUSH,
;  NODMSK C MVI,
;  node^ CALL,
;  M A MOV,
;  NMDRM ANI,
;  A L MOV,
;  0 H MVI,
;  B POP,
;  H PUSH,
; NEXT
; -->
;
; g-d? does "test Grotto Drawn"
L86AE:  POP     HL
        POP     DE
        LD      D,L
        PUSH    BC
        LD      C,$18           ; NODMSK constant 24 for ??
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      A,(HL)
        AND     $01             ; NMDRM constant 1 for ??
        LD      L,A
        LD      H,$00
        POP     BC
        PUSH    HL
        JP      (IY)            ; indexed RETurn
; end of { TEST GROTTO DRAWN AND SET GROTTO DRAWN } !!

; { BLOCK 0116 }
; ( TEST:REL AND MOVE:NODE )
; ( D=ROW,E=COL,C=REL   COL ROW REL TEST:REL --- DIST )
; SUBR test:rel
;  C A MOV,
;  MPL0 ADI,
;  A C MOV,
;  node^ CALL,
;  M A MOV,
;  RET,
;
; L86C1: (not used) test:rel does "D=ROW,E=COL,C=REL ( COL ROW REL TEST:REL --- DIST )"
        LD      A,C
        ADD     A,$08           ; MPL0 constant 8 for ??
        LD      C,A
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      A,(HL)
        RET

; ?? commented out ??
; ( CODE TEST:REL
;  EXX,
;  B POP,
;  H POP,
;  D POP,
;  L D MOV,
;  test:rel CALL
;  A L MOV,
;  0 H MVI,
;  H PUSH,
;  EXX,
; NEXT )

; more of { BLOCK 0116 } !!
; ( MOVE:NODE INSTRUCTIONS TO INCREMENT )
; SUBR INSTR
;  D INR,
;  RET,
;
; INSTR does "INSTRuctions to increment" base address (then RETurns for move:node !!)
L86CA:  INC     D       ; for Up a Row
        RET

;  E DCR,
;  RET,
;
; L86CC: ?? (indexed as 4-Word table !!)
        DEC     E       ; for Left a Column
        RET

;  E INR,
;  RET,
;
; L86CE: (labels not used) ??
        INC     E       ; for Right a Column
        RET

;  D DCR,
;  RET,
;
; L86D0: (not used) ??
        DEC     D       ; for Down a Row
        RET
; end of ( MOVE:NODE INSTRUCTIONS TO INCREMENT ) !!

; SUBR move:node
;  B PUSH, ( C=DIR, D=ROW, E=COL )
;  0 B MVI,
;  INSTR H LXI,
;  B DAD,
;  B DAD,
;  B POP,
;  PCHL,
;
; move:node does "C=DIR, D=ROW, E=COL" routine
L86D2:  PUSH    BC
        LD      B,$00
        LD      HL,L86CA        ; point to INSTR for "INSTRuctions to increment" table
        ADD     HL,BC           ; plus relative DIRection times 2
        ADD     HL,BC           ; see: JOYTBL for REL conversion
        POP     BC
        JP      (HL)            ; to Selected INSTRuction

; CODE MOVE:NODE
;  EXX,
;  B POP,
;  H POP,
;  D POP,
;  L D MOV,
;  move:node CALL,
;  D L MOV,
;  0 D MVI,
;  D H MOV,
;  D PUSH,
;  H PUSH,
;  EXX,
; NEXT
; -->
;
; L86DC: (not used) MOVE:NODE does "C=DIR, D=ROW, E=COL" from Terse
        EXX
        POP     BC
        POP     HL
        POP     DE
        LD      D,L
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        LD      L,D
        LD      D,$00
        LD      H,D
        PUSH    DE
        PUSH    HL
        EXX
        JP      (IY)            ; indexed RETurn
; end of ( TEST:REL AND MOVE:NODE ) !!

; TERSE Forth NODE! does ??
L86ED:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L8680           ; NODE^ do "NODE Zammer ( COL ROW DISP --- ^ )"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; TERSE Forth NODE@ does ??
L86F4:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L8680           ; NODE^ do "NODE Zammer ( COL ROW DISP --- ^ )"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; TERSE Forth NODEB@ does ??
L86FB:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L8680           ; NODE^ do "NODE Zammer ( COL ROW DISP --- ^ )"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; TERSE Forth CL:NM does "CLear Node Matrix" from $E792 base to $EE87
L8702:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; NODEMAT "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E792           ; point to "NODE MATrix" NM-S Byte Array in NV RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $06F6           ; 1782 for "Byte Count" word
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ROTN ?? 4-byte table ??
L8713:  DB      $00,$80,$00,$80

; { BLOCK 0232 }
; ( HOPPED UP 8 BIT MPY ROUTINE )
; SUBR BABS
;  A ANA,
;  RP,
;  CMA,
;  A INR,
;  RET,
;
; BABS does "turn Byte in A ABSolute" routine
L8717:  AND     A
        RET     P
        CPL
        INC     A
        RET

; ( HL= INITIAL DISP, DE= DELTA, A= DIST )
; SUBR HOTMPY
;  RRC,
;  CY, IF,
;   D DAD,
;  THEN,
;  E SLAR,
;  D RALR,
;  RRC,
;  CY, IF,
;   D DAD,
;  THEN,
;  E SLAR,
;  D RALR,
;  RRC,
;  CY, IF,
;   D DAD,
;  THEN,
;  E SLAR,
;  D RALR,
;  RRC,
;  CY, IF,
;   D DAD,
;  THEN,
;  E SLAR,
;  D RALR,
;  RRC,
;  CY, IF,
;   D DAD,
;  THEN,
;  E SLAR,
;  D RALR,
;  RRC,
;  CY, IF,
;   D DAD,
;  THEN,
;  E SLAR,
;  D RALR,
;  RRC,
;  CY, IF,
;   D DAD,
;  THEN,
;  E SLAR,
;  D RALR,
;  RRC,
;  CY, IF,
;   D DAD,
;  THEN,
;  RET,
;
; HOTMPY does "HL= INITIAL DISP, DE= DELTA, A= DIST" ( HOPPED UP 8 BIT MPY ) routine
L871C:  RRCA
        JR      NC,L8720                ; (+$01) IF CY False skip
        ADD     HL,DE
L8720:  SLA     E
        RL      D
        RRCA
        JR      NC,L8728                ; (+$01) IF CY False skip
        ADD     HL,DE
L8728:  SLA     E
        RL      D
        RRCA
        JR      NC,L8730                ; (+$01) IF CY False skip
        ADD     HL,DE
L8730:  SLA     E
        RL      D
        RRCA
        JR      NC,L8738                ; (+$01) IF CY False skip
        ADD     HL,DE
L8738:  SLA     E
        RL      D
        RRCA
        JR      NC,L8740                ; (+$01) IF CY False skip
        ADD     HL,DE
L8740:  SLA     E
        RL      D
        RRCA
        JR      NC,L8748                ; (+$01) IF CY False skip
        ADD     HL,DE
L8748:  SLA     E
        RL      D
        RRCA
        JR      NC,L8750                ; (+$01) IF CY False skip
        ADD     HL,DE
L8750:  SLA     E
        RL      D
        RRCA
        JR      NC,L8758                ; (+$01) IF CY False skip
        ADD     HL,DE
L8758:  RET

; SUBR SQUARE
;  BABS CALL,
;  A E MOV,
;  0 D MVI,
;  0 H LXI,
;  HOTMPY JMPR,
; -->
;
; SQUARE does ??
L8759:  CALL    L8717           ; BABS do "turn Byte in A ABSolute"
        LD      E,A
        LD      D,$00
        LD      HL,$0000        ; 0 for ??
        JR      L871C                   ; (-$48) to HOTMPY "HL= DISP, DE= DELTA, A= DIST"
; end of { BLOCK 0232 } !!

; { BLOCK 0085 }
; ( CALCULATE X Y POSITION OF OBJECT FROM DISTANCE, BASE, AND )
; ( DELTAS )
; F= Txy
; SUBR CALCXY
; <ASSEMBLE
;  0 C MVI,
;  NOWR Y A LDX,
;  MEMR Y CMPX,
;  0<>, IF,
;   C INR,
;   A MEMR Y STX,
;  THEN,
;  NOWC Y A LDX,
;  MEMC Y CMPX,
;  0<>, IF,
;   C INR,
;   A MEMC Y STX,
;  THEN,
;  NOWD Y A LDX,
;  MEMD Y CMPX,
;  0<>, IF,
;   C INR,
;   A MEMD Y STX,
;  THEN,
;  DISTANCE 1+ Y A LDX,
;  A B MOV,
;  MEMDIST Y CMPX,
;  0<>, IF,
;   C INR,
;   A MEMDIST Y STX,
;  THEN,
;  C A MOV,
;  A ANA,
;  0=, IF,
;   VX Y E LDX,
;   VX 1+ Y D LDX,
;   VY Y L LDX,
;   VY 1+ Y H LDX,
;   RET,
;  THEN,
;  CMDIR VLOGICSTAT Y SETX,
; -->
;
; { BLOCK 0150 }
; ( MORE CUTE CALCULATIONS )
; LABEL Txy
;  B A MOV,
;  BASEX Y L LDX,
;  BASEX 1+ Y H LDX,
;  DELTAX Y E LDX,
;  DELTAX 1+ Y D LDX,
;  HOTMPY CALL,
;  L VX Y STX,
;  H VX 1+ Y STX,
;  H PUSH,
;  BASEY Y L LDX,
;  BASEY 1+ Y H LDX,
;  DELTAY Y E LDX,
;  DELTAY 1+ Y D LDX,
;  HOTMPY CALL,
;  L VY Y STX,
;  H VY 1+ Y STX,
;  D POP,
;  RET,
; ASSEMBLE>
; -->
;
; CALCXY does "CALCulate X Y position of object from distance, base, and deltas"
L8764:  LD      C,$00
        LD      A,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        CP      (IY+$4F)        ; MEMR offset 79
        JR      Z,L8772                 ; (+$04) IF 0<> False skip
        INC     C
        LD      (IY+$4F),A      ; MEMR offset 79
L8772:  LD      A,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        CP      (IY+$50)        ; MEMC offset 80
        JR      Z,L877E                 ; (+$04) IF 0<> False skip
        INC     C
        LD      (IY+$50),A      ; MEMC offset 80
L877E:  LD      A,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        CP      (IY+$51)        ; MEMD offset 81
        JR      Z,L878A                 ; (+$04) IF 0<> False skip
        INC     C
        LD      (IY+$51),A      ; MEMD offset 81
L878A:  LD      A,(IY+$4B)      ; DISTANCE + 1 (75 + 1) = 76
        LD      B,A
        CP      (IY+$4E)        ; MEMDIST offset 78
        JR      Z,L8797                 ; (+$04) IF 0<> False skip
        INC     C
        LD      (IY+$4E),A      ; MEMDIST offset 78
L8797:  LD      A,C
        AND     A
        JR      NZ,L87A8                ; (+$0d) IF 0= False skip to THEN
        LD      E,(IY+$1C)      ; VX offset 28
        LD      D,(IY+$1D)      ; VXH offset 29
        LD      L,(IY+$1E)      ; VY offset 30
        LD      H,(IY+$1F)      ; VYH offset 31
        RET

; THEN set CMDIR bit 0 of VLOGICSTAT offset 36
L87A8:  SET     CMDIR,(IY+$24) ; set it
; Txy label does ( MORE CUTE CALCULATIONS ), or fall in ...
L87AC:  LD      A,B
        LD      L,(IY+$41)      ; BASEX offset 65
        LD      H,(IY+$42)      ; BASEXH offset 66
        LD      E,(IY+$45)      ; DELTAX offset 69
        LD      D,(IY+$46)      ; DELTAXH offset 70
        CALL    L871C           ; HOTMPY do "HL= INITIAL DISP, DE= DELTA, A= DIST"
        LD      (IY+$1C),L      ; VX offset 28
        LD      (IY+$1D),H      ; VXH offset 29
        PUSH    HL
        LD      L,(IY+$43)      ; BASEY offset 67
        LD      H,(IY+$44)      ; BASEYH offset 68
        LD      E,(IY+$47)      ; DELTAY offset 71
        LD      D,(IY+$48)      ; DELTAYH offset 72
        CALL    L871C           ; HOTMPY do "HL= INITIAL DISP, DE= DELTA, A= DIST"
        LD      (IY+$1E),L      ; VY offset 30
        LD      (IY+$1F),H      ; VYH offset 31
        POP     DE
        RET
; end of ( CALCULATE X Y POSITION OF OBJECT FROM DISTANCE, BASE, AND DELTAS)

; SETBASEPOS does ??
L87DA:  PUSH    BC
        PUSH    DE
        LD      C,$04           ; NBX constant 4
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      C,(HL)
        INC     HL
        LD      B,(HL)
        LD      (IY+$41),E      ; BASEX offset 65
        LD      (IY+$42),D      ; BASEXH offset 66
        LD      (IY+$1C),E      ; VX offset 28
        LD      (IY+$1D),D      ; VXH offset 29
        LD      (IY+$43),C      ; BASEY offset 67
        LD      (IY+$44),B      ; BASEYH offset 68
        LD      (IY+$1E),C      ; VY offset 30
        LD      (IY+$1F),B      ; VYH offset 31
        POP     DE
        POP     BC
        RET

; FREEZEBASE does ??
L8803:  XOR     A
        LD      (IY+$4A),A      ; DISTANCE offset 74
        LD      (IY+$4B),A      ; DISTANCEH offset 75
        LD      (IY+$4C),A      ; DELTADIST offset 76
        LD      (IY+$4D),A      ; DELTADISTH offset 77
        RET

; { BLOCK 0156 }
; ( ROUTINE TO ESTABLISH NEW BASE POSITIONS AND DELTAS )
; ( FIRST A SIGN ROUTINE )
; SUBR SGNA
;  A ANA,
;  0 A MVI,
;  RP,
;  A DCR,
;  RET,
;
; SGNA does "first A SiGN" routine
L8811:  AND     A
        LD      A,$00
        RET     P
        DEC     A
        RET

; SUBR NEWPATH
;  NOWR Y D LDX,
;  NOWC Y E LDX,
;  SETBASEPOS CALL,
;  NOWD Y A LDX,
;  MPL0 ADI,
;  A C MOV,
;  node^ CALL,
;  M A MOV,
;  A MAXDIST Y STX,
;  4 D LXI,
;  D DAD,
;  M A MOV,
;  A DELTAX Y STX,
;  SGNA CALL,
;  A DELTAX 1+ Y STX,
;  D DAD,
;  M A MOV,
;  A DELTAY Y STX,
;  SGNA CALL,
;  A DELTAY 1+ Y STX,
;  RET,
;
; NEWPATH does "establish NEW base positions and deltas" routine
L8817:  LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        CALL    L87DA           ; SETBASEPOS do ??
        LD      A,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        ADD     A,$08           ; MPL0 constant 8 for ??
        LD      C,A
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      A,(HL)
        LD      (IY+$49),A      ; MAXDIST offset 73
        LD      DE,$0004
        ADD     HL,DE
        LD      A,(HL)
        LD      (IY+$45),A      ; DELTAX offset 69
        CALL    L8811           ; SGNA do "first A SiGN"
        LD      (IY+$46),A      ; DELTAXH offset 70
        ADD     HL,DE
        LD      A,(HL)
        LD      (IY+$47),A      ; DELTAY offset 71
        CALL    L8811           ; SGNA do "first A SiGN"
        LD      (IY+$48),A      ; DELTAYH offset 72
        RET

; ( ROUTINE TO CAUSE OBJECT TO ARRIVE AT A NEW POSITION )
; SUBR ARRIVE
;  NOWR Y D LDX,
;  NOWC Y E LDX,
;  NOWD Y C LDX,
;  move:node CALL,
;  D NOWR Y STX,
;  E NOWC Y STX,
;  SETBASEPOS CALL,
;  FREEZEBASE CALL,
;  RET,
; -->
;
; ARRIVE does "cause object to ARRIVE at a new position" routine
L8847:  LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      C,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        LD      (IY+$3E),D      ; NOWR offset 62 for ( CURRENT Row )
        LD      (IY+$3F),E      ; NOWC offset 63 for ( CURRENT Column )
        CALL    L87DA           ; SETBASEPOS do ??
        CALL    L8803           ; FREEZEBASE do ??
        RET
; end of { BLOCK 0156 } !!

; { BLOCK 0151 }
; ( DISTANCE PHASE ACCUMULATOR )
; ( DISTANCE HAS BOTH DELTA AND ACCELERATION )
; ( IN A= TIMEBASE TO USE )
; SUBR DISTPA
;  TBDEST TCHGSTAT Y BITX,
;  RNZ,
;  DISTANCE Y L LDX,
;  DISTANCE 1+ Y H LDX,
;  DELTADIST Y E LDX,
;  DELTADIST 1+ Y D LDX,
;  ( ACCDIST Y C LDX, ACCDIST 1+ Y B LDX, )
;  BEGIN,
;   D DAD,
;   ( XCHG,
;   B DAD,
;   XCHG, )
;   A DCR,
;  0=, END,
; ( IF BEYOND MAX DISTANCE, SET AT MAX DISTANCE AND FLAG )
;  MAXDIST Y A LDX,
;  A ANA,
;  0<>, IF,
;   H A MOV,
;   MAXDIST Y CMPX,
;   CY~, IF,
;    TBDEST TCHGSTAT Y SETX,
;    MAXDIST Y H LDX,
;    0 L MVI,
;   THEN,
;  THEN,
;  E DELTADIST Y STX,
;  D DELTADIST 1+ Y STX,
;  L DISTANCE Y STX,
;  H DISTANCE 1+ Y STX,
;  RET,
; -->
;
; DISTPA does "DISTance Phase Accumulator"
; note: ( DISTANCE HAS BOTH DELTA AND ACCELERATION )
L8860:  BIT     2,(IY+$12)      ; TBDEST bit 2 of TCHGSTAT offset 18
        RET     NZ
        LD      L,(IY+$4A)      ; DISTANCE offset 74
        LD      H,(IY+$4B)      ; DISTANCEH offset 75
        LD      E,(IY+$4C)      ; DELTADIST offset 76
        LD      D,(IY+$4D)      ; DELTADISTH offset 77
; BEGIN loop with ( ACCDIST Y C LDX, ACCDIST 1+ Y B LDX, ) ?? commented out
L8871:  ADD     HL,DE
; ( IN A= TIMEBASE TO USE ) with ( XCHG, B DAD, XCHG, ) ?? also commented out
        DEC     A               ; count down TIME BASE Number of loops
        JR      NZ,L8871                ; (-$04) END if 0= else to BEGIN
; ( IF BEYOND MAX DISTANCE, SET AT MAX DISTANCE AND FLAG )
        LD      A,(IY+$49)      ; MAXDIST offset 73
        AND     A
        JR      Z,L888A                 ; (+$0f) IF 0<> False skip
        LD      A,H
        CP      (IY+$49)        ; MAXDIST offset 73
        JR      C,L888A                 ; (+$09) IF CY~ False skip
        SET     2,(IY+$12)      ; TBDEST bit 2 of TCHGSTAT offset 18
        LD      H,(IY+$49)      ; MAXDIST offset 73
        LD      L,$00
L888A:  LD      (IY+$4C),E      ; DELTADIST offset 76
        LD      (IY+$4D),D      ; DELTADISTH offset 77
        LD      (IY+$4A),L      ; DISTANCE offset 74
        LD      (IY+$4B),H      ; DISTANCEH offset 75
        RET
; end of ( DISTANCE PHASE ACCUMULATOR ) !!

; { BLOCK 0164 }
; ( DISTANCE VECTORING ROUTINE AND VGER VERBS )
; 5 C= TB-DVECT ( TVMROPT2 BIT TO ACTIVATE DISTANCE VECTORING )
;
; SUBR DISTVECT
;  PSW PUSH,
;  B PUSH,
;  B A MOV,
;  DISTPA CALL,
;  CALCXY CALL,
;  B POP,
;  PSW POP,
;  RET,
;
; DISTVECT does "DISTance VECToring" routine
L8897:  PUSH    AF
        PUSH    BC
        LD      A,B
        CALL    L8860           ; DISTPA do "DISTance Phase Accumulator"
        CALL    L8764           ; CALCXY do "CALCulate X Y position of object"
        POP     BC
        POP     AF
        RET

; SUBR NEWVECT
;  TB-DVECT TVMROPT2 Y BITX,
;  vect JZ,
;  H PUSH,
;  CUSVEC Y L LDX,
;  CUSVEC 1+ Y H LDX,
;  XTHL,
;  RET,
;
; L88A3: NEWVECT ?? routine !! pre-EQUated for CALL from L18EA in Lower ROM !!
; (but ... only from mastervmr if TBNOVECT bit 5 of TVMROPT offset 16 set !!)
; note: TB-DVECT bit 5 is ( TVMROPT2 BIT TO ACTIVATE DISTANCE VECTORING )
        BIT     5,(IY+$11)      ; TB-DVECT bit 5 of TVMROPT2 offset 17
        JP      Z,L169D         ; if Distance Vectoring NOT activated to vect do ??
        PUSH    HL
        LD      L,(IY+$52)      ; CUSVEC offset 82 for ( CUSTom VECtor routine address )
        LD      H,(IY+$53)      ; CUSVECH offset 83 (word !!)
        EX      (SP),HL
        RET

; ?? NO Forth code generated ?? (U! mneans not used ??)
;
; NEWVECT JAYVECT 1+ U!
;

; CODE DVECT-OFF
;  Y PUSHX,
;  vaddr LIYD,
;  TB-DVECT TVMROPT2 Y RESX,
;  Y POPX,
; NEXT
;
; DVECT-OFF does "DE-ACTIVATE Distance Vectoring"
L88B3:  PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        RES     5,(IY+$11)      ; TB-DVECT bit 5 of TVMROPT2 offset 17
        POP     IY
        JP      (IY)            ; indexed RETurn

; CODE CV-ON
;  H POP,
;  Y PUSHX,
;  vaddr LIYD,
;  L CUSVEC Y STX,
;  H CUSVEC 1+ Y STX,
;  TB-DVECT TVMROPT2 Y SETX,
;  Y POPX,
; NEXT
;
; CV-ON does "write Custom Vector and ACTIVATE Distance Vectoring"
L88C1:  POP     HL
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      (IY+$52),L      ; CUSVEC offset 82 for ( CUSTom VECtor routine address )
        LD      (IY+$53),H      ; CUSVECH offset 83
        SET     5,(IY+$11)      ; TB-DVECT bit 5 of TVMROPT2 offset 17
        POP     IY
        JP      (IY)            ; indexed RETurn

; : DVECT-ON DISTVECT CV-ON ;
; -->
;
; DVECT-ON does "ACTIVATE Distance Vectoring"
L88D6:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; DISTVECT "pushWORD to System stack"
        DW      L8897           ; point to "DISTance VECToring"
        ;
        DW      L88C1           ; CV-ON do "write CUSVEC and ACTIVATE Distance Vectoring"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0164 } !!

; { BLOCK 0166 }
; ( CODE FOR TASKS TO INTERFACE TO NEW GOODIES )
; CODE ESTPOS
;  B PUSH,
;  Y PUSHX,
;  vaddr LIYD,
;  NOWC Y E LDX,
;  NOWR Y D LDX,
;  SETBASEPOS CALL,
;  FREEZEBASE CALL,
;  Y POPX,
;  B POP,
; NEXT
;
; ESTPOS does ??
L88DF:  PUSH    BC
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        CALL    L87DA           ; SETBASEPOS do ??
        CALL    L8803           ; FREEZEBASE do ??
        POP     IY
        POP     BC
        JP      (IY)            ; indexed RETurn

; CODE RNIT
;  B PUSH,
;  Y PUSHX,
;  vaddr LIYD,
;  NEWPATH CALL,
;  Y POPX,
;  B POP,
; NEXT
;
; RNIT does ??
L88F7:  PUSH    BC
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        CALL    L8817           ; NEWPATH do "establish NEW base positions and deltas"
        POP     IY
        POP     BC
        JP      (IY)            ; indexed RETurn

; ( TRAVEL AWAY FROM NODE )
; CODE DEPART:NODE
;  B PUSH,
;  Y PUSHX,
;  vaddr LIYD,
;  NEWPATH CALL,
;  Y POPX,
;  B POP,
; NEXT
;
; DEPART:NODE does "travel AWAY from NODE"
L8906:  PUSH    BC
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        CALL    L8817           ; NEWPATH do "establish NEW base positions and deltas"
        POP     IY
        POP     BC
        JP      (IY)            ; indexed RETurn

; ( ARRIVE NODE )
; CODE ARRIVE:NODE
;  B PUSH,
;  Y PUSHX,
;  vaddr LIYD,
;  ARRIVE CALL,
;  Y POPX,
;  B POP,
; NEXT
;
; ARRIVE:NODE does "ARRIVE at NODE"
L8915:  PUSH    BC
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        CALL    L8847           ; ARRIVE do "cause object to ARRIVE at a new position"
        POP     IY
        POP     BC
        JP      (IY)            ; indexed RETurn

; DATA CK8
;  0 B,
; -->
;
; L8924: CK8 ?? NOT a Null byte ?? for "ChecKsum Byte"
        DB      $95             ; spare "SUB  L"
; end of { CODE FOR TASKS TO INTERFACE TO NEW GOODIES } !!

; { BLOCK 0159 }
;  ( REVERSE DIRECTION ROUTINE )
; SUBR r:d
;  NOWR Y D LDX,
;  NOWC Y E LDX,
;  NOWD Y C LDX,
;  cxmove:node CALL,
;  C A MOV,
;  CMA,
;  3 ANI,
;  D NOWR Y STX,
;  E NOWC Y STX,
;  A NOWD Y STX,
;  NEWPATH CALL,
;  MAXDIST Y H LDX,
;  0 L MVI,
;  DISTANCE Y E LDX,
;  DISTANCE 1+ Y D LDX,
;  A ANA,
;  D DSBC,
;  L DISTANCE Y STX,
;  H DISTANCE 1+ Y STX,
;  RET,
;
; r:d does "Reverse Direction" routine
L8925:  LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      C,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        LD      A,C
        CPL
        AND     $03
        LD      (IY+$3E),D      ; NOWR offset 62 for ( CURRENT Row )
        LD      (IY+$3F),E      ; NOWC offset 63 for ( CURRENT Column )
        LD      (IY+$40),A      ; NOWD offset 64 for ( CURRENT Direction )
        CALL    L8817           ; NEWPATH do "establish NEW base positions and deltas"
        LD      H,(IY+$49)      ; MAXDIST offset 73
        LD      L,$00
        LD      E,(IY+$4A)      ; DISTANCE offset 74
        LD      D,(IY+$4B)      ; DISTANCEH offset 75
        AND     A
        SBC     HL,DE
        LD      (IY+$4A),L      ; DISTANCE offset 74
        LD      (IY+$4B),H      ; DISTANCEH offset 75
        RET

; CODE R:D
;  B PUSH,
;  Y PUSHX,
;  vaddr LIYD,
;  r:d CALL,
;  Y POPX,
;  B POP,
; NEXT
; -->
;
; R:D does "Reverse Direction" from TERSE
L8956:  PUSH    BC
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        CALL    L8925           ; r:d do "Reverse Direction"
        POP     IY
        POP     BC
        JP      (IY)            ; indexed RETurn
; end of ( REVERSE DIRECTION ROUTINES ) !!

; { BLOCK 0161 }
; ( COMPUTE DELTAS FOR STORAGE ROUTINE )
; ( THIS ROUTINE COMPUTES DELTA FOR ONE COORDINATE )
; SUBR CDEL1 ( DE=R,C B=COORD PTR, C=DIR )
;  B PUSH,
;  D PUSH,
;  B PUSH,
;  C A MOV,
;  MPL0 ADI,
;  A C MOV,
;  node^ CALL,
;  M L MOV,
;  0 H MVI,
;  B POP,
;  L A MOV,
;  A ANA,
;  0<>, IF,
;   H PUSH,
;   D PUSH,
;   move:node CALL,
;   B C MOV,
;   node^ CALL,
;   M E MOV,
;   H INX,
;   M D MOV,
;   XCHG,
;   XTHL,
;   XCHG,
;   node^ CALL,
;   M C MOV,
;   H INX,
;   M B MOV,
;   H POP, ( TARGET )
;   D POP, ( TIME )
;   CDELTA CALL,
;   E A MOV,
;  THEN,
;  D POP,
;  B POP,
;  A B MOV,
;  RET,
; -->
;
; CDEL1 does "Compute a DELta for storage" routine
; note: THIS ROUTINE COMPUTES DELTA FOR ONE COORDINATE
; inputs: ( DE=R,C B=COORD PTR, C=DIR )
L8965:  PUSH    BC
        PUSH    DE
        PUSH    BC
        LD      A,C
        ADD     A,$08           ; MPL0 constant 8 for ??
        LD      C,A
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      L,(HL)
        LD      H,$00
        POP     BC
        LD      A,L
        AND     A
        JR      Z,L8992                 ; (+$1b) IF 0<> False skip to THEN
        PUSH    HL
        PUSH    DE
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        LD      C,B
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        EX      DE,HL
        EX      (SP),HL
        EX      DE,HL
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      C,(HL)          ; for START
        INC     HL
        LD      B,(HL)
        POP     HL              ; for ( TARGET )
        POP     DE              ; for ( TIME )
        CALL    L858B           ; CDELTA do "Compute DELTA for 1 coordinate"
        LD      A,E
L8992:  POP     DE              ; THEN
        POP     BC
        LD      B,A
        RET
; end of ( COMPUTE DELTAS FOR STORAGE ROUTINE ) !!

; { BLOCK 0162 }
; ( SET DELTAS FOR BOTH COORDINATES FOR A GIVEN PATH )
; SUBR SETDELTS
;  NBX B MVI,
;  CDEL1 CALL,
;  B PUSH,
;  C A MOV,
;  NDX0 ADI,
;  A C MOV,
;  node^ CALL,
;  B M MOV,
;  B POP,
;  NBY B MVI,
;  CDEL1 CALL,
;  B PUSH,
;  C A MOV,
;  NDY0 ADI,
;  A C MOV,
;  node^ CALL,
;  B M MOV,
;  B POP,
;  RET,
;
; SETDELTS does "SET DELTaS for BOTH coordinates for a given path" routine
L8996:  LD      B,$04           ; NBX constant 4
        CALL    L8965           ; CDEL1 do "Compute DELta X for storage"
        PUSH    BC
        LD      A,C
        ADD     A,$0C           ; NDX0 constant 12
        LD      C,A
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      (HL),B
        POP     BC
        LD      B,$06           ; NBY constant 6
        CALL    L8965           ; CDEL1 do "Compute DELta Y for storage"
        PUSH    BC
        LD      A,C
        ADD     A,$10           ; NDY0 constant 16
        LD      C,A
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      (HL),B
        POP     BC
        RET

; ?? not given ??
;
; ( CODE XADJ
;  H POP,
;  xadj CALL,
;  H PUSH,
; NEXT )
;
; XADJ does "convert Screen +/- X to Bytes offset from Left side" from FORTH ??
L89B5:  POP     HL
        CALL    L1A65           ; xadj do "convert Screen +/- X REL to Bytes offset from Left"
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; XC? IFTRUE
;  <STK
;
;  CODE YADJ
;   H POP,
;   yadj CALL,
;   H PUSH,
;  NEXT
;
;  STK>
; IFEND
; -->
;
; YADJ does "convert +/- Y to PIXEL lines from the Top of Screen" from FORTH
L89BC:  POP     HL
        CALL    L1AC5           ; yadj does "convert +/- Y REL to PIXEL lines from Top of Screen"
        PUSH    HL
        JP      (IY)            ; indexed RETurn
; end of ( SET DELTAS FOR BOTH COORDINATES FOR A GIVEN PATH ) !!

; { BLOCK 0084 }
; ( COMPUTE DISTANCES )
; SUBR CDD
;  noder^ CALL,
;  M A MOV,
;  A ANA,
;  RZ,
;  B PUSH,
;  D PUSH,
;  GMRC SDED,
;  C A MOV,
;  GMD STA,
;  move:node CALL,
;  GMNRC SDED,
;  NODX C MVI,
;  GMRC LDED,
;  node^ CALL,
;  M E MOV,
;  H INX,
;  M D MOV,
;  H INX,
;  RCX SDED,
;  M E MOV,
;  H INX,
;  M D MOV,
;  RCY SDED,
;  GMNRC LDED,
;  node^ CALL,
;  M E MOV,
;  H INX,
;  M D MOV,
;  H INX,
;  NRCX SDED,
;  M E MOV,
;  H INX,
;  M D MOV,
;  NRCY SDED,
; -->
;
; { BLOCK 0143 }
; ( COMPUTE DISTANCE )
;  RCY LHLD,
;  A ANA,
;  D DSBC,
;  L A MOV,
;  SQUARE CALL,
;  H PUSH,
;  NRCX LDED,
;  RCX LHLD,
;  A ANA,
;  D DSBC,
;  L A MOV,
;  SQUARE CALL,
;  D POP,
;  D DAD,
;  sqrt CALL,
;  A B MOV, ( B= DIST )
;  GMRC LDED,
;  GMD LDA,
;  MPL0 ADI,
;  A C MOV,
;  node^ CALL,
;  B M MOV,
;  GMD LDA,
;  CMA,
;  3 ANI,
;  MPL0 ADI,
;  A C MOV,
;  GMNRC LDED,
;  node^ CALL,
;  B M MOV,
;  D POP,
;  B POP,
;  RET,
;
; CDD does "COMPute Distances" routine
L89C3:  CALL    L8696           ; noder^ do ??
        LD      A,(HL)
        AND     A
        RET     Z
        PUSH    BC
        PUSH    DE
        LD      ($EEA3),DE      ; GMRC write "Generate Matrix Row and Column" Variable in Static RAM
        LD      A,C
        LD      ($EEA1),A       ; GMD write "Generate Matrix Distance" Variable in Static RAM
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        LD      ($EE9F),DE      ; GMNRC write "Generate Matrix NRC ??" Variable in Static RAM
        LD      C,$00           ; NODX constant 0 for ??
        LD      DE,($EEA3)      ; GMRC read "Generate Matrix Row and Column" Variable in Static RAM
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      ($EE9D),DE      ; RCX write Word ?? into ?? in Static RAM
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        LD      ($EE9B),DE      ; RCY write Word ?? into ?? in Static RAM
        LD      DE,($EE9F)      ; GMNRC read "Generate Matrix NRC ??" Variable in Static RAM
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      ($EE99),DE      ; NRCX write Word ?? into ?? in Static RAM
        LD      E,(HL)
        INC     HL
; ( COMPUTE DISTANCE )
        LD      D,(HL)
        LD      ($EE97),DE      ; NRCY write Word ?? into ?? in Static RAM
        LD      HL,($EE9B)      ; RCY read Word ?? for ?? in Static RAM
        AND     A
        SBC     HL,DE
        LD      A,L
        CALL    L8759           ; SQUARE do ??
        PUSH    HL
        LD      DE,($EE99)      ; NRCX read Word ?? for ?? in Static RAM
        LD      HL,($EE9D)      ; RCX read Word ?? for ?? in Static RAM
        AND     A
        SBC     HL,DE
        LD      A,L
        CALL    L8759           ; SQUARE do ??
        POP     DE
        ADD     HL,DE
        CALL    L85A7           ; sqrt do "new SQuare RooT"
        LD      B,A             ; ( B= DISTance )
        LD      DE,($EEA3)      ; GMRC read "Generate Matrix Row and Column" Variable in Static RAM
        LD      A,($EEA1)       ; GMD read "Generate Matrix Distance" Variable in Static RAM
        ADD     A,$08           ; MPL0 constant 8 for ??
        LD      C,A
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      (HL),B
        LD      A,($EEA1)       ; GMD read "Generate Matrix Distance" Variable in Static RAM again
        CPL
        AND     $03
        ADD     A,$08           ; MPL0 constant 8 for ??
        LD      C,A
        LD      DE,($EE9F)      ; GMNRC read "Generate Matrix NRC ??" Variable in Static RAM
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      (HL),B
        POP     DE
        POP     BC
        RET

; last of { BLOCK 0143 } !!
; F= Cdl
; CODE C-DST
; <ASSEMBLE
;  B PUSH,
;  0 D LXI,
;  0 C MVI,
; LABEL Cdl
;  CDD CALL,
;  C A MOV,
;  A INR,
;  A C MOV,
;  4 CPI,
;  Cdl JRNZ,
;  0 C MVI,
;  E A MOV,
;  A INR,
;  A E MOV,
;  NCOLS CPI,
;  Cdl JRNZ,
;  0 E MVI,
;  D A MOV,
;  A INR,
;  A D MOV,
;  NROWS CPI,
;  Cdl JRNZ,
;  B POP,
; NEXT
; ASSEMBLE>
; -->
;
; C-DST does "Compute DiSTances" from Forth
L8A49:  PUSH    BC
        LD      DE,$0000        ; 0 for ??
        LD      C,$00
; Cdl label
L8A4F:  CALL    L89C3           ; CDD do "COMPute Distances"
        LD      A,C
        INC     A
        LD      C,A
        CP      $04
        JR      NZ,L8A4F                ; (-$0a) if ?? to Cdl
        LD      C,$00
        LD      A,E
        INC     A
        LD      E,A
        CP      $0B             ; NCOLS constant 11
        JR      NZ,L8A4F                ; (-$13)
        LD      E,$00
        LD      A,D
        INC     A
        LD      D,A
        CP      $06             ; NROWS constant 6
        JR      NZ,L8A4F                ; (-$1c)
        POP     BC
        JP      (IY)            ; indexed RETurn
; end of ( COMPUTE DISTANCES )

; { BLOCK 0163 }
; ( COMPUTE DELTAS FOR WHOLE MATRIX )
; CODE MAKEDELTS
;  B PUSH,
;  0 D LXI,
;  0 C MVI,
;  BEGIN,
;   BEGIN,
;    BEGIN,
;     SETDELTS CALL,
;     C A MOV,
;     A INR,
;     A C MOV,
;     4 CPI,
;    0=, END,
;    0 C MVI,
;    E A MOV,
;    A INR,
;    A E MOV,
;    NCOLS CPI,
;   0=, END,
;   0 E MVI,
;   D A MOV,
;   A INR,
;   A D MOV,
;   NROWS CPI,
;  0=, END,
;  B POP,
; NEXT
;
; MAKEDELTS does "compute DELTaS for whole matrix"
L8A6E:  PUSH    BC
        LD      DE,$0000        ; 0 for ??
        LD      C,$00
; BEGIN 3 loops for ??
L8A74:  CALL    L8996           ; SETDELTS do "SET DELTaS for BOTH coordinates"
        LD      A,C
        INC     A
        LD      C,A
        CP      $04
        JR      NZ,L8A74                ; (-$0a) END if 0= else to BEGIN
        LD      C,$00
        LD      A,E
        INC     A
        LD      E,A
        CP      $0B             ; NCOLS constant 11
        JR      NZ,L8A74                ; (-$13) END if 0= else to BEGIN
        LD      E,$00
        LD      A,D
        INC     A
        LD      D,A
        CP      $06             ; NROWS constant 6
        JR      NZ,L8A74                ; (-$1c) END if 0= else to BEGIN
        POP     BC
        JP      (IY)            ; indexed RETurn

; : FIXVGER NCOLS 0 DO NROWS 0 DO
; J I NODX NODE@ XADJ J I NBX NODE!
; J I NODY NODE@ YADJ J I NBY NODE! LOOP LOOP ;
;
; FIXVGER does ??
L8A93:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; NCOLS "pushBYTE to System stack"
        DB      $0B             ; constant 11 for "Number of COLumnS"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; TerseDO Loop #1 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L00C5           ; NROWS "pushBYTE to System stack"
        DB      $06             ; constant 6 for "Number of ROWS"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; _TerseDO Loop #2 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; NODX "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L86F4           ; NODE@ do ??
        ;
        DW      L89B5           ; XADJ do "convert Screen +/- X to Bytes offset from Left side"
        ;
        DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; NBX "pushBYTE to System stack"
        DB      $04             ; constant 4 for ??
        ;
        DW      L86ED           ; NODE! do ??
        ;
        DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; NODY "pushBYTE to System stack"
        DB      $02             ; constant 2 for ??
        ;
        DW      L86F4           ; NODE@ do ??
        ;
        DW      L89BC           ; YADJ do "convert +/- Y to PIXEL lines from the Top of Screen"
        ;
        DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; NBY "pushBYTE to System stack"
        DB      $06             ; constant 6 for ??
        ;
        DW      L86ED           ; NODE! do ??
        ; _TerseLOOP #2 back to TerseDO #2 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" (inner DO)
        ; TerseLOOP #1 back to TerseDO #1 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" (outer DO)
        ;
        DW      L00B0           ; ... TerseRETurn

; : MD FIXVGER C-DST MAKEDELTS ;
; -->
;
; MD does ??
L8AD0:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L8A93           ; FIXVGER do ??
        ;
        DW      L8A49           ; C-DST do "Compute DiSTances"
        ;
        DW      L8A6E           ; MAKEDELTS do "compute DELTaS for whole matrix"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0163 } !!

; { BLOCK 0221 }
; HEX
; SUBR SLEZR2A ( does pat offset and relabs )
; ( in- BC= magic/exp , HL= y , DE= x , IX= pattern addr )
; ( out- HL= new vscradr , C= new vmagic )
;  invertxy? CALL,
;  invert? CALL,
;  L SLAR,
;  H RALR,
;  L SLAR,
;  H RALR,
;  H PUSH,
;  XCHG,
;  0 X D LDX,
;  0 E MVI, ( x offset )
;  D SRAR,
;  E RARR,
;  D SRAR,
;  E RARR, ( /4 for x offset )
;  MRFLOP C BIT,
;  0<>, IF,
;   D DAD,
;  ELSE,
;   A ORA,
;   D DSBC,
;  THEN,
;  XTHL, ( push X+off, HL<-Y )
;  1 X D LDX,
;  0 E MVI, ( y offset )
;  MRFLIP C BIT,
;  0<>, IF,
;   D DAD,
;   H DCX,
;  ELSE,
;   A ORA,
;   D DSBC,
;  THEN,
;  D POP,
;  H A MOV,
;  0 H MVI,
;  A L MOV,
;  H DAD,
;  H DAD,
;  H DAD,
;  H DAD,
;  D PUSH,
;  L E MOV,
;  H D MOV,
;  H DAD,
;  H DAD, ( *64 )
;  D DAD, ( *80 )
;  XCHG,
;  H POP, ( x )
;  L A MOV, ( SAVE BIT CNT )
;  H L MOV,
;  0 H MVI,
;  D DAD, ( x+y )
; -->
;
; { BLOCK 0222 }
; ( VMR )
; ( y can not get here larger then 256 )
;  RLC,
;  RLC,
;  3 ANI,
;  MRFLOP C BIT,
;  0<>, IF,
;   NEG,
;   0=, IF,
;    H DCX,
;   THEN,
;  THEN,
;  3 ANI,
;  A E MOV,
;  invert? CALL, ( FLIPPER BACK )
;  C A MOV,
;  FC ANI,
;  E ORA,
;  A C MOV, ( HL= screen address )
;  RET,
;
; SLEZR2A does "SCALE DOWN Full-Scale X and Y locations from TUNNELS and various ITEMS (multi-part)""
; notes: ( does pat offset and relabs )
; ( in- BC= magic/exp , HL= y , DE= x , IX= pattern addr )
; ( out- HL= new vscradr , C= new vmagic )
L8AD9:  CALL    L0588           ; invertxy? du "read CABINet mode and if Not 0 do Full-Scale INVERT"
        CALL    L057E           ; invert? du "read CABINet mode and if Not 0 set MRFLOP and MRFLIP"
        SLA     L               ; times 4 for ??
        RL      H
        SLA     L
        RL      H
        PUSH    HL
        EX      DE,HL
        LD      D,(IX+$00)      ; read X Hot Spot offset
        LD      E,$00           ; ( X offset )
        SRA     D
        RR      E
        SRA     D
        RR      E               ; ( divide by 4 for X offset )
        BIT     MRFLOP,C        ; is MAGIC FLOP bit 6 set ?
        JR      Z,L8AFD                 ; (+$03) IF 0<> False skip to ELSE no
        ADD     HL,DE           ; else X plus Byte 1/4 X Hot Spot
        JR      L8B00                   ; (+$03) THEN to resume

; ELSE ?? NOT FLOPped
L8AFD:  OR      A               ; then X minus Byte 1/4 X Hot Spot
        SBC     HL,DE
; THEN ?? resume here
L8B00:  EX      (SP),HL         ; ( push X+off, HL<-Y )
        LD      D,(IX+$01)
        LD      E,$00           ; ( Y offset )
        BIT     MRFLIP,C        ; is MAGIC FLIP bit 7 set ?
        JR      Z,L8B0E                 ; (+$04) IF 0<> False skip to ELSE no
        ADD     HL,DE           ; else Y plus Byte Y Hot Spot MINUS 1
        DEC     HL
        JR      L8B11                   ; (+$03) to THEN resume

; ELSE ?? NOT FLIPped
L8B0E:  OR      A               ; then Y minus Byte Y Hot Spot
        SBC     HL,DE
L8B11:  POP     DE              ; THEN resume here
        LD      A,H             ; divide by 16 for ??
        LD      H,$00
        LD      L,A
        ADD     HL,HL           ; times 80 for BPLINE
        ADD     HL,HL
        ADD     HL,HL
        ADD     HL,HL
        PUSH    DE
        LD      E,L
        LD      D,H
        ADD     HL,HL
        ADD     HL,HL           ; ( *64 )
        ADD     HL,DE           ; ( *80 )
        EX      DE,HL           ; return TOP Line in DE
        POP     HL              ; restore ( X ) location times 8,
        LD      A,L             ; ( SAVE BIT CNT ) quick-divide by 16
        LD      L,H
        LD      H,$00
        ADD     HL,DE           ; ( X+Y ) merge X and Y (for ABSOLUTE Address ??)
; VMR ( y can not get here larger then 256 )
        RLCA                    ; Circulate Top 2 bits of ??, then
        RLCA
        AND     $03             ; Mask only Bottom 2 SHIFT bits
        BIT     MRFLOP,C        ; is MAGIC FLOP bit 6 set ?
        JR      Z,L8B34                 ; (+$05) IF 0<> False skip to THEN no
        NEG                     ; if FLOPped, -SHIFT and
        JR      NZ,L8B34                ; (+$01) IF 0= False skip to THEN on ??
        DEC     HL              ; if 0 SHIFT a whole byte LEFT
L8B34:  AND     $03             ; THEN mask off SHIFT bits again
        LD      E,A             ; and ( FLIPPER BACK )
        CALL    L057E           ; invert? du "read CABINet mode and if Not 0 set MRFLOP and MRFLIP"
        LD      A,C
        AND     $FC             ; mask SHIFT bits OFF
        OR      E               ; mix SHIFT bits back in
        LD      C,A             ; return C = new MAGIC register, and
        RET                     ; retURN ( HL= Word ABSOLUTE screen Address )
; end of ( SLEZR2A does pat offset and relabs ) !!

; CODE WRITEP
;  DI,
;  X PUSHX,
;  D POP,
;  EXX,
;  X POPX,
;  B POP,
;  H POP,
;  yadj CALL,
;  XTHL,
;  xadj CALL,
;  XCHG,
;  H POP, ( HL= Y DE= X )
;  SLEZR2A CALL,
;  X INXX,
;  X INXX,
;  0 X E LDX,
;  X INXX,
;  0 X D LDX,
;  X INXX,
;  write CALL,
;  EXX,
;  D PUSH,
;  X POPX,
; NEXT
; DECIMAL
; -->
;
; WRITEP does "Determine location and COPY Various ITEMS ?? in Game Play"
L8B40:  DI
        PUSH    IX
        POP     DE
        EXX
        POP     IX
        POP     BC
        POP     HL
        CALL    L1AC5           ; yadj does "convert +/- Y REL to PIXEL lines from Top of Screen"
        EX      (SP),HL
        CALL    L1A65           ; xadj do "convert Screen +/- X REL to Bytes offset from Left"
        EX      DE,HL
        POP     HL              ; ( HL= Y DE= X )
        CALL    L8AD9           ; SLEZR2A do "SCALE DOWN Full-Scale X and Y locations to ABSolute"
        INC     IX
        INC     IX
        LD      E,(IX+$00)      ; read 4-color ITEM Width in Bytes
        INC     IX
        LD      D,(IX+$00)      ; read 4-color ITEM Height in Rows
        INC     IX
        CALL    L125B           ; write (routine) do "Pattern Board handler to COPY ?? to Screen"
        EXX
        PUSH    DE
        POP     IX
        JP      (IY)            ; indexed RETurn
; end of ?? more than just WRITEP !!

; { BLOCK 0304 }
; SCON IFTRUE ( TASK TO DISPLAY PLAYER ONES SCORE )
;  : P1s ;TASK:
;  sc1l @ sc1h @ 0 AP1S 8 BIN->ASC
;  8 0 AP1S B!
;  0 AP1S 0SUPR 6 2 AP1S B!
;  -156 X! SC-Y Y! PLOP-ON 7 XPAND!-ON
;  2 AP1S PATTERN! EVEN-SPACE-NUMS
;  DI STRING ;
; IFEND -->
;
; P1s does "task to display Player ONEs Score"
L8B6C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L00BC           ; sc1l "pushWORD to System stack"
        DW      $E396           ; for Word "SCore p1 Low" in High WRITE-protected NV RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; sc1h "pushWORD to System stack"
        DW      $E394           ; for Word ( SCore p1 High ) in High WRITE-protected NV RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; AP1S "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $EEB4           ; for "Player 1 Score" 9-Byte Array in Static RAM
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L2125           ; BIN->ASC do "CONVERT BINary Number to ASCII Text String"
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; AP1S "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $EEB4           ; for "Player 1 Score" 9-Byte Array in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; AP1S "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $EEB4           ; for "Player 1 Score" 9-Byte Array in Static RAM
        ;
        DW      L213E           ; 0SUPR do "REPLACE Leading Zeroes with SPACEs in Text String"
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for ??
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00CD           ; AP1S "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $EEB4           ; for "Player 1 Score" 9-Byte Array in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF64           ; -156 for ??
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      L00C5           ; SC-Y "pushBYTE to System stack"
        DB      $5B             ; constant 91 for ??
        ;
        DW      L1D10           ; Y! do ??
        ;
        DW      L1E97           ; PLOP-ON do "Turn OR and X-OR writes OFF in Magic ??"
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for Color 1 on Color 3
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00CD           ; AP1S "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $EEB4           ; for "Player 1 Score" 9-Byte Array in Static RAM
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L1F52           ; EVEN-SPACE-NUMS do "load $FE3C with Byte 6 for ??"
        ;
        DW      L0538           ; DI do "Disable Interrupt"
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of  ( TASK TO DISPLAY PLAYER ONES SCORE ) !!

; { BLOCK 0305 }
; SCON IFTRUE ( TASK TO DISPLAY PLAYER TWOS SCORE )
;  : P2s ;TASK:
;  sc2l @ sc2h @ 0 AP2S 8 BIN->ASC
;  8 0 AP2S B!
;  0 AP2S 0SUPR 6 2 AP2S B!
;  108 X! SC-Y Y! PLOP-ON 7 XPAND!-ON
;  2 AP2S PATTERN! EVEN-SPACE-NUMS
;  DI STRING ;
;
; P2s does "task to display Player TWOs Score"
L8BC2:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L00BC           ; sc2l "pushWORD to System stack"
        DW      $E392           ; for Word "SCore p2 Low" in High WRITE-protected NV RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; sc2h "pushWORD to System stack"
        DW      $E390           ; for Word ( SCore p2 High ) in High WRITE-protected NV RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; AP2S "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $EEAB           ; for "Player 2 Score" 9-Byte Array in Static RAM
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L2125           ; BIN->ASC do "CONVERT BINary Number to ASCII Text String"
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; AP2S "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $EEAB           ; for "Player 2 Score" 9-Byte Array in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; AP2S "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $EEAB           ; for "Player 2 Score" 9-Byte Array in Static RAM
        ;
        DW      L213E           ; 0SUPR do "REPLACE Leading Zeroes with SPACEs in Text String"
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for ??
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00CD           ; AP2S "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $EEAB           ; for "Player 2 Score" 9-Byte Array in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $6C             ; 108 for ??
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      L00C5           ; SC-Y "pushBYTE to System stack"
        DB      $5B             ; constant 91 for ??
        ;
        DW      L1D10           ; Y! do ??
        ;
        DW      L1E97           ; PLOP-ON do "Turn OR and X-OR writes OFF in Magic ??"
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for ?? Color 1 on Color 3
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00CD           ; AP2S "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $EEAB           ; for "Player 2 Score" 9-Byte Array in Static RAM
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L1F52           ; EVEN-SPACE-NUMS do "load $FE3C with Byte 6 for ??"
        ;
        DW      L0538           ; DI do "Disable Interrupt"
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00B0           ; ... TerseRETurn

;  : B1s sc1l @ sc1h @ D+ sc1h WP! sc1l WP! ;
;
; B1s does ??
L8C17:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; sc1l "pushWORD to System stack"
        DW      $E396           ; for Word "SCore p1 Low" in High WRITE-protected NV RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; sc1h "pushWORD to System stack"
        DW      $E394           ; for Word ( SCore p1 High ) in High WRITE-protected NV RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L2074           ; D+ do ??
        ;
        DW      L00BC           ; sc1h "pushWORD to System stack"
        DW      $E394           ; for Word ( SCore p1 High ) in High WRITE-protected NV RAM
        ;
        DW      L07D8           ; WP! do "WRITE-protectedWORD" (SP+2) into (SP) & (SP)-513
        ;
        DW      L00BC           ; sc1l "pushWORD to System stack"
        DW      $E396           ; for Word "SCore p1 Low" in High WRITE-protected NV RAM
        ;
        DW      L07D8           ; WP! do "WRITE-protectedWORD" (SP+2) into (SP) & (SP)-513
        ;
        DW      L00B0           ; ... TerseRETurn

;  : B2s sc2l @ sc2h @ D+ sc2h WP! sc2l WP! ;
;
; B2s does ??
L8C34:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; sc2l "pushWORD to System stack"
        DW      $E392           ; for Word "SCore p2 Low" in High WRITE-protected NV RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; sc2h "pushWORD to System stack"
        DW      $E390           ; for Word ( SCore p2 High ) in High WRITE-protected NV RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L2074           ; D+ do ??
        ;
        DW      L00BC           ; sc2h "pushWORD to System stack"
        DW      $E390           ; for Word ( SCore p2 High ) in High WRITE-protected NV RAM
        ;
        DW      L07D8           ; WP! do "WRITE-protectedWORD" (SP+2) into (SP) & (SP)-513
        ;
        DW      L00BC           ; sc2l "pushWORD to System stack"
        DW      $E392           ; for Word "SCore p2 Low" in High WRITE-protected NV RAM
        ;
        DW      L07D8           ; WP! do "WRITE-protectedWORD" (SP+2) into (SP) & (SP)-513
        ;
        DW      L00B0           ; ... TerseRETurn

;  : S*? SC* B@ DUP IF 1+ * ELSE DROP THEN ;
;
; S*? does "get (SP) * CURRENT (SCore MULT + 1)" returns 0 if "SCore MULT" is 0 !!
L8C51:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L074B           ; SC* do "get SCore MULT for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ; IF False to ELSE
        DW      L03CD,L8C64     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ; (done so Jump to THEN)
        DW      L03C5,L8C66     ; TerseJUMP to ??
        ; ELSE
L8C64:  DW      L00F6           ; DROP do "Pop HL from System stack"
        ; THEN
L8C66:  DW      L00B0           ; ... TerseRETurn

;  : IS-D NERDUP IF B2s ELSE B1s THEN ;
;
; IS-D does ??
L8C68:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ; IF False to ELSE
        DW      L03CD,L8C75     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L8C34           ; B2s do ??
        ; (done so Jump to THEN)
        DW      L03C5,L8C77     ; TerseJUMP to ??
        ; ELSE
L8C75:  DW      L8C17           ; B1s do ??
        ; THEN
L8C77:  DW      L00B0           ; ... TerseRETurn

;  : US-S NERDUP IF SCV P2s ELSE SCV P1s THEN ;
;
; US-S does ??
L8C79:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ; IF False to ELSE
        DW      L03CD,L8C8A     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; SCV "pushWORD to System stack"
        DW      $F285           ; for "?? Vector" base in Static RAM
        ;
        DW      L8BC2           ; P2s do "task to display Player TWOs Score"
        ; (done so Jump to THEN)
        DW      L03C5,L8C90     ; TerseJUMP to ??
        ; ELSE
L8C8A:  DW      L00BC           ; SCV "pushWORD to System stack"
        DW      $F285           ; for "?? Vector" base in Static RAM
        ;
        DW      L8B6C           ; P1s do "task to display Player ONEs Score"
        ; THEN
L8C90:  DW      L00B0           ; ... TerseRETurn

;  : PATTY 0 IS-D US-S ;
;
; PATTY does ??
L8C92:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L8C68           ; IS-D do ??
        ;
        DW      L8C79           ; US-S do ??
        ;
        DW      L00B0           ; ... TerseRETurn

;  : INCSCORE S*? PATTY ;
; IFEND
; -->
;
; { BLOCK 0072 }
; ( SCORING DUMMIES )
; SCON NOT IFTRUE
;  : INCSCORE DROP ;
;  : IS-D 2DROP ;
; IFEND
;
; INCSCORE does "INCrement SCORE times (SCore MULT + 1)" or 0 if "SCore MULT" is 0 !!
L8C9B:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L8C51           ; S*? do "get (SP) * CURRENT (SCore MULT + 1)"
        ;
        DW      L8C92           ; PATTY do ??
        ;
        DW      L00B0           ; ... TerseRETurn
; ( SCORING DUMMIES ) not used since SCON ( Scoring ON flag ) IFTRUE is ON !!
; end of Scoring routines !!

; : TBCL 0 TIMEBSCALE! ZEROTIMEB ;
;
; TBCL does ??
L8CA2:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L1F0A           ; TIMEBSCALE! do ??
        ;
        DW      L1EDC           ; ZEROTIMEB do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; SCON IFTRUE
;  : GO-T ;TASK: BEGIN TBCL -36 X! 78 Y!
;   NORMAL-SPACING 4 XPAND!-ON A" GAME OVER" PATTERN!
;   XOR-ON DI STRING 20 TIMER!-ON WAIT 0 END ;
; OTHERWISE
;  : GO-T DROP ;
; IFEND
; -->

; GO-T does ??
L8CAB:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ; BEGIN loop
L8CAE:  DW      L8CA2           ; TBCL do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFDC           ; -36 for ??
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $4E             ; 78 for ??
        ;
        DW      L1D10           ; Y! do ??
        ;
        DW      L1F49           ; NORMAL-SPACING do "load $FE3C with Byte 0 for ??"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ?? Color 1 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L03E7           ; A" do Terse SKIP RELative by next Byte (counts
        DB      $09,"GAME OVER" ; over) embedded Text String" to END GAME with
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L0538           ; DI do "Disable Interrupt"
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; END or loop to BEGIN if False
        DW      L03CD,L8CAE     ; if 0 END else to BEGIN ConditionalJUMP
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0072 } !!

; { BLOCK 0244 }
; ( PLAYER UP DISPLAY TASK )
; XC? IFTRUE
;  : PU-T ;TASK: TBCL -72 X! 0 Y!
;  68 XPAND!-ON #PLA B@ NOT IF A" GET READY" ELSE
;  NERDUP IF A" PLAYER 2 UP" ELSE A" PLAYER 1 UP" THEN THEN
;  PATTERN! XOR-ON DI STRING VGER-OUT ;
; OTHERWISE : PU-T ;TASK: VGER-OUT ; IFEND
;
; PU-T does "Player Up display Task"
L8CE4:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L8CA2           ; TBCL do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB8           ; -72 for ??
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L1D10           ; Y! do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $44             ; 68 for Double-sized Color 1 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; #PLA "pushWORD to System stack"
        DW      $E39A           ; for ( # of PLAyers-1 ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; IF False skip to THEN #1
        DW      L03CD,L8D14     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L03E7           ; A" do Terse SKIP RELative by next Byte (counts
        DB      $09,"GET READY" ; over) embedded Text String" to START GAME with
        ;
        DW      L03C5,L8D3A     ; TerseJUMP to ??
        ; THEN #1
L8D14:  DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ; IF False to ELSE #2
        DW      L03CD,L8D2C     ; ConditionalJUMP to choose PLAYER 1 message IF not FLOPped
        ;
        DW      L03E7           ; A" do Terse SKIP RELative by next Byte (counts
        DB      $0B,"PLAYER 2 UP" ; over) embedded Text String" to START LEVEL with
        ; (done so Jump to THEN #2)
        DW      L03C5,L8D3A     ; TerseJUMP with PLAYER 2 message only IF in COCKTAIL mode
        ; ELSE #2
L8D2C:  DW      L03E7           ; A" do Terse SKIP RELative by next Byte (counts
        DB      $0B,"PLAYER 1 UP" ; over) embedded Text String" START LEVEL with
        ; THEN #2
L8D3A:  DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L0538           ; DI do "Disable Interrupt"
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L221F           ; VGER-OUT do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; ( TOGGLE:LIFE, DISPLAY REMAINING LIVES, AND BITE DUST )
; : RTw ROTO WRITEP ;
;
; RTw does "toggle:life ??, display Remaining LIVES, and bite dust (Terminate !!)"
L8D46:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; ROTO "pushWORD to System stack"
        DW      L2DCD           ; point to Robby Roto (facing LEFT with 2 FEET) pattern
        ;
        DW      L8B40           ; WRITEP do "Determine location and COPY Remaining ROBBY ROTO"
        ;
        DW      L00B0           ; ... TerseRETurn

; : THIS:LIFE RR# B@ 4 MIN 1- ;
;
; THIS:LIFE does ??
L8D4F:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0742           ; RR# do "get Robby Rotos left for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L0155           ; 1- do "DECrement Top of System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; : RPT1 16 * -100 + RP-Y ;
;
; RPT1 does ??
L8D5C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $10             ; 16 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF9C           ; -100 for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00C5           ; RP-Y "pushBYTE to System stack"
        DB      $52             ; constant 82 for ??
        ;
        DW      L00B0           ; ... TerseRETurn

; : RPT2 16 * 100 SWAP - RP-Y ;
;
; RPT2 does ??
L8D6D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $10             ; 16 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $64             ; 100 for ??
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00C5           ; RP-Y "pushBYTE to System stack"
        DB      $52             ; constant 82 for ??
        ;
        DW      L00B0           ; ... TerseRETurn

; : ROTOPOS NERDUP IF RPT2 ELSE RPT1 THEN ;
; -->
;
; ROTOPOS does ??
L8D7F:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ; IF False to ELSE
        DW      L03CD,L8D8C     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L8D6D           ; RPT2 do ??
        ; (done so Jump to THEN)
        DW      L03C5,L8D8E     ; TerseJUMP to ??
        ; ELSE
L8D8C:  DW      L8D5C           ; RPT1 do ??
        ; THEN
L8D8E:  DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0244 } !!

; { BLOCK 0266 }
; ( MOVE CHECKER AND ADD PATH GOODIES )
; HEX
; SUBR movecheck
;  D A MOV,
;  NROWS CPI,
;  RNC,
;  E A MOV,
;  NCOLS CPI,
;  RET,
;
; movecheck does "MOVE CHECKer" routine
L8D90:  LD      A,D
        CP      $06             ; NROWS constant 6
        RET     NC
        LD      A,E
        CP      $0B             ; NCOLS constant 11
        RET

; SUBR S-DF
;  B PUSH,
;  NODMSK C MVI,
;  node^ CALL,
;  NMEXS M SET,
;  B POP,
;  2 B BIT,
;  0<>, IF,
;   NMDRW M SET,
;  THEN,
;  RET,
;
; S-DF does "Set NODMSK path goodies" routine
L8D98:  PUSH    BC
        LD      C,$18           ; NODMSK constant 24 for ??
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        SET     7,(HL)          ; NMEXS bit 7 for ??
        POP     BC
        BIT     2,B
        JR      Z,L8DA7                 ; (+$02) IF 0<> False skip
        SET     0,(HL)          ; NMDRW bit number 0 for ??
L8DA7:  RET

; SUBR S-RD
;  2 B BIT,
;  0=, IF,
;   1 M MVI,
;  ELSE,
;   7F M MVI,
;  THEN,
;  RET,
; DECIMAL
; -->
;
; S-RD does "Set ?? path goodies" (either GMNRC or GMNRP) routine
L8DA8:  BIT     2,B
        JR      NZ,L8DB0                ; (+$04) IF 0<> False skip to ELSE
        LD      (HL),$01        ; write a 1 for Set bit 0 ?? (Clear others)
        JR      L8DB2                   ; (+$02) to THEN

L8DB0:  LD      (HL),$7F        ; ELSE write 127 for Set bits 0 through 6 ??
L8DB2:  RET                     ; THEN ...URN
; endn of { BLOCK 0266 } !!

; { BLOCK 0274 }
; ( ADD PATH ROUTINE ) ( THIS IS A MESS! )
; SUBR addpath ( B= DISTANCE TO CRAM IN )
;  noder^ CALL,
;  M A MOV,
;  A ANA,
;  RNZ,
;  GMNRP SHLD,
;  D PUSH,
;  move:node CALL,
;  GMNRC SDED,
;  D POP,
;  GMNRP LHLD,
;  S-RD CALL,
;  S-DF CALL,
;  C A MOV,
;  CMA,
;  3 ANI,
;  A C MOV,
;  GMNRC LDED,
;  noder^ CALL,
;  S-RD CALL,
;  S-DF CALL,
;  RET,
; -->
;
; addpath does "ADD a PATH" ( THIS IS A MESS! ) routine
; note: ( B= DISTANCE TO CRAM IN )
L8DB3:  CALL    L8696           ; noder^ do ??
        LD      A,(HL)
        AND     A
        RET     NZ
        LD      ($EEA5),HL      ; GMNRP write "Generate Matrix NRP ??" Variable in Static RAM
        PUSH    DE
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        LD      ($EE9F),DE      ; GMNRC write "Generate Matrix NRC ??" Variable in Static RAM
        POP     DE
        LD      HL,($EEA5)      ; GMNRP read "Generate Matrix NRP ??" Variable in Static RAM
        CALL    L8DA8           ; S-RD do "Set GMNRPath goodies"
        CALL    L8D98           ; S-DF do "Set NODMSK path goodies"
        LD      A,C
        CPL
        AND     $03
        LD      C,A
        LD      DE,($EE9F)      ; GMNRC read "Generate Matrix NRC ??" Variable in Static RAM
        CALL    L8696           ; noder^ do ?? again ??
        CALL    L8DA8           ; S-RD do "Set GMNRC goodies"
        CALL    L8D98           ; S-DF do "Set NODMSK path goodies" again ??
        RET
; end of ( ADD PATH ROUTINE ) !!

; { BLOCK 0241 }
; ( CONNECTIVITY TESTING )
; HEX
; : ZAM NCOLS 0 DO NROWS 0 DO J I
;  COMP:XY J I NODY NODE! J I NODX NODE! LOOP LOOP
;  ST-X Src NODX NODE!
;  ST-Y Src NODY NODE!
;  81 Src NODMSK NODE^ B!
;  NROWS 0 DO 0 I NODX NODE@ 0FF70 <
;  IF 0FF70 0 I NODX NODE! THEN
;  0A I NODX NODE@ 8F >
;  IF 8F 0A I NODX NODE! THEN LOOP ;
;
; ZAM does "connectivity testing"
L8DE1:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; NCOLS "pushBYTE to System stack"
        DB      $0B             ; constant 11 for "Number of COLumnS"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; TerseDO Loop #1 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L00C5           ; NROWS "pushBYTE to System stack"
        DB      $06             ; constant 6 for "Number of ROWS"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; _TerseDO Loop #2 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L8633           ; COMP:XY do "COMPute X and Y position"
        ;
        DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; NODY "pushBYTE to System stack"
        DB      $02             ; constant 2 for ??
        ;
        DW      L86ED           ; NODE! do ??
        ;
        DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; NODX "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L86ED           ; NODE! do ??
        ; _TerseLOOP #2 back to TerseDO $2 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; TerseLOOP #1 back to TerseDO #1 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00C5           ; ST-X "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L84EE           ; Src do ??'
        ;
        DW      L00C5           ; NODX "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L86ED           ; NODE! do ??
        ;
        DW      L00C5           ; ST-Y "pushBYTE to System stack"
        DB      $34             ; constant 52 for ??
        ;
        DW      L84EE           ; Src do ??
        ;
        DW      L00C5           ; NODY "pushBYTE to System stack"
        DB      $02             ; constant 2 for ??
        ;
        DW      L86ED           ; NODE! do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $81             ; 129 for ??
        ;
        DW      L84EE           ; Src do ??
        ;
        DW      L00C5           ; NODMSK "pushBYTE to System stack"
        DB      $18             ; constant 24 for ??
        ;
        DW      L8680           ; node^ do "NODE Zammer ( COL ROW DISP --- ^ )"
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00C5           ; NROWS "pushBYTE to System stack"
        DB      $06             ; constant 6 for "Number of ROWS"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; TerseDO Loop #3 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; NODX "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L86F4           ; NODE@ do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF70           ; for ??
        ;
        DW      L01BE           ; < do "TEST (SP) Less Than (SP+2) return in (SP)"
        ; _IF False to THEN #1
        DW      L03CD,L8E53     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF70           ; for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; NODX "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L86ED           ; NODE! do ??
        ; _THEN #1
L8E53:  DW      L04FD           ; 10 "BYTE Pusher" for ??
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; NODX "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L86F4           ; NODE@ do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $8F             ; 143 for ??
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ; _IF False to THEN #2
        DW      L03CD,L8E71     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $8F             ; 143 for ??
        ;
        DW      L04FD           ; 10 "BYTE Pusher" for ??
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; NODX "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L86ED           ; NODE! do ??
        ; _THEN #2 and TerseLOOP #3 back to TerseDO #3 (until INCrement COUNTer reaches to END value)
L8E71:  DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00B0           ; ... TerseRETurn

; : START:CHAMBER?
; 2DUP START-ROW = IF START-COL = IF 2DROP 0 ELSE 1 THEN
; ELSE DROP 1 THEN ;
; DECIMAL
; -->
;
; L8E75: START:CHAMBER? does ?? (not used)
        RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00EE           ; 2DUP do "duplicate top 2 Words of System stack"
        ;
        DW      L00C5           ; START-ROW "pushBYTE to System stack"
        DB      $05             ; constant 5 for "START ROW"
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; IF False to THEN #1
        DW      L03CD,L8E98     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; START-COL "pushBYTE to System stack"
        DB      $05             ; constant 5 for "START COLumn"
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; _IF False to ELSE #2
        DW      L03CD,L8E92     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L02FE           ; 2DROP do "Pop HL, Pop HL" to clean up System Stack
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; _(done so Jump to THEN #2)
        DW      L03C5,L8E94     ; TerseJUMP to ??
        ; _ELSE #2
L8E92:  DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; _THEN #2
L8E94:  DW      L03C5,L8E9C     ; TerseJUMP to ??
        ; THEN #1
L8E98:  DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
L8E9C:  DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0241 } !!

; { BLOCK 0114 }
; ( CREATE MAZE )
; HEX ( MAKE NODE ENTRY )
; SUBR MN-L
;  H PUSH,
;  B PUSH,
;  A B MOV,
;  0 C MVI,
;  BEGIN,
;   0 B BIT,
;   0<>, IF,
;    B PUSH,
;    D PUSH,
;    addpath CALL,
;    D POP,
;    B POP,
;   THEN,
;   B RRCR,
;   C INR,
;   C A MOV,
;   2 CPI,
;  0=, END,
;  E INR,
;  E A MOV,
;  NCOLS CPI,
;  CY~, IF,
;   0 E MVI,
;   D INR,
;  THEN,
;  B POP,
;  H POP,
;  RET,
; DECIMAL
; -->
;
; MN-L does "Make Node entry" routine
L8E9E:  PUSH    HL
        PUSH    BC
        LD      B,A
        LD      C,$00
L8EA3:  BIT     0,B             ; BEGIN loop
        JR      Z,L8EAE                 ; (+$07) IF 0<> False skip
        PUSH    BC
        PUSH    DE
        CALL    L8DB3           ; addpath do "ADD a PATH" ( B= DISTANCE TO CRAM IN )
        POP     DE
        POP     BC
L8EAE:  RRC     B
        INC     C
        LD      A,C
        CP      $02
        JR      NZ,L8EA3                ; (-$13) END if 0= False else to BEGIN
        INC     E
        LD      A,E
        CP      $0B             ; NCOLS constant 11
        JR      C,L8EBF                 ; (+$03) IF CY~ False skip
        LD      E,$00
        INC     D
L8EBF:  POP     BC
        POP     HL
        RET
; end of ( CREATE MAZE ) !!

; { BLOCK 0129 }
; ( HOSTAGE HIDER AND MAZE GENERATOR )
; HEX
; CODE flm
; ( FIRST DEAL WITH HOSTAGE STUFF )
;  H POP, ( XVSA )
;  D POP, ( HOSTAGE TABLE )
;  B PUSH,
;  D PUSH,
;  TOTAL-HOSTAGES DO,
;   D LDAX,
;   A C MOV,
;   0F ANI,
;   A M MOV,
;   H INX,
;   C A MOV,
;   RRC,
;   RRC,
;   RRC,
;   RRC,
;   0F ANI,
;   A M MOV,
;   H INX,
;   H INX,
;   H INX,
;   H INX,
;   H INX,
;   D INX,
;  LOOP,
;  H POP,
;  0B D LXI,
;  D DAD,
;  0 D LXI, ( ADVANCE TO NODE AREA )
;  NNODES 2/ DO,
;   M A MOV,
;   RRC,
;   RRC,
;   RRC,
;   RRC,
;   MN-L CALL,
;   M A MOV,
;   MN-L CALL,
;   H INX,
;  LOOP,
;  B POP,
; NEXT
;
; flm does "hostage hider and maze generator" routine
; note: ( FIRST DEAL WITH HOSTAGE STUFF )
L8EC2:  POP     HL              ; ( XVSA )
        POP     DE              ; ( HOSTAGE TABLE )
        PUSH    BC
        PUSH    DE
        LD      B,$03           ; TOTAL-HOSTAGES constant 3
; DO loop #1 for ?? 3 times
L8EC8:  LD      A,(DE)
        LD      C,A
        AND     $0F
        LD      (HL),A
        INC     HL
        LD      A,C
        RRCA
        RRCA
        RRCA
        RRCA
        AND     $0F
        LD      (HL),A
        INC     HL
        INC     HL
        INC     HL
        INC     HL
        INC     HL
        INC     DE
        DJNZ    L8EC8                   ; (-$16) LOOP to DO #1 for 3
        POP     HL
        LD      DE,$000B        ; 11 for ??
        ADD     HL,DE
        LD      DE,$0000        ; 0 for ??
; ( ADVANCE TO NODE AREA )
        LD      B,$21           ; (NNODES / 2) = 33
L8EE8:  LD      A,(HL)          ; DO loop #2 for NNODES 2/
        RRCA                    ; divide ?? by 8
        RRCA
        RRCA
        RRCA
        CALL    L8E9E           ; MN-L do "Make Node entry"
        LD      A,(HL)
        CALL    L8E9E           ; MN-L do "Make Node entry" again ??
        INC     HL
        DJNZ    L8EE8                   ; (-$0f) LOOP to DO #2 for 33
        POP     BC
        JP      (IY)            ; indexed RETurn
; end of ( HOSTAGE HIDER AND MAZE GENERATOR ) !!

; : FILMAT DUP MZP ! 0 XVSA flm ;
;
; DECIMAL
; -->
;
; FILMAT does ??
L8EFA:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L8446           ; MZP do "get CURRENT MaZe Pointer"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L8428           ; XVSA do ??
        ;
        DW      L8EC2           ; flm do "hostage hider and maze generator"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0129 } !!

; { BLOCK 0173 }
; ( MAZE LOOKER UPPER ) DECIMAL
; XC? IFTRUE
; ( MAZE TABLES )
; ( DATA MZTTBL MTMD , MTMD , MTMD , MTMD , )
;  DATA MAZELST 0 , ( DANGEROUS )
;
; MAZELST for MAZE LiST table(s) ??
L8F09:  DW      LDFF4           ; 1 item ( 0 , DANGEROUS ) ??

;  : MAKE:MAZE CL:NM ZAM
;  GA# B@ DIF B@ 5 > +
;  2 MIN 2* MAZELST @ + @ DUP
;  B@ ?M URND 44 * 1+ + FILMAT ;
; OTHERWISE
;  ." SLEAZED MAZE STUFF"
;  : MAKE:MAZE CL:NM ZAM MTMD 1+ FILMAT ; IFEND
; -->
;
; MAKE:MAZE does "MAKE the MAZE looker upper"
L8F0B:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L8702           ; CL:NM do ??
        ;
        DW      L8DE1           ; ZAM do "connectivity testing"
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00BC           ; DIF "pushWORD to System stack"
        DW      $E3EB           ; for ( DIFficulty factor ) 0-9 in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L016B           ; 2* do "Double Top of System stack"
        ;
        DW      L00BC           ; MAZELST "pushWORD to System stack"
        DW      L8F09           ; for 1-word L8F09: table ?? points to LDFF4: for ?? in ROM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L840E           ; ?M do "get ( randoM # already used ) by CURRENT Player"
        ;
        DW      L8397           ; URND do "Unsigned RaNDom # without replacement"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $2C             ; 44 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L8EFA           ; FILMAT do ??
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0173 } !!

; { BLOCK 0169 }
; ( COMPUTE DISTANCES BETWEEN TWO VECTORS )
; ( THIS GUY USES THE COORDINATES IN THE VECTOR )
; HEX
; SUBR ABSHL
;  H A MOV,
;  A ANA,
;  RP,
;  CMA,
;  A H MOV,
;  L A MOV,
;  CMA,
;  A L MOV,
;  H INX,
;  RET,
;
; ABSHL does "compute distances between two vectors"
; note: ( THIS GUY USES THE COORDINATES IN THE VECTOR )
L8F45:  LD      A,H
        AND     A
        RET     P
        CPL                     ; One's ComPLement a Negative
        LD      H,A
        LD      A,L             ; word !!
        CPL
        LD      L,A
        INC     HL              ; now Two's ComPLement
        RET

; SUBR LRDIST
;  B PUSH,
;  D PUSH,
;  H PUSH,
;  VXH X D LDX,
;  VX X E LDX,
;  VXH Y H LDX,
;  VX Y L LDX,
;  A ANA,
;  D DSBC,
;  ABSHL CALL,
;  L C MOV,
;  H B MOV,
;  VYH X D LDX,
;  VY X E LDX,
;  VYH Y H LDX,
;  VY Y L LDX,
;  A ANA,
;  D DSBC,
;  ABSHL CALL,
;  B DAD,
;  H A MOV,
;  1F CPI,
;  CY~, IF,
;   7F A MVI,
;  ELSE,
;   H DAD,
;   H DAD,
;   H A MOV,
;  THEN,
;  H POP,
;  D POP,
;  B POP,
;  RET,
; DECIMAL
; -->
;
; LRDIST does ??
L8F4F:  PUSH    BC              ; store
        PUSH    DE
        PUSH    HL
        LD      D,(IX+$1D)      ; VXH offset 29
        LD      E,(IX+$1C)      ; VX offset 28
        LD      H,(IY+$1D)      ; VXH offset 29
        LD      L,(IY+$1C)      ; VX offset 28
        AND     A
        SBC     HL,DE
        CALL    L8F45           ; ABSHL do "compute distances between two vectors"
        LD      C,L
        LD      B,H
        LD      D,(IX+$1F)      ; VYH offset 31
        LD      E,(IX+$1E)      ; VY offset 30
        LD      H,(IY+$1F)      ; VYH offset 31
        LD      L,(IY+$1E)      ; VY offset 30
        AND     A
        SBC     HL,DE
        CALL    L8F45           ; ABSHL do "compute distances between two vectors" again ??
        ADD     HL,BC
        LD      A,H
        CP      $1F
        JR      C,L8F82                 ; (+$04) IF CY~ False skip to ELSE
        LD      A,$7F
        JR      L8F85                   ; (+$03) to THEN

L8F82:  ADD     HL,HL           ; ELSE 4* ??
        ADD     HL,HL
        LD      A,H
L8F85:  POP     HL              ; THEN restore
        POP     DE
        POP     BC
        RET
; end of ( COMPUTE DISTANCES BETWEEN TWO VECTORS ) !!

; { BLOCK 0047 }
; ( COORDINATE SHOVELERS )
; SUBR PUSHyc
;  H POP,
;  VX Y E LDX,
;  VXH Y D LDX,
;  D PUSH,
;  VY Y E LDX,
;  VYH Y D LDX,
;  D PUSH,
; PCHL,
;
; PUSHyc does "PUSH VX and VY in IndexY Coordinate shoveler"
L8F89:  POP     HL
        LD      E,(IY+$1C)      ; VX offset 28
        LD      D,(IY+$1D)      ; VXH offset 29
        PUSH    DE
        LD      E,(IY+$1E)      ; VY offset 30
        LD      D,(IY+$1F)      ; VYH offset 31
        PUSH    DE
        JP      (HL)

; SUBR POPyc
;  H POP,
;  D POP,
;  E VY Y STX,
;  D VYH Y STX,
;  D POP,
;  E VX Y STX,
;  D VXH Y STX,
; PCHL,
;
; POPyc does "POP VY and VX in IndexY Coordinate shoveler"
L8F99:  POP     HL
        POP     DE
        LD      (IY+$1E),E      ; VY offset 30
        LD      (IY+$1F),D      ; VYH offset 31
        POP     DE
        LD      (IY+$1C),E      ; VX offset 28
        LD      (IY+$1D),D      ; VXH offset 29
        JP      (HL)

; SUBR PUSHxc
;  H POP,
;  VX X E LDX,
;  VXH X D LDX,
;  D PUSH,
;  VY X E LDX,
;  VYH X D LDX,
;  D PUSH,
; PCHL,
;
; PUSHxc does "PUSH VX and VY in IndeX Coordinate shoveler"
L8FA9:  POP     HL
        LD      E,(IX+$1C)      ; VX offset 28
        LD      D,(IX+$1D)      ; VXH offset 29
        PUSH    DE
        LD      E,(IX+$1E)      ; VY offset 30
        LD      D,(IX+$1F)      ; VYH offset 31
        PUSH    DE
        JP      (HL)

; SUBR POPxc
;  H POP,
;  D POP,
;  E VY X STX,
;  D VYH X STX,
;  D POP,
;  E VX X STX,
;  D VXH X STX,
;  PCHL,
; -->
;
; POPxc does "POP VY and VX in IndexY Coordinate shoveler"
L8FB9:  POP     HL
        POP     DE
        LD      (IX+$1E),E      ; VY offset 30
        LD      (IX+$1F),D      ; VYH offset 31
        POP     DE
        LD      (IX+$1C),E      ; VX offset 28
        LD      (IX+$1D),D      ; VXH offset 29
        JP      (HL)
; end of ( four COORDINATE SHOVELERS ) !!

; { BLOCK 0192 }
; ( BEARING CALCULATOR - RETURNS BEARING 0-7 )
; DATA BEART
;  1 B, 3 B, 7 B, 5 B,
;  0 B, 4 B, 0 B, 4 B,
;  2 B, 2 B, 6 B, 6 B,
;
; BEART 12-byte (aka BEARing Table) ONLY at Intersections !!
; for 8 Cardnal DIRections by using this compass:    0
L8FC9:  DB      $01             ; Up + Right      7  |  1
        DB      $03             ; Down + Right   6 - * - 2
        DB      $07             ; Up + Left       5  |  3
        DB      $05             ; Down + Left        4
; if MORE Y Skewed then ignore X
        DB      $00             ; Up
        DB      $04             ; Down
        DB      $00             ; Up
        DB      $04             ; Down
; if MORE X Skewed then igmore Y
        DB      $02             ; Right
        DB      $02             ; Right
        DB      $06             ; Left
        DB      $06             ; Left

; SUBR BEARING
;  0 C MVI,
;  XCHG,
;  H A MOV,
;  RAL,
;  C RALR,
;  ABSHL CALL,
;  XCHG,
;  H A MOV,
;  RAL,
;  CMC,
;  C RALR,
;  ABSHL CALL, ( CHECK ABS X > ABS Y*2 )
;  H PUSH,
;  H DAD,
;  A ANA,
;  D DSBC,
;  H POP,
;  CY, IF,
;   3 C SET,
;  ELSE, ( NOW CHECK Y CASE )
;   XCHG,
;   H DAD,
;   A ANA,
;   D DSBC,
;   CY, IF,
;    2 C SET,
;   THEN,
;  THEN,
;  0 B MVI,
;  BEART H LXI,
;  B DAD,
;  M A MOV,
;  RET,
; -->
;
; BEARING does "calculats BEARING 0-7"
; note: IN DE= X Skew, HL= Y Skew
L8FD5:  LD      C,$00           ; clear C for Compass
        EX      DE,HL
        LD      A,H
        RLA                     ; X Sign bit into CY
        RL      C               ; CY into C bit 1 (eventually !!)
        CALL    L8F45           ; ABSHL do "compute distances between two vectors"
        EX      DE,HL
        LD      A,H
        RLA                     ; Y Sign bit into CY
        CCF
        RL      C               ; -CY (to invert Y) into C bit 0
        CALL    L8F45           ; ABSHL do "compute distances between two vectors"
; ( CHECK ABS X > ABS Y*2 )
        PUSH    HL
        ADD     HL,HL           ; for Weighted X by Double-Y
        AND     A
        SBC     HL,DE
        POP     HL
        JR      NC,L8FF4                ; (+$04) IF CY False skip to ELSE
        SET     3,C             ; if still More to the X
        JR      L8FFD                   ; (+$09) to THEN

; ELSE ( NOW CHECK Y CASE )
L8FF4:  EX      DE,HL
        ADD     HL,HL           ; for Weighted Double-X by Y
        AND     A
        SBC     HL,DE
        JR      NC,L8FFD                ; (+$02) IF CY False skip
        SET     2,C             ; if still More to the Y
L8FFD:  LD      B,$00           ; THEN with C bit 2 or bit 3 set, but NOT both !!
        LD      HL,L8FC9        ; BEART point to 12-byte BEARING table
        ADD     HL,BC
        LD      A,(HL)          ; look-up BEART result
        RET

; ?? not used Forth code ??
;
; ( CODE BT
;  EXX,
;  H POP,
;  D POP,
;  B POP,
;  A ANA,
;  B DSBC,
;  XCHG,
;  B POP,
;  A ANA,
;  B DSBC,
;  XCHG,
;  BEARING CALL,
;  EXX,
;  A L MOV,
;  0 H MVI,
;  H PUSH,
; NEXT
; ;S )
; end of { BLOCK 0192 } !!

; { BLOCK 0203 }
; ( MORE BEARING STUFF )
; ( IY= ME, IX= HIM )
; SUBR BEARV
;  VX X L LDX,
;  VXH X H LDX,
;  VX Y C LDX,
;  VXH Y B LDX,
;  A ANA,
;  B DSBC,
;  XCHG,
;  VY X L LDX,
;  VYH X H LDX,
;  VY Y C LDXv VYH Y B LDX,
;  A ANA,
;  B DSBC,
;  BEARING JMP,
;
; BEARV does "more BEARing Vector stuff"
; note: ( IY= ME, IX= HIM ) OUT DE= X Skew, HL= Y Skew
L9005:  LD      L,(IX+$1C)      ; VX offset 28 for HIM
        LD      H,(IX+$1D)      ; VXH offset 29
        LD      C,(IY+$1C)      ; VX offset 28 for ME
        LD      B,(IY+$1D)      ; VXH offset 29
        AND     A
        SBC     HL,BC
        EX      DE,HL
        LD      L,(IX+$1E)      ; VY offset 30 for HIM
        LD      H,(IX+$1F)      ; VYH offset 31
        LD      C,(IY+$1E)      ; VY offset 30 for ME
        LD      B,(IY+$1F)      ; VYH offset 31
        AND     A
        SBC     HL,BC
        JP      L8FD5           ; to BEARING "calculats BEARING 0-7"

; ( TABLE TO CONVERT DIRECTION TO BEARING ANGLE )
; DATA DIR2B
;  0 B, 6 B, 2 B, 4 B,
;
; DIR2B (used where ??) 4-byte DIRection 2 Bearing table
; for 4 Cardnal DIRections by using this:    0
L9028:  DB      $00             ; Up         ^
        DB      $06             ; Left   6 < * > 2
        DB      $02             ; Right      v
        DB      $04             ; Down       4

; SUBR Dxy
;  B PUSH,
;  D PUSH,
;  H PUSH,
;  Txy CALL,
;  H POP,
;  D POP,
;  B POP,
;  RET,
;
; Dxy does "convert direction to bearing angle"
L902B:  PUSH    BC
        PUSH    DE
        PUSH    HL
        CALL    L87AC           ; Txy do "more cute calculations"
        POP     HL
        POP     DE
        POP     BC
        RET

; ( UPDATE POSITION OF VECTOR POINTED AT BY X )
; SUBR Xxy
;  X PUSHX,
;  XTIY,
;  X POPX,
;  Dxy CALL,
;  X PUSHX,
;  XTIY,
;  X POPX,
;  RET,
; -->
;
; Xxy does "update position of vector pointed at by IndeX"
L9035:  PUSH    IX
        EX      (SP),IY
        POP     IX
        CALL    L902B           ; Dxy do "convert direction to bearing angle"
        PUSH    IX
        EX      (SP),IY
        POP     IX
        RET
; end of { BLOCK 0203 } !!

; { BLOCK 0272 }
; ( NEW FINDCLOSE ROUTINE )
; DECIMAL
; F= SRCL F= FCLD F= uF
; SUBR FINDCLOSE
; <ASSEMBLE
;  0 HOSTAB H LXI,
;  EXX,
;  A E MOV,
;  127 C MVI,
;  EXX,
; LABEL SRCL
;  M E MOV,
;  H INX,
;  M D MOV,
;  H INX,
;  D A MOV,
;  E ORA,
;  FCLD JRZ,
;  D PUSH,
;  X POPX,
;  ASSMSV X A LDX,
;  ASNOT CPI,
;  SRCL JRNZ,
;  OBJSV X A LDX,
;  EXX,
;  E CMP,
;  EXX,
;  SRCL JRNZ,
;  LRDIST CALL,
;  EXX,
;  C CMP,
;  uF JRZ,
;  CY, IF,
;  LABEL uF
;   A C MOV,
;   X PUSHX,
;   H POP,
;   EXX,
;   B A MOV,
;   EXX,
;   A B MOV,
;  THEN,
;  EXX,
;  SRCL JMPR,
; LABEL FCLD
;  EXX,
;  RET,
; ASSEMBLE>
; -->
;
; TERSE Forth FINDCLOSE does "search list to FIND CLOSEest hostage"
L9045:  LD      HL,L8374        ; HOSTAB point to 3-word "HOStage vector TABle"
        EXX
        LD      E,A
        LD      C,$7F
        EXX
L904D:  LD      E,(HL)          ; SRCL label
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      A,D
        OR      E
        JR      Z,L907B                 ; (+$26) if ?? to FCLD
        PUSH    DE
        POP     IX
        LD      A,(IX+$5E)      ; ASSMSV offset 94
        CP      $00             ; ASNOT constant 0 for ( Assimilation State NOT assimilated )
        JR      NZ,L904D                ; (-$12) if ?? to SRCL
        LD      A,(IX+$5D)      ; OBJSV offset 93 for ( OBJect State Variable )
        EXX
        CP      E
        EXX
        JR      NZ,L904D                ; (-$1a) if ?? to SRCL
        CALL    L8F4F           ; LRDIST do ??
        EXX
        CP      C
        JR      Z,L9070                 ; (+$02) IF CY False skip to uF
        JR      NC,L9078                ; (+$08) if ?? to THEN
L9070:  LD      C,A             ;  uF label
        PUSH    IX
        POP     HL
        EXX
        LD      A,B
        EXX
        LD      B,A
L9078:  EXX                     ; THEN
        JR      L904D                   ; (-$2e) if ?? to SRCL

L907B:  EXX                     ; FCLD label
        RET
; end of ( NEW FINDCLOSE ROUTINE ) !!

; { BLOCK 0104 }
; ( CHECK FINDCLOSE, AND IF FOUND LIGHT UP FOLLOWER )
; SUBR LOOKFOLLOWER ( SEARCH LIST )
;  FINDCLOSE CALL,
;  C A MOV,
;  MAXASSM CPI, ( IS FOLLOWER CLOSE ENUF? )
;  RNC, ( IF TOO FAR AWAY )
;  DISPF Y B LDX,
;  B DCR,
;  B DCR,
;  B CMP,
;  RC, ( OR TOO CLOSE )
;  H PUSH,
;  X POPX, ( IX= FOLLOWER )
;  DISTANCE 1+ Y A LDX,
;  8 ADI,
;  A B MOV,
;  PUSHyc CALL,
;  Dxy CALL,
;  LRDIST CALL,
;  POPyc CALL,
;  C CMP,
;  RC,
;  X PUSHX,
;  H POP,
;  Y PUSHX,
;  D POP, ( DE=LDR )
;  ( LINK HER IN )
;  L BEHIND Y STX,
;  H BEHIND 1+ Y STX,
;  E AHEAD X STX,
;  D AHEAD 1+ X STX,
;  ASSIM ASSMSV X MVIX,
;  DELTADIST Y A LDX,
;  A DELTADIST X STX,
;  DELTADIST 1+ Y A LDX,
;  A DELTADIST 1+ X STX,
; -->
;
; { BLOCK 0098 }
; ( CHECK FOR REVERSAL NEED )
;  PUSHxc CALL,
;  DISTANCE 1+ X A LDX,
;  8 ADI,
;  A B MOV,
;  Xxy CALL,
;  LRDIST CALL,
;  POPxc CALL,
;  A D MOV,
;  C A MOV,
;  D CMP,
;  RNC, ( FIX RESULT OF REVERSAL )
;  Y PUSHX,
;  X PUSHX,
;  Y POPX,
;  r:d CALL,
;  H B MOV,
;  Txy CALL,
;  Y POPX,
;  RET,
; -->
;
; LOOKFOLLOWER does "LOOK for findclose, and if found light up FOLLOWER"
L907D:  CALL    L9045           ; FINDCLOSE does "search list to FIND CLOSEest hostage"
        LD      A,C
        CP      $7F             ; MAXASSM constant 127 for ( MAX ASSiMilation distance )
; ( IS FOLLOWER CLOSE ENUF? )
        RET     NC
; ( IF TOO FAR AWAY )
        LD      B,(IY+$56)      ; DISPF offset 86 for ( DISPlacement Factor )
        DEC     B
        DEC     B
        CP      B
        RET     C
; ( OR TOO CLOSE )
        PUSH    HL
        POP     IX              ; ( IX= FOLLOWER )
        LD      A,(IY+$4B)      ; DISTANCEH offset 75
        ADD     A,$08
        LD      B,A
        CALL    L8F89           ; PUSHyc do "PUSH VX and VY in IndexY Coordinates"
        CALL    L902B           ; Dxy do "convert direction to bearing angle"
        CALL    L8F4F           ; LRDIST do ??
        CALL    L8F99           ; POPyc do "POP VY and VX in IndexY Coordinates"
        CP      C
        RET     C
        PUSH    IX
        POP     HL
        PUSH    IY
        POP     DE              ; ( DE=LDR )
; ( LINK HER IN )
        LD      (IY+$59),L      ; BEHIND offset 89 for ( fellow BEHIND me )
        LD      (IY+$5A),H      ; BEHINDH offset 90
        LD      (IX+$5B),E      ; AHEAD offset 91 for ( fellow AHEAD of me )
        LD      (IX+$5C),D      ; AHEADH offset 92
        LD      (IX+$5E),$01    ; ASSMSV offset 94 = ASSIM for ( fully ASSIMilated )
        LD      A,(IY+$4C)      ; DELTADIST offset 76
        LD      (IX+$4C),A      ; DELTADIST offset 76
        LD      A,(IY+$4D)      ; DELTADISTH offset 77
        LD      (IX+$4D),A      ; DELTADISTH offset 77
; ( CHECK FOR REVERSAL NEED )
        CALL    L8FA9           ; PUSHxc do "PUSH VX and VY in IndeX Coordinates"
        LD      A,(IX+$4B)      ; DISTANCEH offset 75
        ADD     A,$08
        LD      B,A
        CALL    L9035           ; Xxy do "update position of vector pointed at by IndeX"
        CALL    L8F4F           ; LRDIST do ??
        CALL    L8FB9           ; POPxc do "POP VY and VX in IndexY Coordinates"
        LD      D,A
        LD      A,C
        CP      D
        RET     NC
; ( FIX RESULT OF REVERSAL )
        PUSH    IY
        PUSH    IX
        POP     IY
        CALL    L8925           ; r:d do "Reverse Direction"
        LD      B,H
        CALL    L87AC           ; Txy do "more cute calculations"
        POP     IY
        RET
; end of ( CHECK FINDCLOSE, AND IF FOUND LIGHT UP FOLLOWER ) !!

; { BLOCK 0096 }
; ( LOOKASS ROUTINE )
; F= ASSL
; SUBR LOOKASS
; <ASSEMBLE
;  HSATP A MVI,
; LABEL ASSL
;  PSW PUSH,
;  BEHIND Y A LDX,
;  BEHIND 1+ Y ORAX,
;  0=, IF,
;   PSW POP,
;   B PUSH,
;   D PUSH,
;   H PUSH,
;   X PUSHX,
;   LOOKFOLLOWER CALL,
;   X POPX,
;   H POP,
;   D POP,
;   B POP,
;  ELSE,
;   PSW POP,
;  THEN,
;  RET,
; ASSEMBLE>
;
; LOOKASS does "CHECK MY ASS"
L90EA:  LD      A,$01           ; HSATP constant 1 for ( HoStage Attached to Player )
; ASSL label for LKBUN entry
L90EC:  PUSH    AF
        LD      A,(IY+$59)      ; BEHIND offset 89 for ( fellow BEHIND me )
        OR      (IY+$5A)        ; BEHINDH offset 90
        JR      NZ,L9105                ; (+$10) IF 0= False skip to ELSE
        POP     AF
        PUSH    BC
        PUSH    DE
        PUSH    HL
        PUSH    IX
        CALL    L907D           ; LOOKFOLLOWER do "LOOK for findclose, and if found light up FOLLOWER"
        POP     IX
        POP     HL
        POP     DE
        POP     BC
L9103:  JR      L9106                   ; (+$01) to THEN

L9105:  POP     AF              ; ELSE
L9106:  RET                     ; THEN

; SUBR LKBUN
;  HSATM A MVI,
;  ASSL JMPR,
; -->
;
; LKBUN does ??
L9107:  LD      A,$02           ; HSATM constant 2 for ( HoSTagE Attached to Monster )
        JR      L90EC                   ; (-$1f) to ASSL
; end of { BLOCK 0096 } !!

; { BLOCK 0126 }
; ( CHECK VECTOR FOR INTERCEPT WITH OTHER VECTORS )
; ( ROUTINE TO FIND INTERCEPTORS, IF ANY )
; ( ENTRY: BC= NEARNESS X AND Y, HL= CHECKLIST ADDR )
; ( IY= SUBJECT VECTOR )
; ( RETURNS Z= NOFIND NZ= FIND, IX= FOUND THANG )
; DATA MON-LS MONV1 , MONV2 , XC? IFTRUE MONV3 , MONV4 , JAWSV ,
; IFEND 0 ,
;
; MON-LS 5-Word "MONster-LS" table ??
L910B:  DW      $FD51           ; MONV1 for "MONster Vector" #1 in Static RAM
        DW      $FB47           ; MONV2 for "MONster Vector" #2 in Static RAM
        DW      $F93D           ; MONV3 for "MONster Vector" #3 in Static RAM
        DW      $F733           ; MONV4 for "MONster Vector" #4 in Static RAM
        DW      $F529           ; JAWSV for "JAWS Vector" in Static RAM
        DW      $0000           ; NULL for End of Table

; SUBR PX-M
;  MON-LS H LXI,
;  BEGIN,
;   M E MOV,
;   H INX,
;   M D MOV,
;   H INX,
;   D A MOV,
;   E ORA,
;  0<>, WHILE,
;   D PUSH,
;   X POPX,
;   TBACT TSTAT X BITX,
;   0<>, IF,
;    OBJSV X A LDX,
;    MSPRO CPI,
;    0=, IF,
;     PRXC CALL,
;     RNZ,
;    THEN,
;   THEN,
;  REPEAT,
;  RET,
; -->
;
; PX-M does "set window for MON - HOS"
; ( CHECK VECTOR FOR INTERCEPT WITH OTHER VECTORS )
; ( ROUTINE TO FIND INTERCEPTORS, IF ANY )
; note: ( ENTRY: BC= NEARNESS X AND Y,  )
; ( HL= CHECKLIST ADDR, IY= SUBJECT VECTOR )
; ( RETURNS Z= NOFIND NZ= FIND, IX= FOUND THANG )
L9117:  LD      HL,L910B        ; MON-LS point to 5-Word "MONster-LS" table ??
L911A:  LD      E,(HL)          ; BEGIN loop
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      A,D
        OR      E
        JR      Z,L9138                 ; (+$16) WHILE 0<> False to loop Exit
        PUSH    DE
        POP     IX
        BIT     1,(IX+$04)      ; TBACT bit 1 of TSTAT offset 4
        JR      Z,L9136                 ; (+$0b) IF 0<> False skip to THEN
        LD      A,(IX+$5D)      ; OBJSV offset 93 for ( OBJect State Variable )
        CP      $00             ; MSPRO constant 0 for ( Monster State on PROwl )
        JR      NZ,L9136                ; (+$04) IF 0= False skip to THEN
        CALL    L814B           ; PRXC do ??
        RET     NZ
; THEN (for both IFs ??)
L9136:  JR      L911A                   ; (-$1e) REPEAT to BEGIN

L9138:  RET                     ; (loop Exit)
; end of { BLOCK 0126 } !!

; { BLOCK 0086 }
; ( CHECK FOR ONTOP )
; F= ONTL
; SUBR ONTOP?
; <ASSEMBLE
;  0 HOSTAB H LXI,
;  0 C MVI,
; LABEL ONTL
;  M E MOV,
;  H INX,
;  M D MOV,
;  H INX,
;  D A MOV,
;  E ORA,
;  RZ,
;  D PUSH,
;  X POPX,
;  OBJSV X A LDX,
;  HSATP CPI,
;  ONTL JRNZ,
;  B PUSH,
;  LRDIST CALL,
;  B POP,
;  A B MOV,
;  127 CPI,
;  0<>, IF,
;   DIST-1 X SUBX,
;   0=, IF,
;    1 C MVI,
;   ELSE,
;  .ABS
;    0<, IF,
;     1 C MVI,
;    THEN,
;  .REL
;   THEN,
;   ELSE,
;    0 B MVI,
;  THEN,
;  B DIST-1 X STX,
;  ONTL JMPR,
; ASSEMBLE>
; -->
;
; ONTOP? does "check for ONTOP"
L9139:  LD      HL,L8374        ; HOSTAB point to 3-word "HOStage vector TABle"
        LD      C,$00
L913E:  LD      E,(HL)          ; ONTL label (to make a BEGIN, LOOP, loop !!)
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      A,D
        OR      E
        RET     Z               ; if ?? RETurn !! (onlyEXIT point !!+
        PUSH    DE
        POP     IX
        LD      A,(IX+$5D)      ; OBJSV offset 93 for ( OBJect State Variable )
        CP      $01             ; HSATP constant 1 for ( HoStage Attached to Player )
        JR      NZ,L913E                ; (-$11) if ?? to ONTL
        PUSH    BC
        CALL    L8F4F           ; LRDIST do ??
        POP     BC
        LD      B,A
        CP      $7F
        JR      Z,L9169                 ; (+$10) IF 0<> False skip to THEN
        SUB     (IX+$5F)        ; DIST-1 offset 95 for (PREVious DISTance )
        JR      NZ,L9162                ; (+$04) IF 0= False skip to ELSE
        LD      C,$01
        JR      L9167                   ; (+$05) to JUMP to RELOOP with B = ??

L9162:  JP      P,L9167         ; ELSE IF 0< False skip to JUMP to RELOOP
        LD      C,$01
L9167:  JR      L916B                   ; (+$02) JUMP to RELOOP

L9169:  LD      B,$00           ; THEN set B = 0
L916B:  LD      (IX+$5F),B      ; DIST-1 offset 95 for (PREVious DISTance )
        JR      L913E                   ; (-$32) RELOOP to ONTL (NO test at either end of loop !!)
; end of ( CHECK FOR ONTOP )

; { BLOCK 0106 }
; ( PLAYERS INTERRUPT LEVEL ONTOP CHECKER )
; SUBR PILOTR
;  ASSMSV Y A LDX,
;  A ANA,
;  0<>, IF,
;   ONTOP? CALL,
;   C A MOV,
;   A ANA,
;   RNZ,
;   ASCOOL ASSMSV Y MVIX, ( CLEAR ONTOP STATE )
;  THEN,
;  LOOKASS CALL, ( CHECK MY ASS )
;  RET,
;
; PILOTR does "Players Interrupt Level OnTop checker" Routine
L9170:  LD      A,(IY+$5E)      ; ASSMSV offset 94
        AND     A
        JR      Z,L9180                 ; (+$0a) IF 0<> False skip
        CALL    L9139           ; ONTOP? do "check for ONTOP"
        LD      A,C
        AND     A
        RET     NZ
; ( CLEAR ONTOP STATE )
        LD      (IY+$5E),$00    ; ASSMSV offset 94 = ASCOOL for ( PLAYER NOT ONTOP OF HOSTAGES )
L9180:  CALL    L90EA           ; LOOKASS do ( CHECK MY ASS )
        RET

; SUBR PILOTC
;  X PUSHX,
;  PILOTR CALL,
;  X POPX,
;  RET,
;
; PILOTC does ??
L9184:  PUSH    IX
        CALL    L9170           ; PILOTR do "Players Interrupt Level OnTop checker"
        POP     IX
        RET

; SUBR COPYDELTS
;  BEHIND Y E LDX,
;  BEHIND 1+ Y D LDX,
;  BEGIN,
;   D A MOV,
;   E ORA,
;  0<>, WHILE,
;   D PUSH,
;   X POPX,
;   L DELTADIST X STX,
;   H DELTADIST 1+ X STX,
;   BEHIND X E LDX,
;   BEHIND 1+ X D LDX,
;  REPEAT,
;  RET,
; -->
;
; COPYDELTS does ??
L918C:  LD      E,(IY+$59)      ; BEHIND offset 89 for ( fellow BEHIND me )
        LD      D,(IY+$5A)      ; BEHINDH offset 90
L9192:  LD      A,D             ; BEGIN loop
        OR      E
        JR      Z,L91A7                 ; (+$11) WHILE 0<> False to loop Exit
        PUSH    DE
        POP     IX
        LD      (IX+$4C),L      ; DELTADIST offset 76
        LD      (IX+$4D),H      ; DELTADISTH offset 77
        LD      E,(IX+$59)      ; BEHIND offset 89 for ( fellow BEHIND me )
        LD      D,(IX+$5A)      ; BEHINDH offset 90
        JR      L9192                   ; (-$15) REPEAT to BEGIN

L91A7:  RET                     ; (loop Exit !!)
; end of ( PLAYERS INTERRUPT LEVEL ONTOP CHECKER ) !!

; HALTNOW does do "HALT NOW"
L91A8:  PUSH    BC
        PUSH    DE
        PUSH    HL
        PUSH    IX
        PUSH    IY
        LD      HL,L8374        ; HOSTAB point to 3-word "HOStage vector TABle"
        LD      IY,$F12D        ; PLYRV point to "PLaYer Vector" base for IndexY in Static RAM
L91B6:  LD      E,(HL)
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      A,D
        OR      E
        JR      Z,L91E7                 ; (+$29)
        PUSH    DE
        POP     IX
        LD      A,(IX+$5D)      ; OBJSV offset 93 for ( OBJect State Variable )
        CP      $01
        JR      NZ,L91B6                ; (-$12)
        XOR     A
        LD      (IX+$59),A      ; BEHIND offset 89 for ( fellow BEHIND me )
        LD      (IX+$5A),A      ; BEHINDH offset 90
        LD      (IX+$5B),A      ; AHEAD offset 91 for ( fellow AHEAD of me )
        LD      (IX+$5C),A      ; AHEADH offset 92
        LD      (IX+$4C),A      ; DELTADIST offset 76
        LD      (IX+$4D),A      ; DELTADISTH offset 77
        LD      (IX+$5E),$00    ; ASSMSV offset 94
        CALL    L8F4F           ; LRDIST do ??
        LD      (IX+$5F),A      ; DIST-1 offset 95 for (PREVious DISTance )
        JR      L91B6                   ; (-$31)

L91E7:  XOR     A
        LD      (IY+$59),A      ; BEHIND offset 89 for ( fellow BEHIND me )
        LD      (IY+$5A),A      ; BEHINDH offset 90
        POP     IY
        POP     IX
        POP     HL
        POP     DE
        POP     BC
        LD      A,$01
        LD      ($F18B),A       ; write Byte 1 for ?? in Static RAM
        RET

; { BLOCK 0109 }
;  ( INTERFACES TO THE TERSE WORLD )
;
; CODE PROPDELTAS
;  X PUSHX,
;  Y PUSHX,
;  B PUSH,
;  vaddr LIYD,
;  DELTADIST Y L LDX,
;  DELTADIST 1+ Y H LDX,
;  COPYDELTS CALL,
;  B POP,
;  Y POPX,
;  X POPX,
; NEXT
; -->
;
; PROPDELTAS does "interface to the terse world" routine
L91FB:  PUSH    IX
        PUSH    IY
        PUSH    BC
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      L,(IY+$4C)      ; DELTADIST offset 76
        LD      H,(IY+$4D)      ; DELTADISTH offset 77
        CALL    L918C           ; COPYDELTS do ??
        POP     BC
        POP     IY
        POP     IX
        JP      (IY)            ; indexed RETurn
; end of ( one INTERFACE(s) TO THE TERSE WORLD ) !!

; { BLOCK 0054 }
; ( NEW ASSIMILATED HOSTAGE CRUDOLA )
; SUBR Hass ( IX= OTHER IY= ME )
;  DELTADIST Y A LDX,
;  DELTADIST 1+ Y ORAX,
;  RZ, ( DELTADIST )
;  DISTANCE X L LDX,
;  DISTANCE 1+ X H LDX,
;  DISPF X D LDX,
;  0 E MVI,
;  A ANA,
;  D DSBC,
; .ABS
;  0<, IF, ( SET AT MAXDIST + DIFFER )
;   MAXDIST Y D LDX,
;   DISTANCED DAD, ( COMPUTE NEW BIG  )
;  ELSE,
;   H PUSH,
;   ( IMPORT STUFF, THEN SET NEW CALC DISTANCE )
;   Y PUSHX,
;   H POP,
;   NOWR B LXI,
;   B DAD,
;   XCHG,
;   X PUSHX,
;   H POP,
;   B DAD,
;   POSLEN B LXI,
;   LDIR,
;   H POP,
;  THEN,
; .REL
;  L DISTANCE Y STX,
;  H DISTANCE 1+ Y STX,
;  RET,
; -->
;
; Hass does "new ASSimilated Hostage crudola"
; note:  ( IX= OTHER IY= ME )
L9214:  LD      A,(IY+$4C)      ; DELTADIST offset 76
        OR      (IY+$4D)        ; DELTADISTH offset 77
        RET     Z               ; if ( DELTADIST ) Word = NULL
        LD      L,(IX+$4A)      ; DISTANCE offset 74
        LD      H,(IX+$4B)      ; DISTANCEH offset 75
        LD      D,(IX+$56)      ; DISPF offset 86 for ( DISPlacement Factor )
        LD      E,$00
        AND     A
        SBC     HL,DE
        JP      P,L9233         ; IF 0< False to ELSE
; IF not ( SET AT MAXDIST + DIFFERence )
        LD      D,(IY+$49)      ; MAXDIST offset 73
        ADD     HL,DE           ; ( COMPUTE NEW BIG  )
        JP      L9246           ; to THEN finish

; ELSE ( IMPORT STUFF, THEN SET NEW CALC DISTANCE )
L9233:  PUSH    HL
        PUSH    IY
        POP     HL
        LD      BC,$003E        ; NOWR offset 62 for ( CURRENT Row )
        ADD     HL,BC
        EX      DE,HL
        PUSH    IX
        POP     HL
        ADD     HL,BC
        LD      BC,$000C        ; POSLEN for Copy 12 bytes
        LDIR
        POP     HL
; THEN finish
L9246:  LD      (IY+$4A),L      ; DISTANCE offset 74
        LD      (IY+$4B),H      ; DISTANCEH offset 75
        RET

; { BLOCK 0100 }
; ( ASS HOS SPECIAL VECTORING ROUTINE )
; SUBR HASSIM
;  PSW PUSH,
;  B PUSH,
;  X PUSHX,
;  AHEAD Y L LDX,
;  AHEAD 1+ Y H LDX,
;  H PUSH,
;  X POPX,
;  DRPO X A LDX,
;  A ANA,
;  0<>, IF,
;   B A MOV,
;   DISTVECT CALL,
;  ELSE,
;   Hass CALL,
;  THEN,
;  CALCXY CALL,
;  OBJSV Y A LDX,
;  HSATP CPI,
;  LOOKASS CZ,
;  X POPX,
;  B POP,
;  PSW POP,
;  RET,
;
; HASSIM does "ASS HOS special vectoring" routine
L924D:  PUSH    AF
        PUSH    BC
        PUSH    IX
        LD      L,(IY+$5B)      ; AHEAD offset 91 for ( fellow AHEAD of me )
        LD      H,(IY+$5C)      ; AHEADH offset 92
        PUSH    HL
        POP     IX
        LD      A,(IX+$55)      ; DRPO offset 85 for ( DRoP Off flag )
        AND     A
        JR      Z,L9266                 ; (+$06) IF 0<> False skip to ELSE
        LD      A,B
        CALL    L8897           ; DISTVECT do "DISTance VECToring"
        JR      L9269                   ; (+$03) to THEN

L9266:  CALL    L9214           ; ELSE Hass do ( ASSimilated Hostage crudola )
L9269:  CALL    L8764           ; THEN CALCXY do "CALCulate X Y position of object"
        LD      A,(IY+$5D)      ; OBJSV offset 93 for ( OBJect State Variable )
        CP      $01             ; HSATP constant 1 for ( HoStage Attached to Player )
        CALL    Z,L90EA         ; if ?? LOOKASS do "CHECK MY ASS"
        POP     IX
        POP     BC
        POP     AF
        RET

; ( SPECIAL MASTER VECTORING ROUTINE FOR HOSTAGES )
; SUBR H!V
;  PSW PUSH,
;  ASSMSV Y A LDX,
;  A ANA,
;  0<>, IF,
;   PSW POP,
;   HASSIM JMP,
;  THEN,
;  B PUSH,
;  CALCXY CALL,
;  B POP,
;  PSW POP,
;  RET,
;
; H!V does "special master Vectoring for Hostages" routine
L9279:  PUSH    AF
        LD      A,(IY+$5E)      ; ASSMSV offset 94
        AND     A
        JR      Z,L9284                 ; (+$04) IF 0<> False skip to THEN
        POP     AF
        JP      L924D           ; JUMP to HASSIM ( ASS HOS special vectoring ) routine !!

L9284:  PUSH    BC              ; THEN
        CALL    L8764           ; CALCXY do "CALCulate X Y position of object"
        POP     BC
        POP     AF
        RET

; : HVECT-ON H!V CV-ON ;
; -->
;
; HVECT-ON does ??
L928B:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; H!V "pushWORD to System stack"
        DW      L9279           ; point to "special Vectoring routine for Hostages"
        ;
        DW      L88C1           ; CV-ON do "write CUSVEC and ACTIVATE Distance Vectoring"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0100 } !!

; { BLOCK 0261 }
; ( FORCE HOSTAGE TO HAVE SAME POSITION AS INTERCEPTOR )
; SUBR FUZH ( DE= HOSTAGE, HL= OTHER )
;  NOWR B LXI,
;  B DAD,
;  XCHG,
;  B DAD,
;  XCHG,
;  SNATLEN B LXI,
;  LDIR,
;  RET,
;
; FUZH does "Force Hostage to have same position as interceptor"
; note: ( DE= HOSTAGE, HL= OTHER )
L9294:  LD      BC,$003E        ; NOWR offset 62 for ( CURRENT Row )
        ADD     HL,BC
        EX      DE,HL
        ADD     HL,BC
        EX      DE,HL
        LD      BC,$000E        ; SNATLEN for Copy 14 bytes
        LDIR
        RET

; ( SPECIAL ROUTINE FOR EXITING MAZE )
; SUBR PL-VR
;  PSW PUSH,
;  B PUSH,
;  B A MOV,
;  DISTPA CALL,
;  LOOKASS CALL,
;  B POP,
;  PSW POP,
;  vect JMP,
;
; PL-VR does "special routine for exiting maze"
L92A1:  PUSH    AF
        PUSH    BC
        LD      A,B
        CALL    L8860           ; DISTPA do "DISTance Phase Accumulator"
        CALL    L90EA           ; LOOKASS do "CHECK MY ASS"
        POP     BC
        POP     AF
        JP      L169D           ; to vect do ??

;
; : EV:R ZERODXDYAXAY Src Snm ESTPOS
;  256 DELTADIST V! PROPDELTAS 63 MAXDIST VB! 0 NOWD VB!
;  RX-T TIMER!-ON 256 DY!
;  0 DELTAX V! -64 DELTAY V!
;  1 DRPO VB! PL-VR CV-ON ;
; -->
;
; EV:R does ??
L92AF:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1D2F           ; ZERODXDYAXAY do ??
        ;
        DW      L84EE           ; Src do ??
        ;
        DW      L84AF           ; Snm do ??
        ;
        DW      L88DF           ; ESTPOS do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0100           ; 256 for ??
        ;
        DW      L00C5           ; DELTADIST "pushBYTE to System stack"
        DB      $4C             ; offset 76 for ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L91FB           ; PROPDELTAS do "interface to the terse world"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3F             ; 63 for ??
        ;
        DW      L00C5           ; MAXDIST "pushBYTE to System stack"
        DB      $49             ; offset 73 for "MAXimum DISTance"
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; NOWD "pushBYTE to System stack"
        DB      $40             ; offset 64 for ( CURRENT Direction )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00C5           ; RX-T "pushBYTE to System stack"
        DB      $1E             ; constant 30 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0100           ; 256 for ??
        ;
        DW      L1D56           ; DY! do "Divide DE by 4, then Negate then save as VDY"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; DELTAX "pushBYTE to System stack"
        DB      $45             ; offset 69 for ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC0
        ;
        DW      L00C5           ; DELTAY "pushBYTE to System stack"
        DB      $47             ; offset 71 for ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00C5           ; DRPO "pushBYTE to System stack"
        DB      $55             ; offset 85 for ( DRoP Off flag )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00BC           ; PL-VR "pushWORD to System stack"
        DW      L92A1           ; point to "special routine for exiting maze"
        ;
        DW      L88C1           ; CV-ON do "write CUSVEC and ACTIVATE Distance Vectoring"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0261 } !!

; { BLOCK 0219 }
; ( LOOK FOR NEARBY THANGS )
; ( HL= R,C IX= SUBJ RET Z IF NEAR, NZ IF NOT )
; SUBR NEARBY?
;  NOWR X D LDX,
;  NOWC X E LDX,
;  D A MOV,
;  H CMP,
;  0=, IF,
;   E A MOV,
;   L CMP,
;   RZ,
;  THEN,
;  DISTANCE 1+ X A LDX,
;  A ANA,
;  0=, IF,
;   A INR,
;   RET,
;  THEN,
;  NOWD X C LDX,
;  H PUSH,
;  move:node CALL,
;  H POP,
;  D A MOV,
;  H CMP,
;  RNZ,
;  E A MOV,
;  L CMP,
;  RET,
;
; NEARBY? does "look for NEARBY thangs" routine
; note: ( HL= R,C IX= SUBJ RET Z IF NEAR, NZ IF NOT )
L92FC:  LD      D,(IX+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IX+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      A,D
        CP      H
        JR      NZ,L9309                ; (+$03) IF 0= False skip
        LD      A,E
        CP      L
        RET     Z
L9309:  LD      A,(IX+$4B)      ; DISTANCEH offset 75
        AND     A
        JR      NZ,L9311                ; (+$02) IF 0<> False skip past ??
        INC     A
        RET

; ?? past ??
L9311:  LD      C,(IX+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        PUSH    HL
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        POP     HL
        LD      A,D
        CP      H
        RET     NZ
        LD      A,E
        CP      L
        RET

; ( NEARBY LIST -- HL'= TARG HL= LIST RET Z= NONE NZ= FOUND )
; SUBR NEARBYLIST
;  M E MOV,
;  H INX,
;  M D MOV,
;  H INX,
;  D A MOV,
;  E ORA,
;  RZ,
;  H PUSH,
;  Y PUSHX,
;  H POP,
;  A ANA,
;  D DSBC,
;  H POP,
;  NEARBYLIST JRZ,
;  D PUSH,
;  X POPX,
;  EXX,
;  NEARBY? CALL,
;  EXX,
;  NEARBYLIST JRNZ,
;  1 A MVI,
;  A ANA,
;  RET,
; -->
;
; NEARBYLIST does "--" routine
; note: ( HL'= TARGet HL= LIST )
; ( RETurns Z= NONE NZ= FOUND )
L931F:  LD      E,(HL)
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      A,D
        OR      E
        RET     Z
        PUSH    HL
        PUSH    IY
        POP     HL
        AND     A
        SBC     HL,DE
        POP     HL
        JR      Z,L931F                 ; (-$11) if ?? loop to NEARBYLIST "--"
        PUSH    DE
        POP     IX
        EXX
        CALL    L92FC           ; NEARBY? do "look for NEARBY thangs"
        EXX
        JR      NZ,L931F                ; (-$1b) if ?? loop to NEARBYLIST "--"
        LD      A,$01
        AND     A
        RET
; end of { BLOCK 0219 } !!

; { BLOCK 0260 }
; ( CODE ROUTINE TO DO NEARBY CHECK )
; ( C R LIST MTC? --- T )
; CODE MTC?
;  H POP, ( HL= LIST )
;  EXX,
;  D POP,
;  H POP,
;  E H MOV,
;  EXX, ( R,C )
;  X PUSHX,
;  NEARBYLIST CALL,
;  0 H LXI,
;  0=, IF,
;   H INX,
;  THEN,
;  X POPX,
;  H PUSH,
; NEXT
;
; MTC? does "code to do Nearby Check" routine
; note: ( C R LIST MTC? --- T )
L933E:  POP     HL              ; ( HL= LIST )
        EXX
        POP     DE
        POP     HL
        LD      H,E
        EXX                     ; ( R,C )
        PUSH    IX
        CALL    L931F           ; NEARBYLIST do "--"
        LD      HL,$0000        ; 0 for ??
        JR      NZ,L934F                ; (+$01) IF 0= False skip
        INC     HL
L934F:  POP     IX
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; DATA PCONFT
;  MONV1 , MONV2 , HOSV1 ,
;  KEY ,
;  XC? IFTRUE
;   JAWSV , HOSV2 , HOSV3 , TRSV ,
;   MONV3 , MONV4 ,
;  IFEND
;  0 ,
;
; PCONFT 10-Word "PCONF vector Table" ??
L9354:  DW      $FD51           ; MONV1 for "MONster Vector" #1 in Static RAM
        DW      $FB47           ; MONV2 for "MONster Vector" #2 in Static RAM
        DW      $EFB1           ; HOSV1 for "HOStage Vector" #1 in Static RAM
        DW      $F06F           ; KEY for "KEY Vector" base in Static RAM
        DW      $F529           ; JAWSV for "JAWS Vector" in Static RAM
        DW      $EF51           ; HOSV2 for "HOStage Vector" #2 in Static RAM
        DW      $EEF1           ; HOSV3 for "HOStage Vector" #3 in Static RAM
        DW      $F011           ; TRSV for "TReasure Vector" in Static RAM
        DW      $F93D           ; MONV3 for "MONster Vector" #3 in Static RAM
        DW      $F733           ; MONV4 for "MONster Vector" #4 in Static RAM
        DW      $0000           ; NULL for end of table

; : NHY 2DUP PCONFT MTC? IF 1 ELSE 2DROP 0 THEN ;
;
; NHY does ??
L936A:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00EE           ; 2DUP do "duplicate top 2 Words of System stack"
        ;
        DW      L00BC           ; PCONFT "pushWORD to System stack"
        DW      L9354           ; point to 10-Word "PCONF Table" ??
        ;
        DW      L933E           ; MTC? do "code to do Nearby Check"
        ; IF False to ELSE
        DW      L03CD,L937D     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; (done so Jump to THEN)
        DW      L03C5,L9381     ; TerseJUMP to ??
        ; ELSE
L937D:  DW      L02FE           ; 2DROP do "Pop HL, Pop HL" to clean up System Stack
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; THEN
L9381:  DW      L00B0           ; ... TerseRETurn

; : EXIST? 2DUP NODMSK NODEB@ NMEXM AND IF 1 ELSE 2DROP 0 THEN ;
; -->
;
; EXIST? does ??
L9383:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00EE           ; 2DUP do "duplicate top 2 Words of System stack"
        ;
        DW      L00C5           ; NODMSK "pushBYTE to System stack"
        DB      $18             ; constant 24 for ??
        ;
        DW      L86FB           ; NODEB@ do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $80             ; 128 for ??
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ; IF False to ELSE
        DW      L03CD,L939A     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; (done so Jump to THEN)
        DW      L03C5,L939E     ; TerseJUMP to ??
        ; ELSE
L939A:  DW      L02FE           ; 2DROP do "Pop HL, Pop HL" to clean up System Stack
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; THEN
L939E:  DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0260 } !!

; { BLOCK 0093 }
; ( THE GODDAMN SYSTEM PISSED ON VERSION ONE )
; CODE MYTAR
;  EXX,
;  Y PUSHX,
;  X PUSHX,
;  vaddr LIYD,
;  0 C MVI,
;  MON-LS H LXI,
;  BEGIN,
;   M E MOV,
;   H INX,
;   M D MOV,
;   H INX,
;   D A MOV,
;   E ORA,
;  0<>, WHILE,
;   D PUSH,
;   X POPX,
;   OBJSV X A LDX,
;   MSSNA CPI,
;   0=, IF,
;    INTC X A LDX,
;    INTC Y CMPX,
;    0=, IF,
;     INTR X A LDX,
;     INTR Y CMPX,
;     0=, IF,
;      C INR,
;     THEN,
;    THEN,
;   THEN,
;  REPEAT,
;  0 B MVI,
;  X POPX,
;  Y POPX,
;  B PUSH,
;  EXX,
; NEXT
;
; MYTAR does ( THE GODDAMN SYSTEM PISSED ON VERSION ONE )
L93A0:  EXX
        PUSH    IY
        PUSH    IX
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      C,$00
        LD      HL,L910B        ; MON-LS point to 5-Word "MONster-LS" table ??
L93AE:  LD      E,(HL)          ; BEGIN loop
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      A,D
        OR      E
        JR      Z,L93D3                 ; (+$1d) WHILE 0<> False to loop Exit
        PUSH    DE
        POP     IX
        LD      A,(IX+$5D)      ; OBJSV offset 93 for ( OBJect State Variable )
        CP      $03             ; MSSNA constant for ( Monster State SNAtch hostage )
        JR      NZ,L93D1                ; (+$11) IF 0= False skip to THEN
        LD      A,(IX+$3D)      ; INTC offset 61 for ( INiTiaL Column )
        CP      (IY+$3D)        ; INTC offset 61 for ( INiTiaL Column )
        JR      NZ,L93D1                ; (+$09) IF 0= False skip to THEN
        LD      A,(IX+$3C)      ; INTR offset 60 for ( INiTiaL Row )
        CP      (IY+$3C)        ; INTR offset 60 for ( INiTiaL Row )
        JR      NZ,L93D1                ; (+$01) IF 0= False skip to THEN
        INC     C
L93D1:  JR      L93AE                   ; (-$25) THEN label REPEAT to BEGIN

L93D3:  LD      B,$00           ; (loop Exit)
        POP     IX
        POP     IY
        PUSH    BC
        EXX
        JP      (IY)            ; indexed RETurn

; ?? more of { BLOCK 0093 } ??
;
; : HIDEOUT BEGIN BEGIN BEGIN
; 9 RND 1+ 4 RND 1+ EXIST? END
; NHY END INTR VB! INTC VB! Rip MYTAR 0= END ;
;
; HIDEOUT does ??
L93DD:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ; BEGIN loops #1 #2 and #3
L93DE:  DW      L04FB           ; 9 "BYTE Pusher" for Range ??
        ;
        DW      L1A5B           ; RND does "SHIFT and limit RANGE for Next Pseudo-RANDOM Number"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for Range ??
        ;
        DW      L1A5B           ; RND does "SHIFT and limit RANGE for Next Pseudo-RANDOM Number"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L9383           ; EXIST? do ??
        ; __END #3 or loop to BEGINs if False
        DW      L03CD,L93DE     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L936A           ; NHY do ??
        ; _END #2 or loop to BEGINs if False
        DW      L03CD,L93DE     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; INTR "pushBYTE to System stack"
        DB      $3C             ; offset 60 for ( INiTiaL Row )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00C5           ; INTC "pushBYTE to System stack"
        DB      $3D             ; offset 61 for ( INiTiaL Column )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L8498           ; Rip do ??
        ;
        DW      L93A0           ; MYTAR do ( THE GODDAMN SYSTEM PISSED ON VERSION ONE )
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; END #1 or loop to BEGINs if False
        DW      L03CD,L93DE     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0093 } !!

; : HIDE? PUSH:CCR OR 0= IF HIDEOUT THEN ;
; ;S
;
; HIDE? does ??
L940C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L844F           ; PUSH:CCR do ??
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; IF False skip to THEN
        DW      L03CD,L9419     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L93DD           ; HIDEOUT do ??
        ; THEN done
L9419:  DW      L00B0           ; ... TerseRETurn

; { BLOCK 0249 }
; ( ROUTINE TO LINK TO VGER WRITE ROUTINE )
; SUBR XOR-FLIP
;  VOXPAND Y B LDX,
;  VOMAGIC Y C LDX,
;  VOPATH Y H LDX,
;  VOPAT Y L LDX,
;  H INX,
;  H INX, ( pat off set)
;  H PUSH,
;  X POPX,
;  VOSCRADRH Y H LDX,
;  VOSCRADR Y L LDX,
;  writep JMP, ( erase it )
;
; XOR-FLIP does "Invwert XOR-ON in Magic ??" routine
L941B:  LD      B,(IY+$23)      ; VOXPAND offset 35
        LD      C,(IY+$22)      ; VOMAGIC offset 34
        LD      H,(IY+$2B)      ; VOPATH offset 43
        LD      L,(IY+$2A)      ; VOPAT offset 42
        INC     HL
        INC     HL              ; ( pat off set)
        PUSH    HL
        POP     IX              ; restore as Terse SP
        LD      H,(IY+$2F)      ; VOSCRADRH offset 47
        LD      L,(IY+$2E)      ; VOSCRADR offset 46
; then ( erase it )
        JP      L12D0           ; to writep do "Pop DE from Terse stack then Pattern Transfer start"

; SUBR WRITE-LINK
;  CMXPND VLOGICSTAT Y BITX,
;  0=, IF,
;   VWRITE CALL,
;  ELSE,
;   CMXPND VLOGICSTAT Y RESX,
;  THEN,
;  RET,
;
; WRITE-LINK does "link to vger write" routine
L9435:  BIT     CMXPND,(IY+$24) ; is CMXPND bit 1 of VLOGICSTAT offset 36 set ?
        JR      NZ,L9440                ; (+$05) IF 0= False to ELSE yes
        CALL    L12DD           ; VWRITE do "load Pattern Board values to Draw with"
        JR      L9444                   ; (+$04) JUMP to THEN

; ELSE if CMXPND bit 1 of VLOGICSTAT offset 36 set
L9440:  RES     CMXPND,(IY+$24) ; clear it
L9444:  RET                     ; THEN

; ( CHECK:NEAR )
; DATA PCON
;  PLYRV , MONV1 , MONV2 ,
;  XC? IFTRUE
;   MONV3 , JAWSV , MONV4 ,
;  IFEND
;  KEY , HOSV1 , ARV ,
;  XC? IFTRUE
;   TRSV , HOSV2 , HOSV3 ,
;  IFEND
;  0 ,
; -->
;
; PCON 12-Word "PCON vector" table for ( CHECK:NEAR )
L9445:  DW      $F12D           ; PLYRV for "PLaYer Vector" in Static RAM
        DW      $FD51           ; MONV1 for "MONster Vector" #1 in Static RAM
        DW      $FB47           ; MONV2 for "MONster Vector" #2 in Static RAM
        DW      $F93D           ; MONV3 for "MONster Vector" #3 in Static RAM
        DW      $F529           ; JAWSV for "JAWS Vector" in Static RAM
        DW      $F733           ; MONV4 for "MONster Vector" #4 in Static RAM
        DW      $F06F           ; KEY for "KEY Vector" base in Static RAM
        DW      $EFB1           ; HOSV1 for "HOStage Vector" #1 in Static RAM
        DW      $F31F           ; ARV for ( ARrow Vector )
        DW      $F011           ; TRSV for "TReasure Vector"in Static RAM
        DW      $EF51           ; HOSV2 for "HOStage Vector" #2 in Static RAM
        DW      $EEF1           ; HOSV3 for "HOStage Vector" #3 in Static RAM
        DW      $0000           ; NULL for end of table
; end of { BLOCK 0249 } !

; { BLOCK 0175 }
; ( SPECIAL WRITE ROUTINE FOR REVEALS )
; DECIMAL
; F= REML
; F= RESL
; F= LISTEND
; SUBR REVEALWRITE
; <ASSEMBLE
;  0 H LXI,
;  H PUSH, ( MARK STACK )
;  ( Y PUSHX,
;  H POP,
;  CONFTAB D LXI,
;  D DAD, )
;  PCON H LXI,
; LABEL REML
;  M E MOV,
;  H INX,
;  M D MOV,
;  H INX,
;  D A MOV,
;  E ORA,
;  LISTEND JRZ,
;  Y PUSHX,
;  B POP,
;  B A MOV,
;  D CMP,
;  0=, IF,
;   C A MOV,
;   E CMP,
;   REML JRZ,
;  THEN,
;  D PUSH,
;  X POPX,
;  CMFLIP VLOGICSTAT X BITX,
;  REML JRZ,
;  CMCONST VLOGICSTAT X BITX,
;  REML JRNZ,
;  VOPATH X A LDX,
;  VOPAT X ORAX,
;  REML JRZ,
; -->
;
; { BLOCK 0176 }
; ( MORE OF SPECIAL WRITE ROUTINE FOR REVEALS )
;  VOSCRADRH X A LDX,
;  VSCRADRH Y SUBX,
;  10 ADI,
;  20 CPI,
;  REML JRNC,
;  X PUSHX,
;  H PUSH,
;  Y PUSHX,
;  X PUSHX,
;  Y POPX,
;  XOR-FLIP CALL,
;  Y POPX,
;  H POP,
;  REML JMPR,
; LABEL LISTEND
;  WRITE-LINK CALL,
; LABEL RESL
;  D POP,
;  D A MOV,
;  E ORA,
;  transition JZ,
;  Y PUSHX,
;  D PUSH,
;  Y POPX,
;  XOR-FLIP CALL,
;  Y POPX,
;  RESL JMPR,
; ASSEMBLE>
;
; REVEALWRITE does "special WRITE routine for REVEALs "
L945F:  LD      HL,$0000        ; 0 for ??
        PUSH    HL              ; ( MARK STACK )
; commented out: ( Y PUSHX, H POP,  CONFTAB D LXI, D DAD, )
        LD      HL,L9445        ; PCON point to 12-Word "PCON vector" table ??
; REML label
L9466:  LD      E,(HL)          ; REML loop here until NULL entry ?? found
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      A,D
        OR      E
        JR      Z,L94AD                 ; (+$3f) to LISTEND when NULL found
        PUSH    IY
        POP     BC
        LD      A,B
        CP      D
        JR      NZ,L9479                ; (+$04) IF 0= False skip to THEN
        LD      A,C
        CP      E
        JR      Z,L9466                 ; (-$13) to REML
L9479:  PUSH    DE              ; THEN
        POP     IX
        BIT     CMFLIP,(IX+$24) ; is CMFLIP bit 4 of VLOGICSTAT offset 36 set ?
        JR      Z,L9466                 ; (-$1c) to REML no
        BIT     CMCONST,(IX+$24) ; is CMCONST bit 2 of VLOGICSTAT offset 36 set ?
        JR      NZ,L9466                ; (-$22) yes to REML
        LD      A,(IX+$2B)      ; VOPATH offset 43
        OR      (IX+$2A)        ; VOPAT offset 42
        JR      Z,L9466                 ; (-$2a) to REML
; ( MORE OF SPECIAL WRITE ROUTINE FOR REVEALS )
        LD      A,(IX+$2F)      ; VOSCRADRH offset 47
        SUB     (IY+$2D)        ; VSCRADRH offset 45
        ADD     A,$0A
        CP      $14
        JR      NC,L9466                ; (-$36) to REML
        PUSH    IX
        PUSH    HL
        PUSH    IY
        PUSH    IX
        POP     IY
        CALL    L941B           ; XOR-FLIP do "Invwert XOR-ON in Magic ??"
        POP     IY
        POP     HL
        JR      L9466                   ; (-$47) to REML

; LISTEND label
L94AD:  CALL    L9435           ; WRITE-LINK do "link to vger write"
; RESL label
 L94B0:  POP     DE              ; RESL loop
        LD      A,D
        OR      E
        JP      Z,L136A         ; transition to re-entry point for ??
        PUSH    IY
        PUSH    DE
        POP     IY
        CALL    L941B           ; XOR-FLIP do "Invwert XOR-ON in Magic ??"
        POP     IY
        JR      L94B0                   ; (-$12) to RESL

; HEX ( 4 C= HDST )
; 800 C= REVVEL
; DECIMAL
; -->
;
; end of ( SPECIAL WRITE ROUTINE FOR REVEALS ) !!

; { BLOCK 0090 }
; ( CHANGE PLAYERS PERSPECTIVE INDEX ROUTINE )
; SUBR C-PX
;  H PUSH,
;  B PUSH,
;  1 ANI,
;  A C MOV, ( C= WHAT TO GO TO )
;  VPERINX PLYRV + H LXI,
;  M A MOV,
;  1 ANI,
;  C CMP,
;  0<>, IF,
;   M A MOV,
;   2 ANI,
;   C ORA,
;   A M MOV,
;   A XRA,
;   VANIMINX PLYRV + STA,
;   A INR,
;   VANIMTIMER PLYRV + STA,
;   D PUSH,
;   M A MOV,
;   1 ANI,
;   0<>, IF,
;    dig-s CALL,
;   ELSE,
;    walk-s CALL,
;   THEN,
;   D POP,
;  THEN,
;  B POP,
;  H POP,
;  RET,
; -->
;
; C-PX does "Change players Perspective indeX" routine
L94C2:  PUSH    HL
        PUSH    BC
        AND     $01
        LD      C,A             ; ( C= WHAT TO GO TO )
        LD      HL,$F167        ; VPERINX + PLYRV (58 + $F12D) point to Word ?? for ?? in Static RAM
        LD      A,(HL)
        AND     $01
        CP      C
        JR      Z,L94EC                 ; (+$1c) IF 0<> False skip over
        LD      A,(HL)
        AND     $02
        OR      C
        LD      (HL),A
        XOR     A
        LD      ($F165),A       ; VANIMINX + PLYRV (56 + $F12D) write Byte 0 for ?? in Static RAM
        INC     A
        LD      ($F164),A       ; VANIMTIMER + PLYRV (55 + $F12D) write Byte 1 for ?? in Static RAM
        PUSH    DE
        LD      A,(HL)
        AND     $01
        JR      Z,L94E8                 ; (+$05) IF 0<> False skip to ELSE
        CALL    L347B           ; dig-s do ??
        JR      L94EB                   ; (+$03) to THEN

L94E8:  CALL    L33F0           ; ELSE walk-s do ??
L94EB:  POP     DE              ; THEN
L94EC:  POP     BC              ; over
        POP     HL
        RET
; end of ( CHANGE PLAYERS PERSPECTIVE INDEX ROUTINE )

; { BLOCK 0044 }
; ( REVEALER SLAVE TO PLAYER ROUTINE )
; F= ruk
; F= JCXY
; F= SAM
; F= DIX
; SUBR SLV!
; .ABS
; <ASSEMBLE
;  PSW PUSH,
;  B PUSH,
;  DIRFLAG LDA,
;  A ANA,
;  0<>, IF,
;   A XRA,
;   C-PX CALL,
;   JCXY JMP,
;  THEN,
;  O-M LDA,
;  A ANA,
;  JCXY JZ,
;  PLYRV NOWD + LDA,
;  NOWD Y CMPX,
;  DIX JRNZ,
;  NOWR PLYRV + LDED,
;  NOWR REVV + LHLD,
;  A ANA,
;  D DSBC,
;  SAM JRZ,
; LABEL DIX
;  PLYRV NOWR + LHLD,
;  REVV NOWR + SHLD,
;  PLYRV NOWD + LDA,
;  REVV NOWD + STA,
;  NEWPATH CALL,
; -->
;
; { BLOCK 0228 }
; ( FETCH R,C,D )
; LABEL SAM
;  NOWC Y E LDX,
;  NOWR Y D LDX,
;  NOWD Y C LDX,
;  noder^ CALL,
;  M B MOV,
;  B DISTANCE 1+ Y STX,
;  DISTANCE 1+ PLYRV + LDA,
;  A L MOV,
;  B A MOV,
;  L SUB,
;  0>=, IF,
;   12 CPI,
;   CY~, IF,
;    A XRA,
;    C-PX CALL,
;   THEN, ( WE ARE AHEAD OF THE PLAYER - ARE WE NEAR MAX? )
;   noded^ CALL,
;   M A MOV,
;   B SUB,
;   JCXY JZ,
;   8 CPI,
;   JCXY JNC,
;  THEN,
; -->
;
; { BLOCK 0089 }
; ( BUMP MUNCH CTR )
;  DIGSCR H LXI,
;  M INR,
;  1 A MVI,
;  C-PX CALL,
;  1 A MVI,
;  DISTPA CALL,
;  NOWC Y E LDX,
;  NOWR Y D LDX,
;  NOWD Y C LDX,
;  TBDEST TCHGSTAT Y BITX,
;  ruk JRNZ,
;  B PUSH,
;  D PUSH,
;  move:node CALL,
;  C A MOV,
;  CMA,
;  3 ANI,
;  A C MOV,
;  noder^ CALL,
;  D POP,
;  M B MOV,
;  REVV DISTANCE 1+ + LDA,
;  B ADD,
;  B POP,
;  MAXDIST Y CMPX,
;  ruk JRNC,
;  noder^ CALL,
;  REVV DISTANCE 1+ + LDA,
;  A M MOV,
;  JCXY JMPR,
; LABEL ruk
;  noded^ CALL,
;  M B MOV,
;  noder^ CALL,
;  B M MOV,
;  move:node CALL,
;  C A MOV,
;  CMA,
;  3 ANI,
;  A C MOV,
;  noder^ CALL,
;  B M MOV, ( BOTH )
;  TBDEST TCHGSTAT Y RESX,
;  A XRA,
;  C-PX CALL,
; LABEL JCXY
;  CALCXY CALL,
;  B POP,
;  PSW POP,
;  RET,
; ASSEMBLE>
; .REL
; -->
;
; SLV! does "revealer SLaVe to player" routine
L94EF:  PUSH    AF
        PUSH    BC
        LD      A,($EEEC)       ; DIRFLAG read ( player DIRection FLAG ) Byte-Variable in Static RAM
        AND     A
        JP      Z,L94FF         ; IF 0<> False skip
        XOR     A
        CALL    L94C2           ; C-PX do "Change players Perspective indeX"
        JP      L95B3           ; to JCXY

L94FF:  LD      A,($EEEB)       ; O-M read ( Object Moving ) Byte-Variable
        AND     A
        JP      Z,L95B3         ; if ?? to JCXY
        LD      A,($F16D)       ; PLYRV + NOWD ($F12D + 64) read Byte ?? for ?? in Static RAM
        CP      (IY+$40)        ; NOWD offset 64 for ( CURRENT Direction )
        JR      NZ,L951A                ; (+$0c) if ?? to DIX
        LD      DE,($F16B)      ; PLYRV + NOWR ($F12D + 62) read Word ?? for ?? in Static RAM
        LD      HL,($F10B)      ; REVV + NOWR ($F0CD + 62) read Word ?? for ?? in Static RAM
        AND     A
        SBC     HL,DE
        JR      Z,L9529                 ; (+$0f) if ?? to SAM
; DIX label
L951A:  LD      HL,($F16B)      ; PLYRV + NOWR ($F12D + 62) read Word ?? for ?? in Static RAM
        LD      ($F10B),HL      ; REVV + NOWR ($F0CD + 62) write Word ?? into ?? in Static RAM
        LD      A,($F16D)       ; PLYRV + NOWD ($F12D + 64) read Byte ?? for ?? in Static RAM
        LD      ($F10D),A       ; REVV + NOWD ($F0CD + 64) write Byte ?? for ?? in Static RAM
        CALL    L8817           ; NEWPATH do "establish NEW base positions and deltas"
; SAM label ?? continue ( FETCH R,C,D )
L9529:  LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      C,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        CALL    L8696           ; noder^ do ??
        LD      B,(HL)
        LD      (IY+$4B),B      ; DISTANCEH offset 75
        LD      A,($F178)       ; DISTANCEH + PLYRV (75 + $F12D) read Byte ?? for ?? in Static RAM
        LD      L,A
        LD      A,B
        SUB     L
        JP      M,L9558         ; IF 0>= False to THEN
        CP      $0C
        JP      C,L954B         ; IF CY~ False skip
        XOR     A
        CALL    L94C2           ; C-PX do "Change players Perspective indeX"
; ( WE ARE AHEAD OF THE PLAYER - ARE WE NEAR MAX? )
L954B:  CALL    L868C           ; noded^ do ??
        LD      A,(HL)
        SUB     B
        JP      Z,L95B3         ; if ?? to JCXY
        CP      $08
        JP      NC,L95B3        ; if ?? to JCXY
; THEN ( BUMP MUNCH CTR )
L9558:  LD      HL,$EEC9        ; DIGSCR point to "DIG SCoRe" Byte-Variable in Static RAM
        INC     (HL)
        LD      A,$01
        CALL    L94C2           ; C-PX do "Change players Perspective indeX"
        LD      A,$01
        CALL    L8860           ; DISTPA do "DISTance Phase Accumulator"
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      C,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        BIT     2,(IY+$12)      ; TBDEST bit 2 of TCHGSTAT offset 18
        JR      NZ,L9597                ; (+$22) if ?? to ruk
        PUSH    BC
        PUSH    DE
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        LD      A,C
        CPL
        AND     $03
        LD      C,A
        CALL    L8696           ; noder^ do ??
        POP     DE
        LD      B,(HL)
        LD      A,($F118)       ; REVV + DISTANCEH ($F0CD + 75) read Byte ?? for ?? in Static RAM
        ADD     A,B
        POP     BC
        CP      (IY+$49)        ; MAXDIST offset 73
        JR      NC,L9597                ; (+$09) if ?? to ruk
        CALL    L8696           ; noder^ do ??
        LD      A,($F118)       ; REVV + DISTANCEH ($F0CD + 75) read Byte ?? for ?? in Static RAM
        LD      (HL),A
        JR      L95B3                   ; (+$1c) to JCXY

; ruk label
L9597:  CALL    L868C           ; noded^ do ??
        LD      B,(HL)
        CALL    L8696           ; noder^ do ??
        LD      (HL),B
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        LD      A,C
        CPL
        AND     $03
        LD      C,A
        CALL    L8696           ; noder^ do ??
        LD      (HL),B          ; BOTH
        RES     2,(IY+$12)      ; TBDEST bit 2 of TCHGSTAT offset 18
        XOR     A
        CALL    L94C2           ; C-PX do "Change players Perspective indeX"
; JCXY label
L95B3:  CALL    L8764           ; CALCXY do "CALCulate X Y position of object"
        POP     BC
        POP     AF
        RET
; end of ( "revealer SLaVe to player" routine ) !!

; { BLOCK 0078 }
; ( CHAMBER REVEALER )
;
; HEX
; : CH:R DIVG
; ESTPOS DVECT-ON PUSH:CCR G-D? NOT IF
; ( PUSH:CCR WALDO )
; gr-p ANIM! 1STWRITE 0C XPAND!-ON OR-ON
; 1 TIMER!-ON REVEALWRITE ZGO DIVG
; XPAND-OFF XOR-ON
; PUSH:CCR S-GD THEN COGO ;
;
; CH:R does "CHamber Revealer"
L95B9:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L88DF           ; ESTPOS do ??
        ;
        DW      L88D6           ; DVECT-ON do "ACTIVATE Distance Vectoring"
        ;
        DW      L844F           ; PUSH:CCR do ??
        ;
        DW      L86AE           ; G-D? do "test Grotto Drawn"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; IF False to THEN
        DW      L03CD,L95EC     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ; commented out: ( PUSH:CCR WALDO )
        DW      L00BC           ; gr-p "pushWORD to System stack"
        DW      L81C7           ; unknown color ?? Monochrome RBOX pattern
        ;
        DW      L1BE2           ; ANIM! do Set up RBOX Pattern for ??
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L0501           ; 12 "BYTE Pusher" for Color 3 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L1E63           ; OR-ON do "Turn on OR writes in Magic ??"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L00BC           ; REVEALWRITE "pushWORD to System stack"
        DW      L945F           ; point to "special WRITE routine for REVEALs"
        ;
        DW      L80FE           ; ZGO do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L1E3A           ; XPAND!-OFF do "Turn eXPAND ?? OFF"
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L844F           ; PUSH:CCR do ??
        ;
        DW      L86A0           ; S-GD do "Set Grotto Drawn"
        ; THEN
L95EC:  DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of ( CHAMBER REVEALER ) !!

; CODE RVECT-ON
;  Y PUSHX,
;  vaddr LIYD,
;  SLV! H LXI,
;  L CUSVEC Y STX,
;  H CUSVEC 1+ Y STX,
;  TB-DVECT TVMROPT2 Y SETX,
;  Y POPX,
; NEXT
;
; DECIMAL -->
;
; TERSE Forth RVECT-ON does "?? then ACTIVATE Distance Vectoring"
L95F0:  PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      HL,L94EF        ; SLV! point to "revealer SLaVe to player" routine
        LD      (IY+$52),L      ; CUSVEC offset 82 for ( CUSTom VECtor routine address )
        LD      (IY+$53),H      ; CUSVECH offset 83
        SET     5,(IY+$11)      ; TB-DVECT bit 5 of TVMROPT2 offset 17
L9603:  POP     IY
        JP      (IY)            ; indexed RETurn
; end of { BLOCK 0078 } !!

; { BLOCK 0254 }
; ( BIZARRE REVEALER FUNCTION )
; HEX
; : H:R ;TASK: DIVG
; BEGIN PLYRV GRCD
; ESTPOS
; rv-p ANIM! 0C XPAND!-ON OR-ON 1STWRITE 1 TIMEBMAX!
; BEGIN REVVEL DELTADIST V!
; ( HOTROD THE REVEALER )
; RVECT-ON REVEALWRITE ZGO DIVG 0 END ;
; -->
;
; H:R does "bizarre revealer function" ??
L9607:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00BC           ; PLYRV "pushWORD to System stack"
        DW      $F12D           ; for Word "PLaYeR Vector" base in Static RAM
        ;
        DW      L84F7           ; GRCD do ??
        ;
        DW      L88DF           ; ESTPOS do ??
        ;
        DW      L00BC           ; rv-p "pushWORD to System stack"
        DW      L8214           ; unknown color ?? Monochrome CIRCLE pattern
        ;
        DW      L1BE2           ; ANIM! do Set up CIRCLE Pattern for ??
        ;
        DW      L0501           ; 12 "BYTE Pusher" for Color 3 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L1E63           ; OR-ON do "Turn OR writes ON in Magic ??"
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L1F22           ; TIMEBMAX! do ??
        ; BEGIN loop
L9626:  DW      L00BC           ; REVVEL "pushWORD to System stack"
        DW      $0800           ; constant 2048 for ??
        ;
        DW      L00C5           ; DELTADIST "pushBYTE to System stack"
        DB      $4C             ; offset 76 for ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ; ( HOTROD THE REVEALER )
        DW      L95F0           ; RVECT-ON do "?? then ACTIVATE Distance Vectoring"
        ;
        DW      L00BC           ; REVEALWRITE "pushWORD to System stack"
        DW      L945F           ; point to "special WRITE routine for REVEALs"
        ;
        DW      L80FE           ; ZGO do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; END or loop to BEGIN if False
        DW      L03CD,L9626     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of ( BIZARRE REVEALER FUNCTION ) !!

; { BLOCK 0306 }
; ( CHAMBER REVEALER TASK )
; : C:RT ;TASK: DIVG PLYRV GRCD ' CH:R SETCO COGO ;
; DECIMAL
; -->
;
; C:RT does "Chamber Revealer Task"
L9641:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00BC           ; PLYRV "pushWORD to System stack"
        DW      $F12D           ; for Word "PLaYeR Vector" base in Static RAM
        ;
        DW      L84F7           ; GRCD do ??
        ;
        DW      L00BC           ; CH:R "pushWORD to System stack"
        DW      L95B9           ; point to "CHamber Revealer" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of ( CHAMBER REVEALER TASK ) !!

; { BLOCK 0248 }
; ( PATTERNS TO FORM MASTER ARROW PATTERN WITH )
; { : BIN } 2 BASE ! { ; }
; DATA SYNTBL
; ( UP )
; DECIMAL 5 B, BIN
;  00000010 B, 00000000 B,
;  00000111 B, 00000000 B,
;  00001111 B, 10000000 B,
;  00000010 B, 00000000 B,
;  00000010 B, 00000000 B,
;
; ( PATTERNS TO FORM MASTER ARROW PATTERN WITH )
; SYNTBL for "First ARROW UP" TaBLe
L9656:  DB      $05             ; 5 for ??
        DB      $02,$00         ; . . . . . . X . . . . . . . . .
        DB      $07,$00         ; . . . . . X X X . . . . . . . .
        DB      $0F,$80         ; . . . . X X X X X . . . . . . .
        DB      $02,$00         ; . . . . . . X . . . . . . . . .
        DB      $02,$00         ; . . . . . . X . . . . . . . . .

; ( LEFT )
; DECIMAL 69 B, BIN
;  00100000 B, 00000000 B,
;  01100000 B, 00000000 B,
;  11111000 B, 00000000 B,
;  01100000 B, 00000000 B,
;  00100000 B, 00000000 B,
; DECIMAL
; -->
;
; ( ARROW LEFT ) DIRection 1 in JOYTBL
        DB      $45             ; 69 for ??
        DB      $20,$00         ; . . X . . . . . . . . . . . . .
        DB      $60,$00         ; . X X . . . . . . . . . . . . .
        DB      $F8,$00         ; X X X X X . . . . . . . . . . .
        DB      $60,$00         ; . X X . . . . . . . . . . . . .
        DB      $20,$00         ; . . X . . . . . . . . . . . . .
; end of { BLOCK 0248 } !!

; { BLOCK 0271 }
; ( more PATTERNS TO FORM MASTER ARROW PATTERN WITH )
; ( RIGHT )
; DECIMAL 67 B, BIN
;  00010000 B, 00000000 B,
;  00011000 B, 00000000 B,
;  01111100 B, 00000000 B,
;  00011000 B, 00000000 B,
;  00010000 B, 00000000 B,
;
; ( ARROW RIGHT ) DIRection 2 in JOYTBL
        DB      $43             ; 67 for ??
        DB      $10,$00         ; . . . X . . . . . . . . . . . .
        DB      $18,$00         ; . . . X X . . . . . . . . . . .
        DB      $7C,$00         ; . X X X X X . . . . . . . . . .
        DB      $18,$00         ; . . . X X . . . . . . . . . . .
        DB      $10,$00         ; . . . X . . . . . . . . . . . .

;  ( DN )
; DECIMAL 130 B, BIN
;  00000001 B, 00000000 B,
;  00000001 B, 00000000 B,
;  00000111 B, 11000000 B,
;  00000011 B, 10000000 B,
;  00000001 B, 00000000 B,
; DECIMAL
; -->
;
; ( ARROW DowN ) DIRection 3 in JOYTBL
        DB      $82             ; 130 for ??
        DB      $01,$00         ; . . . . . . . X . . . . . . . .
        DB      $01,$00         ; . . . . . . . X . . . . . . . .
        DB      $07,$C0         ; . . . . . X X X X X . . . . . .
        DB      $03,$80         ; . . . . . . X X X . . . . . . .
        DB      $01,$00         ; . . . . . . . X . . . . . . . .
; end of { BLOCK 0271 } !!

; { BLOCK 0223 }
; ( SYNAP )
; HEX
; SUBR SYNAP
;  B PUSH,
;  0 ARWP H LXI,
;  ARWL DO,
;   0 M MVI,
;   H INX,
;  LOOP,
;  D A MOV,
;  A ANA,
;  0<>, IF,
;   0F0F H LXI,
;   0 ARWP SHLD,
;   1E05 H LXI,
;   2 ARWP SHLD,
;  ELSE,
;   0F0F H LXI,
;   0 ARWP SHLD,
;   1405 H LXI,
;   2 ARWP SHLD,
;  THEN,
;  0 B MVI,
;  BEGIN,
;   B C MOV,
;   noded^ CALL,
;   M A MOV,
;   A ANA,
;   0<>, IF,
;    noder^ CALL,
;    M A MOV,
;    0C CPI,
;    CY, IF,
;     ARS LDA,
;     A ANA,
;     0<>, IF,
;      C A MOV,
;      CMA,
;      3 ANI,
;      A L MOV,
;      PLYRV NOWD + LDA,
;      L CMP,
;     ELSE,
;      1 A MVI,
;      A ANA,
;     THEN,
;     0<>, IF,
; -->
;
; { BLOCK 0273 }
; ( CALCULATE PATTERN ADDRESS )
;      B PUSH,
;      D PUSH,
;      B INR,
;      0F5 A MVI,
;      BEGIN,
;       0B ADI,
;      LOOP,
;      A C MOV,
;      SYNTBL H LXI,
;      B DAD,
;      M C MOV,
;      H INX,
;      XCHG,
;      0 ARWP H LXI,
;      B DAD,
;      5 DO,
;       D LDAX,
;       D INX,
;       A M MOV,
;       H INX,
;       D LDAX,
;       D INX,
;       A M MOV,
;       H INX,
;       H INX,
;       H INX,
;       H INX,
;      LOOP,
;      D POP,
;      B POP,
;     THEN,
;    THEN,
;   THEN,
;   B INR,
;   B A MOV,
;   4 CPI,
;  CY~, END,
;  B POP,
;  RET,
; DECIMAL
; -->
;
; SYNAP does ( SYNAP ) routine
L9682:  PUSH    BC
        LD      HL,$F18D        ; ARWP point to "ARWRow Pattern" in Static RAM (NOT vs1s)
        LD      B,$9A           ; ARWL constant 154 for "ARWRow Array" Length
L9688:  LD      (HL),$00        ; DO loop to ZERO starting with vs1s
        INC     HL
        DJNZ    L9688                   ; (-$05) LOOP to DO for 154
        LD      A,D
        AND     A
        JR      Z,L969F                 ; (+$0e) IF 0<> False skip to ELSE #1
        LD      HL,$0F0F        ; write 00001111B 00001111B into vs1s in Static RAM
        LD      ($F18D),HL      ; ARWP write "ARWRow Pattern" in Static RAM (NOT vs1s)
        LD      HL,$1E05        ; write 00010100B 00000101B into ?? in Static RAM
        LD      ($F18F),HL      ; ARWP+2 write "ARWRow Pattern + 2" in Array in Static RAM
        JR      L96AB                   ; (+$0c) to THEN #1

; ELSE #1 ??
L969F:  LD      HL,$0F0F        ; write 00001111B 00001111B into vs1s in Static RAM
        LD      ($F18D),HL      ; ARWP write "ARWRow Pattern" in Static RAM (NOT vs1s)
        LD      HL,$1405        ; write 00010100B 00000101B into ?? in Static RAM
        LD      ($F18F),HL      ; ARWP+2 write "ARWRow Pattern + 2" in Array in Static RAM
L96AB:  LD      B,$00           ; THEN #1
L96AD:  LD      C,B             ; BEGIN 0 (really 256 !!) loops ??
        CALL    L868C           ; noded^ do ??
        LD      A,(HL)
        AND     A
        JR      Z,L96F9                 ; (+$44) IF 0<> False skip to THEN #2
        CALL    L8696           ; noder^ do ??
        LD      A,(HL)
        CP      $0C
        JR      NC,L96F9                ; (+$3c) IF CY False skip to THEN #2 too
        LD      A,($EEC6)       ; ARS read ( ARrow Status ) Byte-Variable
        AND     A
        JR      Z,L96CE                 ; (+$0b) IF 0<> False skip to ELSE #2
        LD      A,C
        CPL
        AND     $03
        LD      L,A
        LD      A,($F16D)       ; PLYRV + NOWD ($F12D + 64) read Byte for ?? in Static RAM
        CP      L
        JR      L96D1                   ; (+$03) to THEN #3

L96CE:  LD      A,$01           ; ELSE #2
        AND     A
; THEN #3 ??
L96D1:  JR      Z,L96F9                 ; (+$26) IF 0<> False skip to THEN #2
; ( CALCULATE PATTERN ADDRESS )
        PUSH    BC
        PUSH    DE
        INC     B
        LD      A,$F5           ; offset -11 for ARROW patterns MINUS size
; BEGIN tight loop
L96D8:  ADD     A,$0B           ; offset 11 for ARROW patterns size add back in ??
        DJNZ    L96D8                   ; (-$04) LOOP to tight loop BEGIN
        LD      C,A
        LD      HL,L9656        ; SYNTBL point to "First ARROW" in TaBLe
        ADD     HL,BC
        LD      C,(HL)
        INC     HL
        EX      DE,HL
        LD      HL,$F18D        ; ARWP point to "ARWRow Pattern" in Static RAM (NOT vs1s)
        ADD     HL,BC
        LD      B,$05
L96EA:  LD      A,(DE)          ; DO 5 final loops to ??
        INC     DE
        LD      (HL),A
        INC     HL
        LD      A,(DE)
        INC     DE
        LD      (HL),A
        INC     HL
        INC     HL
        INC     HL
        INC     HL
        DJNZ    L96EA                   ; (-$0d) LOOP to final DO
        POP     DE
        POP     BC
L96F9:  INC     B               ; THEN #2
        LD      A,B
        CP      $04
        JR      C,L96AD                 ; (-$52) END if CY~ False else to BEGIN
        POP     BC
        RET
; end of ( SYNAP ) !!

; { BLOCK 0091 }
; ( ARROW DISPLAY TASK )
; HEX
; CODE ARW
;  B PUSH,
;  Y PUSHX,
;  vaddr LIYD,
;  NOWC Y E LDX,
;  NOWR Y D LDX,
;  SYNAP CALL,
;  Y POPX,
;  B POP,
; NEXT
;
; ARW does "ARroW display task"
L9701:  PUSH    BC
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        CALL    L9682           ; SYNAP do ( SYNAP )
        POP     IY
        POP     BC
        JP      (IY)            ; indexed RETurn

; SUBR Acl ( ARROW CLASSIFY )
;  DISTANCE 1+ PLYRV + LDA,
;  A E MOV,
;  MAXDIST PLYRV + LDA,
;  RRC,
;  7F ANI,
;  E CMP,
;  CY~, IF,
;   A XRA,
;  ELSE,
;   1 A MVI,
;  THEN,
;  RET,
;
; Acl does "Arrow CLassify"
L9716:  LD      A,($F178)       ; DISTANCEH + PLYRV (75 + $F12D) read Byte for ?? in Static RAM
        LD      E,A
        LD      A,($F176)       ; MAXDIST + PLYRV (73 + $F12D) read Byte for ?? in Static RAM
        RRCA
        AND     $7F             ; 01111111B mask for ??
        CP      E
        JR      C,L9726                 ; (+$03) IF CY~ False skip to ELSE
        XOR     A
        JR      L9728                   ; (+$02) to THEN

L9726:  LD      A,$01           ; ELSE
L9728:  RET                     ; THEN

; SUBR Pac
;  Acl CALL,
;  A E MOV,
;  ARS LDA,
;  E CMP,
;  RZ,
;  E A MOV,
;  ARS STA,
;  1 A MVI,
;  MYFLAG ARV + STA,
;  RET,
;
; Pac does ??
L9729:  CALL    L9716           ; Acl do "Arrow CLassify"
        LD      E,A
        LD      A,($EEC6)       ; ARS read ( ARrow Status ) Byte-Variable in Static RAM
        CP      E
        RET     Z
        LD      A,E
        LD      ($EEC6),A       ; ARS write ( ARrow Status ) Byte-Variable in Static RAM
        LD      A,$01
        LD      ($F373),A       ; MYFLAG + ARV (84 + $F31F) = 1 for ?? in Static RAM
        RET

; CODE Gb?
;  Y PUSHX,
;  B PUSH,
;  vaddr LIYD,
;  NOWD Y C LDX,
;  NOWR Y D LDX,
;  NOWC Y E LDX,
;  move:node CALL,
;  movecheck CALL,
;  CY, IF,
;   D NOWR Y STX,
;   E NOWC Y STX,
;  THEN,
;  B POP,
;  Y POPX,
; NEXT
; DECIMAL
; -->
;
; Gb? does ??
L973C:  PUSH    IY
        PUSH    BC
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      C,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        CALL    L8D90           ; movecheck do "MOVE CHECKer"
        JR      NC,L975A                ; (+$06) IF CY False skip
        LD      (IY+$3E),D      ; NOWR offset 62 for ( CURRENT Row )
        LD      (IY+$3F),E      ; NOWC offset 63 for ( CURRENT Column )
L975A:  POP     BC
        POP     IY
        JP      (IY)            ; indexed RETurn
; end of { BLOCK 0091 }

; { BLOCK 0127 }
; ( ARROW TASK FELLA )
; : ERW DIVG ERASEWRITE DIVG ;
;
; ERW does "ERaseWrite" from Terse
L975F:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L1DFC           ; ERASEWRITE do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00B0           ; ... TerseRETurn

; : A-T ;TASK: DIVG
;  NULPAT ANIM! 1STWRITE XOR-ON 8 XPAND!-ON
;  BEGIN
; ( NEED TO CHANGE? )
;   PLYRV GRCD ARS B@ IF Gb? THEN
;   NULPAT ANIM! ERW
;   ESTPOS ARW 0 ARWP ANIM! ERW
;   POA WAIT DIVG 0 END ;
;
; -->
;
; A-T does "Arrow Task fella"
L9768:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00BC           ; NULPAT "pushWORD to System stack"
        DW      L81AD           ; for un-colored 0x0 BLANK pattern
        ;
        DW      L1BE2           ; ANIM! do Set up BLANK Pattern for ??
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for Color 2 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ; BEGIN loop ( NEED TO CHANGE? )
L977B:  DW      L00BC           ; PLYRV "pushWORD to System stack"
        DW      $F12D           ; for Word "PLaYeR Vector" base in Static RAM
        ;
        DW      L84F7           ; GRCD do ??
        ;
        DW      L00BC           ; ARS "pushWORD to System stack"
        DW      $EEC6           ; for ( ARrow Status ) Byte-Variable in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; _IF False skip to THEN
        DW      L03CD,L978D     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L973C           ; Gb? do ??
        ; _THEN
L978D:  DW      L00BC           ; NULPAT "pushWORD to System stack"
        DW      L81AD           ; for un-colored 0x0 BLANK pattern
        ;
        DW      L1BE2           ; ANIM! do Set up BLANK Pattern for ??
        ;
        DW      L975F           ; ERW do "ERaseWrite" ??
        ;
        DW      L88DF           ; ESTPOS do ??
        ;
        DW      L9701           ; ARW do "ARroW display task"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; ARWP "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $F18D           ; point to "ARWRow Pattern" Array in Static RAM (NOT vs1s)
        ;
        DW      L1BE2           ; ANIM! do Set up ?? Pattern for ??
        ;
        DW      L975F           ; ERW do "ERaseWrite" ??
        ;
        DW      L84E4           ; POA do ??
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; END or loop to BEGIN if False
        DW      L03CD,L977B     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { ARROW TASK FELLAs } !!

; { BLOCK 0120 }
; ( PLACE TREASURE IN MAZE ) XC? IFTRUE
;  4 C= T-LIM
;  TABLE T/I THEFLOWER , THESYM , THEJEWEL , THESTAR , 0 ,
;
; T/I for "place Treasure In maze" BONUS animation tables table
L97B1:  DW      L2842           ; THEFLOWER for FLOWERS
        DW      L275F           ; THESYM ?? for CYMBAL ??
        DW      L27DD           ; THEJEWEL for DIAMONDS
        DW      L26F3           ; THESTAR for STARS
        DW      $0000           ; NULL for end of BONUS table

;  TABLE T/F FL , SYM , JL1 , ST1 ,
;
; T/F for "Treasure Fixed-at-4" single BONUS patterns table
L97BB:  DW      L27EC           ; FL for 1 FLOWER
        DW      L2702           ; SYM ?? for 1 CYMBAL ??
        DW      L276E           ; JL1 for 1 DIAMOND
        DW      L2658           ; ST1 for 1 4-point STAR
; end of ( PLACE TREASURE IN MAZE ) tables ??

; ( CAPTURED TREASURE DISPLAY STUFF )
;  : TP-1 -82 SWAP 15 * + 95 ;
;
; TP-1 does "Place Treasure in maze #1"
L97C3:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFAE           ; -82 for ??
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0F             ; 15 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5F             ; 95 for ??
        ;
        DW      L00B0           ; ... TerseRETurn

;  : TP-2 82 SWAP 15 * - 95 ;
;
; TP-2 does "Place Treasure in maze #2"
L97D6:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $52             ; 82 for ??
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0F             ; 15 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5F             ; 95 for ??
        ;
        DW      L00B0           ; ... TerseRETurn

;  : T-POS NERDUP IF TP-2 ELSE TP-1 THEN ;
;
; T-POS does "Treasure POSition"
L97E8:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ; IF False to ELSE
        DW      L03CD,L97F5     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L97D6           ; TP-2 do "Place Treasure in maze #2"
        ; (done so Jump to THEN)
        DW      L03C5,L97F7     ; TerseJUMP to ??
        ; ELSE
L97F5:  DW      L97C3           ; TP-1 do "Place Treasure in maze #1"
        ; THEN
L97F7:  DW      L00B0           ; ... TerseRETurn

;  : TRw 96 SWAP T/F @ WRITEP ;
;
; TRw does "TReasure Write"
L97F9:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $60             ; 96 for ??
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L00D8           ; T/F "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      L97BB           ; for "Treasure Fixed-at-4" single BONUS patterns table
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L8B40           ; WRITEP do "Determine location and COPY TREASURE ITEMS"
        ;
        DW      L00B0           ; ... TerseRETurn

;  : T-DIS DUP T-POS ROT TRw ;
;
; T-DIS does "Treasure DISplay" (NOT used !!)
L9809:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L97E8           ; T-POS do "Treasure POSition"
        ;
        DW      L02ED           ; ROT do "Pop DE, Pop HL, EX (SP),HL then Push DE, Push (Old SP) to New System stack"
        ;
        DW      L97F9           ; TRw do "TReasure Write"
        ;
        DW      L00B0           ; ... TerseRETurn

;  : Tgr1 0 tr# B@ -DUP IF 0 DO I TP-1 I TRw LOOP THEN ;
;
; Tgr1 does "GRowl out Player 1 Treasures" on;y !!
L9814:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; tr# "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E384           ; for ( TReasure pointer ) base in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0217           ; -DUP do "DUPlicate Top of System stack IF Not Zero"
        ; IF False to THEN
        DW      L03CD,L9831     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; _TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L97C3           ; TP-1 do "Place Treasure in maze #1"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L97F9           ; TRw do "TReasure Write"
        ; _TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; THEN
L9831:  DW      L00B0           ; ... TerseRETurn

;  : Tgr2 1 tr# B@ -DUP IF 0 DO I TP-2 I TRw LOOP THEN ;
; OTHERWISE : Tgr1 ; : Tgr2 ; IFEND
; -->
;
; Tgr2 does "GRowl out Player 2 Treasures" only !!
L9833:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00CD           ; tr# "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E384           ; for ( TReasure pointer ) base in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0217           ; -DUP do "DUPlicate Top of System stack IF Not Zero"
        ; IF False to THEN
        DW      L03CD,L9850     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; _TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L97D6           ; TP-2 do "Place Treasure in maze #2"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L97F9           ; TRw do "TReasure Write"
        ; _TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; THEN
L9850:  DW      L00B0           ; ... TerseRETurn
; end of  ( CAPTURED TREASURE DISPLAY STUFF ) !!

; { BLOCK 0144 }
; ( TASK FOR A HUNK OF TREASURE IN THE MAZE )
; XC? IFTRUE : TRS-T ;TASK:
;  BEGIN DIVG TR# B@ T-LIM < WHILE HIDE?
;  SELF PUSH:CCR >TREASURE NODE^ ! ( HAVE PTR PT AT ME )
;  NULPAT ANIM! ' CH:R SETCO COGO
;  ( MAKE SELF APPEAR )
;  ESTPOS TR# B@ T/I @ ANIM! 1STWRITE
;  XOR-ON EMOV
;  10 TIMEBSCALE!
;  POA GO DIVG GA# B@ -DUP IF 5 MIN 200 * ELSE 100 THEN
;  INCSCORE TREA-S
;  NULPAT ANIM! ERASEWRITE DIVG
;  TR# B@ DUP T-POS ROT TRw TR# 1+WPB! 0 0 Snm ( REHIDETH )
;  2 TIMER!-ON WAIT
;  REPEAT ; OTHERWISE : TRS-T ; : TRSV ; IFEND
; -->
;
; TRS-T does "Task for a hunk of TReaSure in the maze"
L9852:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ; BEGIN (WHILE REPEAT) loop
L9855:  DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L0754           ; TR# do "get TReasure pointer for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00C5           ; T-LIM "pushBYTE to System stack"
        DB      $04             ; constant 4 for "Treasure LIMit"
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; WHILE False to loop Exit (aka WHILE True continue in BEGIN ... REPEAT loop)
        DW      L03CD,L98E6     ; WHILE < False ConditionalJUMP to loop Exit
        ;
        DW      L940C           ; HIDE? do ??
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L844F           ; PUSH:CCR do ??
        ;
        DW      L00C5           ; >TREASURE "pushBYTE to System stack"
        DB      $19             ; constant 25 for ??
        ;
        DW      L8680           ; node^ do "NODE Zammer ( COL ROW DISP --- ^ )"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ; ( HAVE PTR PT AT ME )
        DW      L00BC           ; NULPAT "pushWORD to System stack"
        DW      L81AD           ; for un-colored 0x0 BLANK pattern
        ;
        DW      L1BE2           ; ANIM! do Set up BLANK Pattern for ??
        ;
        DW      L00BC           ; CH:R "pushWORD to System stack"
        DW      L95B9           ; point to "CHamber Revealer" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ; ( MAKE SELF APPEAR )
        DW      L88DF           ; ESTPOS do ??
        ;
        DW      L0754           ; TR# do "get TReasure pointer for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00D8           ; T/I "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      L97B1           ; for 4 ANIMATION LOOPS "Treasure In maze" table
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L1BE2           ; ANIM! do Set up selected BONUS ANIMATION Loop for ??
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L8517           ; EMOV do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L1F0A           ; TIMEBSCALE! do ??
        ;
        DW      L84E4           ; POA do ??
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0217           ; -DUP do "DUPlicate Top of System stack IF Not Zero"
        ; _IF False to ELSE
        DW      L03CD,L98B5     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $C8             ; 200 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ; _(done so Jump to THEN)
        DW      L03C5,L98B8     ; TerseJUMP to ??
        ; _ELSE
L98B5:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $64             ; 100 for ??
        ; _THEN
L98B8:  DW      L8C9B           ; INCSCORE do "INCrement SCORE times (SCore MULT + 1)"
        ;
        DW      L36DB           ; TREA-S does ??
        ;
        DW      L00BC           ; NULPAT "pushWORD to System stack"
        DW      L81AD           ; for un-colored 0x0 BLANK pattern
        ;
        DW      L1BE2           ; ANIM! do Set up BLANK Pattern for ??
        ;
        DW      L1DFC           ; ERASEWRITE do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L0754           ; TR# do "get TReasure pointer for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L97E8           ; T-POS do "Treasure POSition"
        ;
        DW      L02ED           ; ROT do "Pop DE, Pop HL, EX (SP),HL then Push DE, Push (Old SP) to New System stack"
        ;
        DW      L97F9           ; TRw do "TReasure Write"
        ;
        DW      L0754           ; TR# do "get TReasure pointer for CURRENT player"
        ;
        DW      L07D3           ; 1+WPB! do "INCREMENT WRITE-protectedBYTE in (SP)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L84AF           ; Snm do ??
        ; ( REHIDETH )
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ; REPEAT loop to BEGIN always
        DW      L03C5,L9855     ; TerseJUMP to ??
        ; (loop Exit)
L98E6:  DW      L00B0           ; ... TerseRETurn
; end of { TASK FOR A HUNK OF TREASURE IN THE MAZE } !!

; { BLOCK 0122 }
; ( CHECK PLAYER INTERCEPT WITH TREASURE )
;
; SUBR TR:CHK
;  O-M LDA,
;  A ANA,
;  RZ,
;  NOWR Y D LDX,
;  NOWC Y E LDX,
;  PLYRV DISTANCE 1+ + LDA,
;  8 CPI,
;  CY~, IF,
;   A C MOV,
;   PLYRV MAXDIST + LDA,
;   C SUB,
;   8 CPI,
;   RNC,
;   PLYRV NOWD + LDA,
;   A C MOV,
;   move:node CALL,
;  THEN,
;  >TREASURE C MVI,
;  node^ CALL,
;  M C MOV,
;  H INX,
;  M B MOV,
;  B A MOV,
;  C ORA,
;  RZ,
;  XCHG,
;  MYFLAG H LXI,
;  B DAD,
;  1 M MVI,
;  XCHG,
;  0 M MVI,
;  H DCX,
;  0 M MVI,
; RET,
; -->
; ;S
;
; TR:CHK does "CHecK player intercept with TReasure" routine
L98E8:  LD      A,($EEEB)       ; O-M read ( Object Moving ) Byte-Variable in Static RAM
        AND     A
        RET     Z
        LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      A,($F178)       ; PLYRV + DISTANCEH ($F12D + 75) read Byte for ?? in Static RAM
        CP      $08
        JR      C,L9909                 ; (+$0f) IF CY~ False skip to ELSE
        LD      C,A
        LD      A,($F176)       ; PLYRV + MAXDIST ($F12D + 73) read Byte for ?? in Static RAM
        SUB     C
        CP      $08
        RET     NC
        LD      A,($F16D)       ; PLYRV + NOWD ($F12D + 64) for ?? in Static RAM
        LD      C,A
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
L9909:  LD      C,$19           ; >TREASURE constant 25
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      C,(HL)
        INC     HL
        LD      B,(HL)
        LD      A,B
        OR      C
        RET     Z
        EX      DE,HL
        LD      HL,$0054        ; MYFLAG offset 84 for ( build in neato FLAG )
        ADD     HL,BC
        LD      (HL),$01        ; True ??
        EX      DE,HL
        LD      (HL),$00
        DEC     HL
        LD      (HL),$00
        RET
; end of { CHECK PLAYER INTERCEPT WITH TREASURE } !!

; TARCHK does "TARget CHecK ??" routine
L9922:  PUSH    BC
        PUSH    DE
        PUSH    HL
        LD      D,(IY+$3C)      ; INTR offset 60 for ( INiTiaL Row )
        LD      E,(IY+$3D)      ; INTC offset 61 for ( INiTiaL Column )
        LD      C,$18           ; NODMSK constant 24 for ??
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        BIT     7,(HL)          ; NMEXS bit 7 for ??
        JP      Z,L0000         ; to RESET !! Robby Roto
        POP     HL
        POP     DE
        POP     BC
        RET

; L9939: junque ?? (a ChecKsum Byte ??)
        LD      D,C

; { BLOCK 0073 }
; ( ROUTE SEARCH ROUTINE ROUTINES )
; SUBR FORKETH
;  PCHL,
;
; FORKETH does "JumP to (HL)" subroutine
L993A:  JP      (HL)

; SUBR VIS?
;  H PUSH,
;  B PUSH,
;  Y PUSHX,
;  H POP,
;  VISMAT B LXI,
;  B DAD,
;  E C MOV,
;  0 B MVI,
;  B DAD,
;  D A MOV,
;  BIT^ CALL,
;  M ANA,
;  B POP,
;  H POP,
;  RET,
;
; VIS? does "Route search routine ??" routine
L993B:  PUSH    HL
        PUSH    BC
        PUSH    IY
        POP     HL
        LD      BC,$FFE3        ; VISMAT offset -29 for ??
        ADD     HL,BC
        LD      C,E
        LD      B,$00
        ADD     HL,BC
        LD      A,D
        CALL    L81BA           ; BIT^ do "Bit in A to Mask Translation"
        AND     (HL)
        POP     BC
        POP     HL
        RET

; SUBR SETVIS
;  H PUSH,
;  B PUSH,
;  Y PUSHX,
;  H POP,
;  VISMAT B LXI,
;  B DAD,
;  E C MOV,
;  0 B MVI,
;  B DAD,
;  D A MOV,
;  BIT^ CALL,
;  M ORA,
;  A M MOV,
;  B POP,
;  H POP,
;  RET,
;
; SETVIS does ?? routine
L9950:  PUSH    HL
        PUSH    BC
        PUSH    IY
        POP     HL
        LD      BC,$FFE3        ; VISMAT offset -29 for ??
        ADD     HL,BC
        LD      C,E
        LD      B,$00
        ADD     HL,BC
        LD      A,D
        CALL    L81BA           ; BIT^ do "Bit in A to Mask Translation"
        OR      (HL)
        LD      (HL),A
        POP     BC
        POP     HL
        RET

; SUBR ZAPVIS
;  B PUSH,
;  H PUSH,
;  VISMAT B LXI,
;  Y PUSHX,
;  H POP,
;  B DAD,
;  NCOLS DO,
;  0 M MVI,
;  H INX,
;  LOOP,
;  H POP,
;  B POP,
;  RET,
;
; ZAPVIS does ?? routine
L9966:  PUSH    BC
        PUSH    HL
        LD      BC,$FFE3        ; VISMAT offset -29 for ??
        PUSH    IY
        POP     HL
        ADD     HL,BC
        LD      B,$0B           ; NCOLS constant 11
L9971:  LD      (HL),$00        ; DO loop to ZERO starting with ??
        INC     HL
        DJNZ    L9971                   ; (-$05) LOOP to DO for 11 ??
        POP     HL
        POP     BC
        RET

; SUBR Mnd
;  TARCHK CALL,
;  SETVIS CALL,
;  MYBOSS Y A LDX,
;  A TPL X STX,
;  MYBOSS 1+ Y A LDX,
;  A TPL 1+ X STX,
;  D A MOV,
;  RLC,
;  RLC,
;  RLC,
;  RLC,
;  E ORA,
;  A TRC X STX,
;  C TD X STX,
;  TREECK Y L LDX,
;  TREECK 1+ Y H LDX,
;  FORKETH CALL, ( END CHECK? )
;  TEL D LXI,
;  D DADX,
;  RET,
; -->
;
; Mnd does "generate NoDe" routine
L9979:  CALL    L9922           ; TARCHK do "TARget CHecK ??"
        CALL    L9950           ; SETVIS do ??
        LD      A,(IY-$0F)      ; MYBOSS offset -15 MINUS ??
        LD      (IX+$00),A      ; TPL offset 0
        LD      A,(IY-$0E)      ; MYBOSSH offset -14 MINUS ??
        LD      (IX+$01),A      ; TPLH offset 1
        LD      A,D
        RLCA
        RLCA
        RLCA
        RLCA
        OR      E
        LD      (IX+$02),A      ; TRC offset 2
        LD      (IX+$03),C      ; TD offset 3
        LD      L,(IY-$0D)      ; TREECK offset -13 MINUS ??
        LD      H,(IY-$0C)      ; TREECKH offset -12 MINUS ??
        CALL    L993A           ; FORKETH do "JumP to (HL)" to ( END CHECK? )
        LD      DE,$0004        ; TEL constant 4 for ??
        ADD     IX,DE
        RET
; end of { ROUTE SEARCH ROUTINE ROUTINES } !!

; { BLOCK 0138 }
; ( GENERATE TREE ENTRYS FOR ONE ENTRY )
; SUBR GENTE
;  MPL0 C MVI,
;  node^ CALL,
;  H PUSH,
;  4 B MVI,
;  LDAR,
;  3 ANI,
;  A C MOV,
;  BEGIN,
;   H POP,
;   H PUSH,
;   B A MOV,
;   0 B MVI,
;   B DAD,
;   A B MOV,
;   M A MOV,
;   A ANA,
;   0<>, IF,
;    D PUSH,
;    move:node CALL,
;    VIS? CALL,
;    Mnd CZ, ( GENERATE NODE )
;    D POP,
;   THEN,
;   C A MOV,
;   A INR,
;   3 ANI,
;   A C MOV,
;  LOOP,
;  H POP,
;  RET,
; -->
;
; GENTE does "GENerate Tree Entrys for one entry" routine
L99A6:  LD      C,$08           ; MPL0 constant 8 for ??
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        PUSH    HL
        LD      B,$04           ; for 4 loops
        LD      A,R
        AND     $03             ; random 0 through 3
        LD      C,A
L99B3:  POP     HL              ; BEGIN loop 4 times
        PUSH    HL
        LD      A,B
        LD      B,$00
        ADD     HL,BC
        LD      B,A
        LD      A,(HL)
        AND     A
        JR      Z,L99C9                 ; (+$0b) IF 0<> False skip
        PUSH    DE
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        CALL    L993B           ; VIS? do "Route search routine ??"
        CALL    Z,L9979         ; if ?? Mnd do "generate NoDe"
        POP     DE
L99C9:  LD      A,C
        INC     A
        AND     $03
        LD      C,A
        DJNZ    L99B3                   ; (-$1d) LOOP to BEGIN
        POP     HL
        RET
; end of ( GENERATE TREE ENTRYS FOR ONE ENTRY ) !!

; { BLOCK 0139 }
;  ( ADVANCE TREE ONE DEPTH DOWN )
; SUBR ADVT
;  MYBOSS Y L LDX,
;  MYBOSS 1+ Y H LDX,
;  H INX,
;  H INX,
;  M E MOV,
;  E A MOV,
;  RRC,
;  RRC,
;  RRC,
;  RRC,
;  15 ANI,
;  A D MOV,
;  E A MOV,
;  15 ANI,
;  A E MOV,
;  GENTE CALL,
;  MYBOSS Y L LDX,
;  MYBOSS 1+ Y H LDX,
;  TEL D LXI,
;  D DAD,
;  M E MOV,
;  H INX,
;  M D MOV,
;  D INX,
;  D A MOV,
;  E ORA,
;  0=, IF,
;   H INX,
;  ELSE,
;   H DCX,
;  THEN,
;  L MYBOSS Y STX,
;  H MYBOSS 1+ Y STX,
;  ADVT JRNZ,
;  -1 X 0 MVIX,
;  X INXX,
;  -1 X 0 MVIX,
;  X INXX,
;  RET,
; -->
;
; ADVT does "ADVance Tree one depth down" routine (also ADVT label !!)
L99D2:  LD      L,(IY-$0F)      ; MYBOSS offset -15 MINUS ??
        LD      H,(IY-$0E)      ; MYBOSSH offset -14 MINUS ??
        INC     HL
        INC     HL
        LD      E,(HL)
        LD      A,E
        RRCA
        RRCA
        RRCA
        RRCA
        AND     $0F
        LD      D,A
        LD      A,E
        AND     $0F
        LD      E,A
        CALL    L99A6           ; GENTE do "GENerate Tree Entrys for one entry"
        LD      L,(IY-$0F)      ; MYBOSS offset -15 MINUS ??
        LD      H,(IY-$0E)      ; MYBOSSH offset -14 MINUS ??
        LD      DE,$0004        ; TEL constant 4 for ??
        ADD     HL,DE
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        INC     DE
        LD      A,D
        OR      E
        JR      NZ,L99FF                ; (+$03) IF 0= False skip to ELSE
        INC     HL
        JR      L9A00                   ; (+$01) to THEN

L99FF:  DEC     HL              ; ELSE
; THEN ?? previous info ??
L9A00:  LD      (IY-$0F),L      ; MYBOSS offset -15 MINUS ??
L9A03:  LD      (IY-$0E),H      ; MYBOSSH offset -14 MINUS ??
        JR      NZ,L99D2                ; (-$36) to Start of ADVT !!
        LD      (IX+$00),$FF    ; TPL offset 0 ?? or not ?? = -1 for ??
        INC     IX
        LD      (IX+$00),$FF    ; 0+1 ?? TPLH offset 1 ?? = -1 for ??
        INC     IX
        RET
; end of ( ADVANCE TREE ONE DEPTH DOWN ) !!

; { BLOCK 0140 }
; ( FIND PATH ROUTINE )
; ( BC=TARGET R,C DE= NOWR,NOWC HL= ENDCHK IY= TREE RAM )
; CODE FPSS
;  H POP,
;  X PUSHX,
;  Y PUSHX,
;  B PUSH,
;  vaddr LIYD,
;  ZAPVIS CALL,
;  A XRA,
;  A FNDPTR Y STX,
;  A FNDPTR 1+ Y STX,
;  A MYBOSS Y STX,
;  A MYBOSS 1+ Y STX,
;  NOWR Y D LDX,
;  NOWC Y E LDX,
;  L TREECK Y STX,
;  H TREECK 1+ Y STX,
;  Y PUSHX,
;  X POPX,
;  TREES B LXI,
;  B DADX,
;  X PUSHX,
;  DISTANCE Y A LDX,
;  DISTANCE 1+ Y ORAX,
;  0=, IF,
;   0 PMOD Y MVIX,
;   GENTE CALL,
;  ELSE,
; -->
;
; { BLOCK 0074 }
; ( IN MIDDLE OF PATH - MAKE ENTRYS FOR TWO OPTIONS )
;   1 PMOD Y MVIX,
;   NOWD Y A LDX,
;   CMA,
;   3 ANI, ( REVERSE TO SOURCE )
;   A C MOV,
;   D PUSH,
;   Mnd CALL,
;   D POP,
;   NOWD Y C LDX,
;   move:node CALL,
;   Mnd CALL,
;  THEN,
;  H POP,
;  L MYBOSS Y STX,
;  H MYBOSS 1+ Y STX,
;  -1 X 0 MVIX,
;  X INXX,
;  -1 X 0 MVIX,
;  X INXX,
;  X PUSHX,
;  D POP,
;  E FRONTIER Y STX,
;  D FRONTIER 1+ Y STX,
;  B POP,
;  Y POPX,
;  X POPX,
; NEXT
;
; FPSS does "Find Path" routine
; note:( BC=TARGET R,C DE= NOWR,NOWC HL= ENDCHK IY= TREE RAM )
L9A15:  POP     HL
        PUSH    IX
        PUSH    IY
        PUSH    BC
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        CALL    L9966           ; ZAPVIS do ??
        XOR     A
        LD      (IY-$09),A      ; FNDPTR offset -9 MINUS ??
        LD      (IY-$08),A      ; FNDPTRH offset -8 MINUS ??
        LD      (IY-$0F),A      ; MYBOSS offset -15 MINUS ??
        LD      (IY-$0E),A      ; MYBOSSH offset -14 MINUS ??
        LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      (IY-$0D),L      ; TREECK offset -13 MINUS ??
        LD      (IY-$0C),H      ; TREECKH offset -12 MINUS ??
        PUSH    IY
        POP     IX
        LD      BC,$FE54        ; TREES constant -428 for ?? in Static RAM
        ADD     IX,BC
        PUSH    IX
        LD      A,(IY+$4A)      ; DISTANCE offset 74
        OR      (IY+$4B)        ; DISTANCEH offset 75
        JR      NZ,L9A57                ; (+$09) IF 0= False skip to ELSE
        LD      (IY-$07),$00    ; PMOD offset -7 MINUS ??
        CALL    L99A6           ; GENTE do "GENerate Tree Entrys for one entry"
        JR      L9A70                   ; (+$19) to THEN

; ELSE ( IN MIDDLE OF PATH - MAKE ENTRYS FOR TWO OPTIONS )
L9A57:  LD      (IY-$07),$01    ; PMOD offset -7 MINUS ??
        LD      A,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        CPL
        AND     $03             ; ( REVERSE TO SOURCE )
        LD      C,A
        PUSH    DE
        CALL    L9979           ; Mnd do "generate NoDe"
        POP     DE
        LD      C,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        CALL    L9979           ; Mnd do "generate NoDe"
L9A70:  POP     HL              ; THEN
        LD      (IY-$0F),L      ; MYBOSS offset -15 MINUS ??
        LD      (IY-$0E),H      ; MYBOSSH offset -14 MINUS ??
        LD      (IX+$00),$FF    ; 0 TPL offset 0 ?? = -1 for ??
        INC     IX
        LD      (IX+$00),$FF    ; 0+1 TPLH offset 1 ?? = -1 for ??
        INC     IX
        PUSH    IX
        POP     DE
        LD      (IY-$11),E      ; FRONTIER offset -17 MINUS ??
        LD      (IY-$10),D      ; FRONTIERH offset -16 MINUS ??
        POP     BC
        POP     IY
        POP     IX
        JP      (IY)            ; indexed RETurn
; end of ( FIND PATH ROUTINE ) !!

; last of { BLOCK 0074 } !! but mising TREELP ??
; F= TREELP
; F= SCANBK
; F= SCAN1
; SUBR BANGTREE
; <ASSEMBLE
;  FRONTIER Y E LDX,
;  FRONTIER 1+ Y D LDX,
;  D PUSH,
;  X POPX,
;  FNDPTR Y L LDX,
;  FNDPTR 1+ Y H LDX,
;  L A MOV,
;  H ORA,
;  SCAN1 JRNZ,
;  ADVT CALL,
;  X PUSHX,
;  D POP,
;  E FRONTIER Y STX,
;  D FRONTIER 1+ Y STX,
;  A XRA,
;  RET,
; -->
;
; { BLOCK 0199 }
; ( MORE )
; LABEL SCAN1
;  0 B LXI,
; LABEL SCANBK
;  M E MOV,
;  C M MOV,
;  H INX,
;  M D MOV,
;  B M MOV,
;  H DCX,
;  H B MOV,
;  L C MOV,
;  E A MOV,
;  D ORA,
;  0<>, IF,
;   XCHG,
;   SCANBK JMPR,
;  THEN,
;  1 A MVI,
;  A ANA,
;  RET,
; ASSEMBLE>
;
; BANGTREE does ?? routine
L9A93:  LD      E,(IY-$11)      ; FRONTIER offset -17 MINUS ??
        LD      D,(IY-$10)      ; FRONTIERH offset -16 MINUS ??
        PUSH    DE
        POP     IX
        LD      L,(IY-$09)      ; FNDPTR offset -9 MINUS ??
        LD      H,(IY-$08)      ; FNDPTRH offset -8 MINUS ??
        LD      A,L
        OR      H
        JR      NZ,L9AB4                ; (+$0e) if ?? to SCAN1
        CALL    L99D2           ; ADVT does "ADVance Tree one depth down"
        PUSH    IX
        POP     DE
        LD      (IY-$11),E      ; FRONTIER offset -17 MINUS ??
        LD      (IY-$10),D      ; FRONTIERH offset -16 MINUS ??
        XOR     A
        RET

; SCAN1 label ( MORE )
L9AB4:  LD      BC,$0000        ; 0 for ?? will do (up to) 256 loops !!
L9AB7:  LD      E,(HL)          ; SCANBK label (for fake BEGIN, LOOP, !!)
        LD      (HL),C
        INC     HL
        LD      D,(HL)
        LD      (HL),B
        DEC     HL
        LD      B,H
        LD      C,L
        LD      A,E
        OR      D
        JR      Z,L9AC6                 ; (+$03) IF 0<> False exit to THEN
        EX      DE,HL
        JR      L9AB7                   ; (-$0f) fake LOOP to SCANBK

; THEN ??
L9AC6:  LD      A,$01
        AND     A
        RET

; last of { BLOCK 0199 } !!
; CODE LAH
;  Y PUSHX,
;  X PUSHX,
;  B PUSH,
;  vaddr LIYD,
;  BANGTREE CALL,
;  B POP,
;  X POPX,
;  Y POPX,
;  0=, IF,
;   0 H LXI,
;  ELSE,
;   H PUSH,
;   1 H LXI,
;  THEN,
;  H PUSH,
; NEXT
; -->
;
; LAH does ?? routine
L9ACA:  PUSH    IY
        PUSH    IX
        PUSH    BC
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        CALL    L9A93           ; BANGTREE do ??
        POP     BC
        POP     IX
        POP     IY
        JR      NZ,L9AE2                ; (+$05) IF 0= False skip to ELSE
        LD      HL,$0000        ; 0 for ?? False
        JR      L9AE6                   ; (+$04) to THEN

L9AE2:  PUSH    HL              ; ELSE
        LD      HL,$0001
L9AE6:  PUSH    HL              ; THEN
        JP      (IY)            ; indexed RETurn
; end of ( MORE ) !!

; { BLOCK 0142 }
; ( ROUTINE TO FIND BEST PATH TOWARDS TARGET )
; ( CHECK ROUTINE - ARE WE HOME YET? )
; SUBR BE?
;  INTR Y A LDX,
;  D CMP,
;  RNZ,
;  INTC Y A LDX,
;  E CMP,
;  RNZ,
;  X PUSHX,
;  H POP,
;  L FNDPTR Y STX,
;  H FNDPTR 1+ Y STX,
;  RET,
;
; BE? does "find BEst path towards target" routine
L9AE9:  LD      A,(IY+$3C)      ; INTR offset 60 for ( INiTiaL Row )
        CP      D               ; ( CHECK ROUTINE - ARE WE HOME YET? )
        RET     NZ
        LD      A,(IY+$3D)      ; INTC offset 61 for ( INiTiaL Column )
        CP      E
        RET     NZ
        PUSH    IX
        POP     HL
        LD      (IY-$09),L      ; FNDPTR offset -9 MINUS ??
        LD      (IY-$08),H      ; FNDPTRH offset -8 MINUS ??
        RET

; CODE FOLLOWTRACK
;  Y PUSHX,
;  vaddr LIYD,
;  TRACKPTR Y L LDX,
;  TRACKPTR 1+ Y H LDX,
;  M E MOV,
;  H INX,
;  M D MOV,
;  H INX,
;  H INX,
;  E TRACKPTR Y STX,
;  D TRACKPTR 1+ Y STX,
;  M L MOV,
;  0 H MVI,
;  Y POPX,
;  H PUSH,
; NEXT
; ASSEMBLE>
; -->
;
; FOLLOWTRACK does ??
L9AFD:  PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      L,(IY-$0B)      ; TRACKPTR offset -11 MINUS ??
        LD      H,(IY-$0A)      ; TRACKPTRH offset -10 MINUS ??
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        INC     HL
        INC     HL
        LD      (IY-$0B),E      ; TRACKPTR offset -11 MINUS ??
        LD      (IY-$0A),D      ; TRACKPTRH offset -10 MINUS ??
        LD      L,(HL)
        LD      H,$00
        POP     IY
        PUSH    HL
        JP      (IY)            ; indexed RETurn
; end of { ROUTINE TO FIND BEST PATH TOWARDS TARGET } !!

; { BLOCK 0180 }
; ( PLAYER HOSTAGE INTERFACE JUNK )
; SUBR dishos
;  0 H LXI,
;  PLYRV AHEAD + SHLD,
;  PLYRV BEHIND + SHLD,
;  A XRA,
;  Hctr STA,
;  0 HOSTAB H LXI,
;  BEGIN,
;   M E MOV,
;   H INX,
;   M D MOV,
;   H INX,
;   D A MOV,
;   E ORA,
;  0<>, WHILE,
;   XCHG,
;   OBJSV B LXI,
;   B DAD,
;   M A MOV,
;   HSATP CPI,
;   0=, IF,
;    HSFREE M MVI,
;    ASSMSV OBJSV - B LXI,
;    B DAD,
;    ASNOT M MVI,
;    MYFLAG ASSMSV - B LXI,
;    B DAD,
;    1 M MVI,
;    BEHIND MYFLAG - B LXI,
;    B DAD,
;    A XRA,
;    A M MOV,
;    H INX,
;    A M MOV,
;    H INX,
;    A M MOV,
;    H INX,
;    A M MOV,
;   THEN,
;   XCHG,
;  REPEAT,
;  RET,
;
; dishos does "player HOStage interface junk" routine
L9B1C:  LD      HL,$0000        ; 0 for ??
        LD      ($F188),HL      ; PLYRV + AHEAD ($F12D + 91) = 0 for ?? in Static RAM
        LD      ($F186),HL      ; PLYRV + BEHIND ($F12D + 89) = 0 for ?? in Static RAM
        XOR     A
        LD      ($EEC7),A       ; Hctr write Byte 0 into "Hostage CounTeR" Byte-Variable in Static RAM
        LD      HL,L8374        ; HOSTAB point to 3-word "HOStage vector TABle"
L9B2C:  LD      E,(HL)          ; BEGIN loop
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      A,D
        OR      E
        JR      Z,L9B5B                 ; (+$27) WHILE 0<> False to loop Exit
        EX      DE,HL
        LD      BC,$005D        ; OBJSV offset 93 for ( OBJect State Variable )
        ADD     HL,BC
        LD      A,(HL)
        CP      $01             ; HSATP constant 1 for ( HoStage Attached to Player )
        JR      NZ,L9B58                ; (+$1a) IF 0= False exit to THEN
        LD      (HL),$00        ; HSFREE constant 0 for ( HoStage FREE )
        LD      BC,$0001        ; ASSMSV - OBJSV (94 - 93) = 1 for ??
        ADD     HL,BC
        LD      (HL),$00        ; ASNOT for ( Assimilation State NOT assimilated )
        LD      BC,$FFF6        ; MYFLAG - ASSMSV (84 - 94) = -10 MINUS !!
        ADD     HL,BC
        LD      (HL),$01
        LD      BC,$0005        ; BEHIND - MYFLAG (89 - 84) = 5
        ADD     HL,BC
        XOR     A
        LD      (HL),A
        INC     HL
        LD      (HL),A
        INC     HL
        LD      (HL),A
        INC     HL
        LD      (HL),A
L9B58:  EX      DE,HL
        JR      L9B2C                   ; (-$2f) REPEAT to BEGIN

L9B5B:  RET                     ; (loop Exit)

; CODE DISHOS
;  B PUSH,
;  dishos CALL,
;  B POP,
; NEXT
; -->
;
; DISHOS does "player HOStage interface junk" from Terse
L9B5C:  PUSH    BC
        CALL    L9B1C           ; dishos do "player HOStage interface junk" routine
        POP     BC
        JP      (IY)            ; indexed RETurn
; end of_PLAYER HOSTAGE INTERFACE JUNK ) !!

; { BLOCK 0252 }
; ( more PLAYER HOSTAGE INTERFACE JUNK )
; SUBR cutup
;  Y PUSHX,
;  X POPX,
;  BEGIN,
;   Hctr H LXI,
;   M DCR,
;   BEHIND X E LDX,
;   BEHIND 1+ X D LDX,
;   A XRA,
;   A BEHIND X STX,
;   A BEHIND 1+ X STX,
;   A AHEAD X STX,
;   A AHEAD 1+ X STX,
;   D A MOV,
;   E ORA,
;  0<>, WHILE,
;   D PUSH,
;   X POPX,
;   HSFREE OBJSV X MVIX,
;   ASNOT ASSMSV X MVIX, ( AND UNASSIM )
;   1 MYFLAG X MVIX,
;  REPEAT,
;  RET,
; -->
;
; cutup does "MORE player HOStage interface junk" routine
L9B63:  PUSH    IY
        POP     IX
; BEGIN loop
L9B67:  LD      HL,$EEC7        ; Hctr point to "Hostage CounTeR" Byte-Variable in Static RAM
        DEC     (HL)
        LD      E,(IX+$59)      ; BEHIND offset 89 for ( fellow BEHIND me )
        LD      D,(IX+$5A)      ; BEHINDH offset 90
        XOR     A
        LD      (IX+$59),A      ; BEHIND offset 89 for ( fellow BEHIND me )
        LD      (IX+$5A),A      ; BEHINDH offset 90
        LD      (IX+$5B),A      ; AHEAD offset 91 for ( fellow AHEAD of me )
        LD      (IX+$5C),A      ; AHEADH offset 92
        LD      A,D
        OR      E
        JR      Z,L9B93                 ; (+$11) WHILE 0<> False to loop Exit
        PUSH    DE
        POP     IX
        LD      (IX+$5D),$00    ; OBJSV offset 93 = HSFREE for ( HoStage FREE )
        LD      (IX+$5E),$00    ; ASSMSV offset 94 = ASNOT for ( AND UNASSIMilate_ )
        LD      (IX+$54),$01    ; MYFLAG offset 84 = 1 for "SET ME EATEN"
        JR      L9B67                   ; (-$2c) REPEAT to BEGIN

L9B93:  RET                     ; (loop Exit)
; end of ( more PLAYER HOSTAGE INTERFACE JUNK ) !!

; { BLOCK 0056 }
; ( FREE HOSTAGES FROM MONSTER )
; CODE FREM
;  B PUSH,
;  0 H LXI,
;  PLYRV AHEAD + SHLD,
;  PLYRV BEHIND + SHLD,
;  A XRA,
;  Hctr STA,
;  0 HOSTAB H LXI,
;  BEGIN,
;   M E MOV,
;   H INX,
;   M D MOV,
;   H INX,
;   D A MOV,
;   E ORA,
;  0<>, WHILE,
;   XCHG,
;   OBJSV B LXI,
;   B DAD,
;   M A MOV,
;   HSATM CPI,
;   0=, IF,
;    HSFREE M MVI,
;    ASSMSV OBJSV - B LXI,
;    B DAD,
;    ASNOT M MVI,
;    MYFLAG ASSMSV - B LXI,
;    B DAD,
;    1 M MVI,
;    BEHIND MYFLAG - B LXI,
;    B DAD,
;    A XRA,
;    A M MOV,
;    H INX,
;    A M MOV,
;    H INX,
;    A M MOV,
;    H INX,
;    A M MOV,
;   THEN,
;   XCHG,
;  REPEAT,
;  B POP,
; NEXT
; -->
;
; FREM does "FREe hostages from Monster"
L9B94:  PUSH    BC
        LD      HL,$0000        ; 0 for ??
        LD      ($F188),HL      ; PLYRV + AHEAD ($F12D + 91) = 0 for ?? in Static RAM
        LD      ($F186),HL      ; PLYRV + BEHIND ($F12D + 89) = 0 for ?? in Static RAM
        XOR     A
        LD      ($EEC7),A       ; Hctr write Byte 0 into "Hostage CounTeR" Byte-Variable in Static RAM
        LD      HL,L8374        ; HOSTAB point to 3-word "HOStage vector TABle"
L9BA5:  LD      E,(HL)          ; BEGIN loop
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      A,D
        OR      E
        JR      Z,L9BD4                 ; (+$27) WHILE 0<> False to loop Exit
        EX      DE,HL
        LD      BC,$005D        ; OBJSV offset 93 for ( OBJect State Variable )
        ADD     HL,BC
        LD      A,(HL)
        CP      $02             ; HSATM constant 2 for ( HoSTagE Attached to Monster )
        JR      NZ,L9BD1                ; (+$1a) IF 0= False skip to THEN
        LD      (HL),$00        ; HSFREE constant 0 for ( HoStage FREE )
        LD      BC,$0001        ; ASSMSV - OBJSV (94 - 93) = 1 for ??
        ADD     HL,BC
        LD      (HL),$00        ; ASNOT for ( Assimilation State NOT assimilated )
        LD      BC,$FFF6        ; MYFLAG - ASSMSV (84 - 94) = -10 MINUS !!
        ADD     HL,BC
        LD      (HL),$01
        LD      BC,$0005        ; BEHIND - MYFLAG (89 - 84) = 5
        ADD     HL,BC
        XOR     A
        LD      (HL),A
        INC     HL
        LD      (HL),A
        INC     HL
        LD      (HL),A
        INC     HL
        LD      (HL),A
L9BD1:  EX      DE,HL           ; THEN
        JR      L9BA5                   ; (-$2f) REPEAT to BEGIN

L9BD4:  POP     BC              ; (loop Exit)
        JP      (IY)            ; indexed RETurn
; end of ( FREE HOSTAGES FROM MONSTER ) !!

; { BLOCK 0094 }
; ( HOSTAGE TABLE, HOSTAGE INTERCEPT CHECKER )
; ( CHECK HOSTAGE INTERCEPT WITH MONSTERS )
; HEX ( HOSTAGES INTERCEPT CHECKER, RUNS AS HOOK )
; SUBR HOS-MON?
;  FREEZE? CALL,
;  RNZ,
;  OBJSV Y A LDX,
;  HSATP CPI,
;  RNZ,
;  P-S LDA,
;  A DCR,
;  2 CPI,
;  RNC, ( MAKE SURE PLAYER IN MAZE )
;  EXX,
;  0280 B LXI,
;  PX-M CALL, ( WIDER WINDOW FOR MON - HOS )
;  0<>, IF,
;   1 MYFLAG Y MVIX, ( SET ME EATEN )
;   ASNOT ASSMSV Y MVIX,( SET UNASSIMILATED )
;   X PUSHX,
;   Y PUSHX,
;   D POP,
;   B POP,
;   XC? IFTRUE
;    JAWSV H LXI,
;    A ANA,
;    B DSBC,
;   OTHERWISE
;    1 A MVI,
;    A ANA,
;   IFEND
;   0=, IF,
;    HSFREE OBJSV Y MVIX,
;    XC? IFTRUE
;     chomp-s CALL,
;    IFEND
;   ELSE,
;    HSATM OBJSV Y MVIX,
;    MSSNA OBJSV X MVIX,
;    1 MYFLAG X MVIX,
;    B H MOV,
;    C L MOV,
;    FUZH CALL,
;   THEN,
;   X PUSHX,
;   cutup CALL,
;   X POPX,
;   HALTNOW CALL,
;  THEN,
;  EXX,
;  RET,
; DECIMAL
; -->
;
; HOS-MON? does "check HOStage intercept with Monsters, runs as hook"
L9BD7:  CALL    L8523           ; FREEZE? do "TEST F-F for Freeze Flag"
        RET     NZ
        LD      A,(IY+$5D)      ; OBJSV offset 93 for ( OBJect State Variable )
        CP      $01             ; HSATP constant 1 for ( HoStage Attached to Player )
        RET     NZ
        LD      A,($EEE6)       ; P-S read ( Player State ) Byte-Variable in Static RAM
        DEC     A
        CP      $02
        RET     NC              ; if ?? ( MAKE SURE PLAYER IN MAZE )
        EXX
        LD      BC,$0280        ; 640 for ( WIDER WINDOW FOR MON - HOS )
        CALL    L9117           ; PX-M do "set window for MON - HOS"
        JR      Z,L9C2B                 ; (+$3a) IF 0<> False exit to THEN #1
        LD      (IY+$54),$01    ; MYFLAG offset 84 = 1 for ( SET ME EATEN )
        LD      (IY+$5E),$00    ; ASSMSV offset 94 = ASNOT for ( set UNASsimilated )
        PUSH    IX
        PUSH    IY
        POP     DE
        POP     BC
        LD      HL,$F529        ; JAWSV point to "JAWS Vector" base in Static RAM
        AND     A
L9C03:  SBC     HL,BC
        JR      NZ,L9C10                ; (+$09) IF 0= False skip to ELSE
        LD      (IY+$5D),$00    ; OBJSV offset 93 = HSFREE for ( HoStage FREE )
        CALL    L35C7
        JR      L9C21                   ; (+$11)to THEN #2

; ELSE
L9C10:  LD      (IY+$5D),$02    ; OBJSV offset 93 = HSATM for ( HoSTagE Attached to Monster )
        LD      (IX+$5D),$03    ; OBJSV offset 93 = MSSNA for ( Monster State SNAtch hostage )
        LD      (IX+$54),$01    ; MYFLAG offset 84 = 1 for "SET ME EATEN"
        LD      H,B
        LD      L,C
        CALL    L9294           ; FUZH do "Force Hostage to have same position as interceptor"
L9C21:  PUSH    IX              ; THEN #2
        CALL    L9B63           ; cutup do "MORE player HOStage interface junk"
        POP     IX
        CALL    L91A8           ; HALTNOW do ??
L9C2B:  EXX                     ; THEN #1
        RET
; end of ( HOSTAGE TABLE, HOSTAGE INTERCEPT CHECKER ) !! (with NO table ??)

; { BLOCK 0300 }
; ( UNLINK ROUTINE )
; CODE UNLINK
;  Y PUSHX,
;  vaddr LIYD,
;  AHEAD Y E LDX,
;  AHEAD 1+ Y D LDX,
;  D PUSH,
;  XTIX,
;  A XRA,
;  A AHEAD Y STX,
;  A AHEAD 1+ Y STX,
;  A AHEAD X STX,
;  A AHEAD 1+ X STX,
;  A DRPO X STX,
;  A BEHIND Y STX,
;  A BEHIND 1+ Y STX,
;  A BEHIND X STX,
;  A BEHIND 1+ X STX,
;  X POPX,
;  Y POPX,
; NEXT
;
; UNLINK does ?? routine
L9C2D:  PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      E,(IY+$5B)      ; AHEAD offset 91 for ( fellow AHEAD of me )
        LD      D,(IY+$5C)      ; AHEADH offset 92
        PUSH    DE
        EX      (SP),IX
        XOR     A
        LD      (IY+$5B),A      ; AHEAD offset 91 for ( fellow AHEAD of me )
        LD      (IY+$5C),A      ; AHEADH offset 92
        LD      (IX+$5B),A      ; AHEAD offset 91 for ( fellow AHEAD of me )
        LD      (IX+$5C),A      ; AHEADH offset 92
        LD      (IX+$55),A      ; DRPO offset 85 for ( DRoP Off flag )
        LD      (IY+$59),A      ; BEHIND offset 89 for ( fellow BEHIND me )
        LD      (IY+$5A),A      ; BEHINDH offset 90
        LD      (IX+$59),A      ; BEHIND offset 89 for ( fellow BEHIND me )
        LD      (IX+$5A),A      ; BEHINDH offset 90
        POP     IX
        POP     IY
        JP      (IY)            ; indexed RETurn
; end of ( UNLINK ROUTINE ) !!

; { BLOCK 0136 }
; ( HOSTAGE INDEXER GOODIES )
; : I:H V#L * HOSV1 SWAP - ;
;
; I:H does "Index Hostages" (not used ??)
L9C5E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; V#L "pushBYTE to System stack"
        DB      $60             ; 96 for "Vector Length"
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L00BC           ; HOSV1 "pushWORD to System stack"
        DW      $EFB1           ; for "HOStage Vector" #1 base in Static RAM
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00B0           ; ... TerseRETurn

; : HOS#? HOSV1 SWAP - V#L / ;
;
; HOS#? does ?? (not used ??)
L9C6E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; HOSV1 "pushWORD to System stack"
        DW      $EFB1           ; for "HOStage Vector" #1 base in Static RAM
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00C5           ; V#L "pushBYTE to System stack"
        DB      $60             ; 96 for "Vector Length"
        ;
        DW      L041E           ; / do "word (SP) DIVide by (SP+2), Push QUOTIENT, Discard REMAINDER"
        ;
        DW      L00B0           ; ... TerseRETurn

; ( CALCULATE POSITION ON FREED HOSTAGE LINE )
; : FH-P -16 SWAP 16 * + 94 ;
;
; FH-P does "calculate Position on Freed Hostage line"
L9C7E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF0           ; -16 for ??
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $10             ; 16 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5E             ; 94 for ??
        ;
        DW      L00B0           ; ... TerseRETurn

; : H-DIS FH-P 96 JHOS-S WRITEP ;
; DECIMAL
;
; H-DIS does "Hostage DISplay"
L9C91:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L9C7E           ; FH-P do "calculate Position on Freed Hostage line"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $60             ; 96 for ??
        ;
        DW      L00BC           ; JHOS-S "pushWORD to System stack"
        DW      L288D           ; point to HAPPY-freed-HOSTAGE pattern
        ;
        DW      L8B40           ; WRITEP do "Determine location and COPY ?? ITEMS"
        ;
        DW      L00B0           ; ... TerseRETurn

; <ANIM-TBL Ha1 JHOS-S 100 TBL>
;
; Ha1 ?? display HAPPY HOSTAGE #1 table
L9C9F:  DB      $01,$00,$81     ; single entry
        ;
L9CA2:  DB      $64,$8D,$28     ; JHOS-S single HAPPY freed HOSTAGE pattern
        DB      $00,$A2,$9C     ; TBL (ANIM-TBL automatic ??) loop here

; <ANIM-TBL Ha2 IJHOS-S 100 TBL>
;
; Ha2 ?? display HAPPY HOSTAGE #2 table
L9CA8:  DB      $01,$00,$81     ; another single entry
        ;
L9CAB:  DB      $64,$AF,$28     ; IJHOS-S single HOLLOW happy HOSTAGE pattern
        DB      $00,$AB,$9C     ; TBL loop here

; <PER-ANIM-TBL Hsml Ha1 Ha2 TBL>
; -->
;
; Hsml ?? display alternating HAPPY HOSTAGES tables
L9CB1:  DB      $00,$00,$85     ; -6 for word + word entry ??
        ;
        DB      $A2,$9C         ; Ha1 to HAPPY freed HOSTAGE loop
        DB      $AB,$9C         ; Ha2 to HOLLOW happy HOSTAGE loop
; what ?? PER--ANIM-TBL ?? has NO $00 TBL loop here !!
; end of HAPPY HOSTAGES tables
; end of ( HOSTAGE INDEXER GOODIES ) !!

; { BLOCK 0225 }
; ( TASK FOR A TEST HOSTAGE )
; : H-T ;TASK: DIVG H-H-D DISPF VB!
; EMOV 1STWRITE HSFREE OBJSV VB! RNIT BEGIN DIVG
; OBJSV VB@ HSFREE CASE 0 DELTADIST V! DVECT-ON
; DISTANCE V@ NOT IF PUSH:CCR G-D? NOT IF
; ESTPOS NULPAT ANIM! ERASEWRITE DIVG
; ' CH:R SETCO COGO XPAND-OFF THEN THEN
; ( SELF HOS#? 1+ DUP GA# B@ + 10 < IF
; I:M DUP HGSV OVB@ MPCHP >= IF
; MPRTH SWAP HGSV OVB! ELSE DROP THEN ELSE DROP THEN )
; JHOS-F ANIM!
; XOR-ON 10 TIMEBSCALE! 0 TIMEBMAX! POA GO
; ELSE HSATP CASE
; NULPAT ANIM! ERASEWRITE DIVG
; Hctr B@ CAPT-S Hsml ANIM!
; TBCL POA HOS-MON? HOOK!-ON
; -->
;
; { BLOCK 0230 }
; 100 INCSCORE HVECT-ON GO DIVG
; DEST? OBJSV VB@ HSATP = AND IF HSLPF OBJSV VB! THEN
; ( FOLLOW MONSTER TO NEW HANGOUT )
; ELSE HSATM CASE Hctr B@ DRUG-S JHOS-F ANIM!
; HVECT-ON
; 400 TIMER!-ON ( PREVENT HOSTAGE HANGUP )
; ( FOLLOW MONSTER TO ITS TARGET POSITION )
; POA GO DIVG
; UNLINK
; FLAG? NOT IF
; ARRIVE:NODE ESTPOS
; HSFREE OBJSV VB! ASNOT ASSMSV VB! THEN
; -->
;
; missing middle block ??
;
; missing end ??
;
; H-T does "task for a Test Hostage"
L9CB8:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00C5           ; H-H-D "pushBYTE to System stack"
        DB      $0C             ; constant 12 for ( Hostage to Hostage Distance )
        ;
        DW      L00C5           ; DISPF "pushBYTE to System stack"
        DB      $56             ; offset 86 for ( DISPlacement Factor )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L8517           ; EMOV do ??
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L00C5           ; HSFREE "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( HoStage FREE )
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L88F7           ; RNIT do ??
        ; BEGIN loop
L9CD3:  DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L8171           ; VB@ do ??
        ;
        DW      L00C5           ; HSFREE "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( HoStage FREE )
        ; _CASE "TEST State = 0 and Skip Over if False ?? or Continue if True"
        DW      L0427,L9D2E     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; DELTADIST "pushBYTE to System stack"
        DB      $4C             ; offset 76 for ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L88D6           ; DVECT-ON do "ACTIVATE Distance Vectoring"
        ;
        DW      L00C5           ; DISTANCE "pushBYTE to System stack"
        DB      $4A             ; offset 74 for ??
        ;
        DW      L815B           ; V@ do "PUSH (offset PLUS Vector ADDRess)"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; __IF False to THEN #1
        DW      L03CD,L9D15     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L844F           ; PUSH:CCR do ??
        ;
        DW      L86AE           ; G-D? do "test Grotto Drawn"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; ___IF False to THEN #2
        DW      L03CD,L9D15     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L88DF           ; ESTPOS do ??
        ;
        DW      L00BC           ; NULPAT "pushWORD to System stack"
        DW      L81AD           ; for un-colored 0x0 BLANK pattern
        ;
        DW      L1BE2           ; ANIM! do Set up BLANK Pattern for ??
        ;
        DW      L1DFC           ; ERASEWRITE do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00BC           ; CH:R "pushWORD to System stack"
        DW      L95B9           ; point to "CHamber Revealer" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L1E3A           ; XPAND!-OFF do "Turn eXPAND ?? OFF"
        ; __THEN #1 and THEN #2
L9D15:  DW      L00BC           ; JHOS-F "pushWORD to System stack"
        DW      L2851           ; for SAD-captured-HOSTAGE-in-box pattern
        ;
        DW      L1BE2           ; ANIM! do Set up CAPTURED HOSTAGE Pattern for ??
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L1F0A           ; TIMEBSCALE! do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L1F22           ; TIMEBMAX! do ??
        ;
        DW      L84E4           ; POA do ??
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ; _(end of CASE = 0 so ...)
        DW      L03C5,L9E2C     ; TerseJUMP to THENs
        ; _(Case = 0 ELSE label)
L9D2E:  DW      L00C5           ; HSATP "pushBYTE to System stack"
        DB      $01             ; constant 1 for ( HoStage Attached to Player )
        ; _CASE "TEST State = 1 and Skip Over if False ?? or Continue if True"
        DW      L0427,L9D80     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00BC           ; NULPAT "pushWORD to System stack"
        DW      L81AD           ; for un-colored 0x0 BLANK pattern
        ;
        DW      L1BE2           ; ANIM! do Set up BLANK Pattern for ??
        ;
        DW      L1DFC           ; ERASEWRITE do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00BC           ; Hctr "pushWORD to System stack"
        DW      $EEC7           ; for "Hostage CounTeR" Byte-Variable in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L3646           ; CAPT-S do ??
        ;
        DW      L00BC           ; Hsml "pushWORD to System stack"
        DW      L9CB1           ; for display "2 HAPPY HOSTAGE pattern loops"
        ;
        DW      L1BE2           ; ANIM! do Set up FREED HOSTAGE Animations for ??
        ;
        DW      L8CA2           ; TBCL do ??
        ;
        DW      L84E4           ; POA do ??
        ;
        DW      L00BC           ; HOS-MON? "pushWORD to System stack"
        DW      L9BD7           ; point to "check HOStage intercept with Monsters, runs as hook"
        ;
        DW      L1BCF           ; HOOK!-ON do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $64             ; 100 for ??
        ;
        DW      L8C9B           ; INCSCORE do "INCrement SCORE times (SCore MULT + 1)"
        ;
        DW      L928B           ; HVECT-ON do ??
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L1B95           ; DEDEST?ST do ??
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L8171           ; VB@ do ??
        ;
        DW      L00C5           ; HSATP "pushBYTE to System stack"
        DB      $01             ; constant 1 for ( HoStage Attached to Player )
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ; __IF False to THEN #3
        DW      L03CD,L9D7C     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; HSLPF "pushBYTE to System stack"
        DB      $03             ; constant 3 for ( HoStage Leaving PlayField )
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L817C           ; VB! do ??
        ; __THEN #3 and (end of CASE = 1 so ...)
L9D7C:  DW      L03C5,L9E2C     ; TerseJUMP to THENs
        ; _(Case = 1 ELSE label)
L9D80:  DW      L00C5           ; HSATM "pushBYTE to System stack"
        DB      $02             ; constant 2 for ( HoSTagE Attached to Monster )
        ; _CASE "TEST State = 2 and Skip Over if False ?? or Continue if True"
        DW      L0427,L9DC5     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00BC           ; Hctr "pushWORD to System stack"
        DW      $EEC7           ; for "Hostage CounTeR" Byte-Variable in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L35E7           ; DRUG-S do ??
        ;
        DW      L00BC           ; JHOS-F "pushWORD to System stack"
        DW      L2851           ; for SAD-captured-HOSTAGE-in-box pattern
        ;
        DW      L1BE2           ; ANIM! do Set up CAPTURED HOSTAGE Pattern for ??
        ;
        DW      L928B           ; HVECT-ON do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0190           ; 400 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L84E4           ; POA do ??
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L9C2D           ; UNLINK do ??
        ;
        DW      L1B5F           ; FLAG? do ??
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; __IF False to THEN #4
        DW      L03CD,L9DC1     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L8915           ; ARRIVE:NODE do "ARRIVE at NODE"
        ;
        DW      L88DF           ; ESTPOS do ??
        ;
        DW      L00C5           ; HSFREE  "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( HoStage FREE )
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00C5           ; ASNOT "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Assimilation State NOT assimilated )
        ;
        DW      L00C5           ; ASSMSV "pushBYTE to System stack"
        DB      $5E             ; offset 94 for ??
        ;
        DW      L817C           ; VB! do ??
        ; __THEN #4 (end of CASE = 2 so ...)
L9DC1:  DW      L03C5,L9E2C     ; TerseJUMP to THENs
        ;

; ?? WTF ?? no source code for the rest of this !!


        ; _(Case = 2 ELSE label)
L9DC5:  DW      L00C5           ; HSLPF "pushBYTE to System stack"
        DB      $03             ; constant 3 for ( HoStage Leaving PlayField ) ??
        ; _CASE "TEST State = 3 and Skip Over if False ?? or Continue if True"
        DW      L0427,L9E13     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L1C3A           ; PERINX! do ??
        ;
        DW      L92AF           ; EV:R do ??
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L8517           ; EMOV do ??
        ;
        DW      L843D           ; FREDH do "get FREeD Hostage counter"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L9C7E           ; FH-P do "calculate Position on Freed Hostage line"
        ;
        DW      L1B83           ; DESTY! do "convert +/- Y REL to PIXEL lines and save in VDESTY ??"
        ;
        DW      L1B71           ; DESTX! do "convert +/- X REL to ABSolute PIXELs and save in VDESTX ??"
        ;
        DW      L843D           ; FREDH do "get FREeD Hostage counter"
        ;
        DW      L0442           ; 1+B! do "Pop HL, ADD 1 to (HL)"
        ;
        DW      L00BC           ; Hctr "pushWORD to System stack"
        DW      $EEC7           ; for "Hostage CounTeR" Byte-Variable in Static RAM
        ;
        DW      L0448           ; 1-B! do "Pop HL, SUBtract 1 from (HL)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0F             ; 15 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L85BD           ; A->DEST/TIME do "vector between position and DEST in TIME given"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L8517           ; EMOV do ??
        ;
        DW      L37D0
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $C8             ; 200 for ??
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $32             ; 50 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L8C9B           ; INCSCORE do "INCrement SCORE times (SCore MULT + 1)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $04             ; 4 for ??
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L817C           ; VB! do ??
        ; _(end of CASE = 3 so ...)
        DW      L03C5,L9E2C     ; TerseJUMP to THENs
        ; _(Case = 3 ELSE label)
L9E13:  DW      L00C5           ; HSRES "pushBYTE to System stack"
        DB      $04             ; constant 4 for ( HoStage completely REScued )
        ; _CASE "TEST State = 4 and Skip Over if False ?? or Continue if True"
        DW      L0427,L9E2C     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00BC           ; Hsml "pushWORD to System stack"
        DW      L9CB1           ; for display "2 HAPPY HOSTAGE pattern loops"
        ;
        DW      L1BE2           ; ANIM! do Set up FREED HOSTAGE Animations for ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L1670           ; SLEEP do ??
        ; _(end of CASE = 4 so ...)
        DW      L03C5,L9E2C     ; TerseJUMP to THENs (equal to NO JUMP ??)
        ; _THEN THEN THEN THEN THEN for 5 CASEs
L9E2C:  DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; END or loop to BEGIN if False
        DW      L03CD,L9CD3     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of ( TASK FOR A TEST HOSTAGE ) !! missing Block(s) ??

; { BLOCK 0185 }
; ( DOOR STUFF )
; HEX : DORWR DIVG ST-X ST-Y ROT 828 SWAP WRITEP ; DECIMAL
;
; DORWR does "DOoR WRiter"
L9E34:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00C5           ; ST-X "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L00C5           ; ST-Y "pushBYTE to System stack"
        DB      $34             ; constant 52 for ??
        ;
        DW      L02ED           ; ROT do "Pop DE, Pop HL, EX (SP),HL then Push DE, Push (Old SP) to New System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0828           ; 2088 for ??
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L8B40           ; WRITEP do "Determine location and COPY different DOORS"
        ;
        DW      L00B0           ; ... TerseRETurn

; XC? IFTRUE
;  CODE TSET
;   DI,
;   H POP,
;   M A MOV,
;   A ANA,
;   0=, IF,
;    M INR,
;    0 H LXI,
;   ELSE,
;    1 H LXI,
;   THEN,
;   H PUSH,
;  NEXT
;
; TSET does ??
L9E49:  DI
        POP     HL
        LD      A,(HL)
        AND     A
        JR      NZ,L9E55                ; (+$06) IF 0= False exit to ELSE
        INC     (HL)
        LD      HL,$0000        ; 0 for ?? False
        JR      L9E58                   ; (+$03) to THEN

; ELSE ??
L9E55:  LD      HL,$0001        ; 1 for ?? True
L9E58:  PUSH    HL              ; THEN
        JP      (IY)            ; indexed RETurn

; : CLDR BEGIN DSM4 TSET WHILE SYNC REPEAT
;  DORS B@ IF DOR2 DORWR DOR1 DORWR 3 TIMER!-ON
;  WAIT DOR1 DORWR DOR0 DORWR DORS BZERO THEN DSM4 BZERO COGO ;
;
; CLDR does "CLose DooR"
L9E5B:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ; BEGIN (WHILE REPEAT) loop
L9E5C:  DW      L00BC           ; DSM4 "pushWORD to System stack"
        DW      $EEBF           ; for ( Door SeMiFORE ) Byte-Variable
        ;
        DW      L9E49           ; TSET do ??
        ; WHILE False to loop Exit (aka WHILE True continue in BEGIN ... REPEAT loop)
        DW      L03CD,L9E6C     ; WHILE TSET False ConditionalJUMP to loop Exit
        ;
        DW      L1660           ; SYNC do ??
        ; REPEAT loop to BEGIN always
        DW      L03C5,L9E5C     ; REPEAT TerseJUMP to ??
        ; (loop Exit)
L9E6C:  DW      L00BC           ; DORS "pushWORD to System stack"
        DW      $EEC4           ; for ( DOoR State ) Byte-Variable
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; IF False to THEN
        DW      L03CD,L9E9A     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; DOR2 "pushWORD to System stack"
        DW      L829F           ; unknown color Monochrome "DOORS are OPEN" pattern
        ;
        DW      L9E34           ; DORWR do "DOoR WRiter"
        ;
        DW      L00BC           ; DOR1 "pushWORD to System stack"
        DW      L8286           ; unknown color ?? Monochrome "DOORS opening" pattern
        ;
        DW      L9E34           ; DORWR do "DOoR WRiter"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; DOR1 "pushWORD to System stack"
        DW      L8286           ; unknown color ?? Monochrome "DOORS opening" pattern
        ;
        DW      L9E34           ; DORWR do "DOoR WRiter"
        ;
        DW      L00BC           ; DOR0 "pushWORD to System stack"
        DW      L827C           ; for unknown color Monochrome "DOOR closed" pattern
        ;
        DW      L9E34           ; DORWR do "DOoR WRiter"
        ;
        DW      L00BC           ; DORS "pushWORD to System stack"
        DW      $EEC4           ; for ( DOoR State ) Byte-Variable in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ; THEN
L9E9A:  DW      L00BC           ; DSM4 "pushWORD to System stack"
        DW      $EEBF           ; for ( Door SeMiFORE ) Byte-Variable in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00B0           ; ... TerseRETurn

;  ( OPEN DOOR ROUTINE )
;  : OPDR BEGIN DSM4 TSET WHILE SYNC REPEAT
;  DORS B@ 0= IF DOR0 DORWR DOR1 DORWR
;  3 TIMER!-ON WAIT DOR1 DORWR DOR2 DORWR DORS BONE THEN
;  DSM4 BZERO COGO ;
; OTHERWISE : CLDR COGO ; : OPDR COGO ; IFEND
; -->
;
; OPDR does "OPen DooR"
L9EA4:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ; BEGIN (WHILE REPEAT) loop
L9EA5:  DW      L00BC           ; DSM4 "pushWORD to System stack"
        DW      $EEBF           ; for ( Door SeMiFORE ) Byte-Variable in Static RAM
        ;
        DW      L9E49           ; TSET do ??
        ; WHILE False to loop Exit (aka WHILE True continue in BEGIN ... REPEAT loop)
        DW      L03CD,L9EB5     ; WHILE TSET False ConditionalJUMP to loop Exit
        ;
        DW      L1660           ; SYNC do ??
        ; REPEAT loop to BEGIN always
        DW      L03C5,L9EA5     ; REPEAT do "TerseJUMP to BEGIN label"
        ; (loop Exit)
L9EB5:  DW      L00BC           ; DORS "pushWORD to System stack"
        DW      $EEC4           ; for ( DOoR State ) Byte-Variable in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; IF False to THEN
        DW      L03CD,L9EE5     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; DOR0 "pushWORD to System stack"
        DW      L827C           ; for unknown color Monochrome "DOOR closed" pattern
        ;
        DW      L9E34           ; DORWR do "DOoR WRiter"
        ;
        DW      L00BC           ; DOR1 "pushWORD to System stack"
        DW      L8286           ; unknown color ?? Monochrome "DOORS opening" pattern
        ;
        DW      L9E34           ; DORWR do "DOoR WRiter"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; DOR1 "pushWORD to System stack"
        DW      L8286           ; unknown color ?? Monochrome "DOORS opening" pattern
        ;
        DW      L9E34           ; DORWR do "DOoR WRiter"
        ;
        DW      L00BC           ; DOR2 "pushWORD to System stack"
        DW      L829F           ; unknown color Monochrome "DOORS are OPEN" pattern
        ;
        DW      L9E34           ; DORWR do "DOoR WRiter"
        ;
        DW      L00BC           ; DORS "pushWORD to System stack"
        DW      $EEC4           ; for ( DOoR State ) Byte-Variable in Static RAM
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ; THEN
L9EE5:  DW      L00BC           ; DSM4 "pushWORD to System stack"
        DW      $EEBF           ; for ( Door SeMiFORE ) Byte-Variable in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0185 } !!

; { BLOCK 0130 }
; ( KEY MONITOR )
; <ANIM-TBL F-K KEY1 20 NULPAT 20 TBL>
; XC? NOT IFTRUE F-K C= ex-p IFEND
;
; F-K for "Flashing single KEY pattern" animation table above
L9EEF:  DB      $02,$00,$81     ; 2 entries, 0, and -2 for ??
        ;
L9EF2:  DB      $14,$FA,$25     ; KEY1 buried KEY with durations = 20
        DB      $14,$AD,$81     ; NULPAT Blank pattern
        DB      $00,$F2,$9E     ; TBL ?? and loop

; : EXAT ;TASK: START-COL START-ROW Snm DVECT-ON ESTPOS
;  1STWRITE XOR-ON
;  4 XPAND!-ON ex-p ANIM! BEGIN GO 0 END ;
;
; EXAT does ??
L9EFB:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L00C5           ; START-COL "pushBYTE to System stack"
        DB      $05             ; constant 5 for "START COLumn"
        ;
        DW      L00C5           ; START-ROW "pushBYTE to System stack"
        DB      $05             ; constant 5 for "START ROW"
        ;
        DW      L84AF           ; Snm do ??
        ;
        DW      L88D6           ; DVECT-ON do "ACTIVATE Distance Vectoring"
        ;
        DW      L88DF           ; ESTPOS do ??
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for Color 1 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; ex-p "pushWORD to System stack" (NOT ex-p constant F-K ...)
        DW      L8201           ; unknown color ?? Monochrome EXIT SIGN pattern (at L9EEF ??)
        ;
        DW      L1BE2           ; ANIM! do Set up EXIT SIGN pattern for ??
        ; BEGIN loop
L9F18:  DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; END or loop to BEGIN if False
        DW      L03CD,L9F18     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn

; : KEYMAN ;TASK:
;  DIVG
;  HIDE? DVECT-ON ESTPOS
;  SELF PUSH:CCR >TREASURE NODE!
; -->
;
; { BLOCK 0131 }
; ( KEY REVEALER )
;  NULPAT ANIM!
;  DIVG
;  ' CH:R SETCO COGO
;  1STWRITE
;  XPAND-OFF F-K ANIM! XOR-ON
;  POA DVECT-ON GO DIVG
;  KYOPEN OBJSV VB!
;  NULPAT ANIM! 1 TIMER!-ON GO DIVG
;  KEY-S
;  ' OPDR SETCO COGO GA# B@ NOT IF SELF EXAT THEN ;
; -->
;
; KEYMAN does "KEY MANager"
L9F22:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L940C           ; HIDE? do ??
        ;
        DW      L88D6           ; DVECT-ON do "ACTIVATE Distance Vectoring"
        ;
        DW      L88DF           ; ESTPOS do ??
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L844F           ; PUSH:CCR do ??
        ;
        DW      L00C5           ; >TREASURE do "pushBYTE to System stack"
        DB      $19             ; constant 25 for ??
        ;
        DW      L86ED           ; NODE! do ??
        ; KEY REVEALER
        DW      L00BC           ; NULPAT "pushWORD to System stack"
        DW      L81AD           ; for un-colored 0x0 BLANK pattern
        ;
        DW      L1BE2           ; ANIM! do Set up BLANK Pattern for ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00BC           ; CH:R "pushWORD to System stack"
        DW      L95B9           ; point to "CHamber Revealer" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L1E3A           ; XPAND!-OFF do "Turn eXPAND ?? OFF"
        ;
        DW      L00BC           ; F-K "pushWORD to System stack"
        DW      L9EEF           ; for "Flashing KEY" animation table
        ;
        DW      L1BE2           ; ANIM! do Set up BONUS animation Loop for KEY
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L84E4           ; POA do ??
        ;
        DW      L88D6           ; DVECT-ON do "ACTIVATE Distance Vectoring"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $01             ; 1 for ??
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00BC           ; NULPAT "pushWORD to System stack"
        DW      L81AD           ; for un-colored 0x0 BLANK pattern
        ;
        DW      L1BE2           ; ANIM! do Set up BLANK Pattern for ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L369C           ; KEY-S do ??
        ;
        DW      L00BC           ; OPDR "pushWORD to System stack"
        DW      L9EA4           ; point to "OPen DooR" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; IF False to THEN
        DW      L03CD,L9F88     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L9EFB           ; EXAT do ??
        ; THEN
L9F88:  DW      L00B0           ; ... TerseRETurn
; end of ( KEY MONITOR ) !!

; { BLOCK 0177 }
; ( INDEXER AND VISABLE MONSTER WRITER )
;
; SUBR VM-W ( VISABLE MONSTER WRITER )
;  CMCONST VLOGICSTAT Y BITX,
;  0=, IF,
;   VOPATH Y A LDX,
;   VOPAT Y ORAX,
;   0<>, IF,
;    VERASE CALL,
;   THEN, ( don't erase if no pattern )
;  ELSE,
;   CMCONST VLOGICSTAT Y RESX,
;  THEN,
;  CMXPND VLOGICSTAT Y BITX,
;  0=, IF,
;   INTCPT IN,
;   VWRITE CALL,
;   INTCPT IN,
;   A ANA,
;   0<>, IF,
;    1 A MVI,
;   THEN,
;   1 XRI,
;   VPERINX Y CMPX,
;   0<>, IF,
;    A VPERINX Y STX,
;    1 VANIMTIMER Y MVIX,
;    0 VANIMINX Y MVIX,
;   THEN,
;  ELSE,
;   CMXPND VLOGICSTAT Y RESX,
;  THEN,
;  transition JMP,
; -->
;
; VM-W does "Visable Monster Writer"
L9F8A:  BIT     CMCONST,(IY+$24); is CMCONST bit 2 of VLOGICSTAT offset 36 set ?
        JR      NZ,L9F9D                ; (+$0d) IF 0= False to ELSE #1 yes
        LD      A,(IY+$2B)      ; VOPATH offset 43
        OR      (IY+$2A)        ; VOPAT offset 42
        JR      Z,L9F9B                 ; (+$03) IF 0<> False skip
        CALL    L130D           ; VERASE do "load Pattern Board values to Erase with"
L9F9B:  JR      L9FA1                   ; (+$04) to THEN #1

; ELSE #1 (don't erase if no pattern) with CMCONST bit 2 of VLOGICSTAT offset 36 set then
L9F9D:  RES     CMCONST,(IY+$24) ; clear it
L9FA1:  BIT     CMXPND,(IY+$24) ; THEN #1 is CMXPND bit 1 of VLOGICSTAT offset 36 set ?
        JR      NZ,L9FC7                ; (+$20) IF 0= False to ELSE #2 yes
        IN      A,(INTST)       ; aka INTCPT inport =&(8) to CLEAR INTercept STatus
        CALL    L12DD           ; VWRITE do "load Pattern Board values to Draw with"
        IN      A,(INTST)       ; aka INTCPT inport =&(8) to READ INTercept STatus
        AND     A
        JR      Z,L9FB3                 ; (+$02) IF 0<> False skip
        LD      A,$01
L9FB3:  XOR     $01
        CP      (IY+$3A)        ; VPERINX offset 58 for "VECTORS PERspective INdeX"
        JR      Z,L9FC5                 ; (+$0b) IF 0<> False skip
        LD      (IY+$3A),A      ; VPERINX offset 58 again
        LD      (IY+$37),$01    ; VANIMTIMER offset 55
        LD      (IY+$38),$00    ; VANIMINX offset 56
L9FC5:  JR      L9FCB                   ; (+$04) to THEN #2

; ELSE #2 with CMXPND bit 1 of VLOGICSTAT offset 36 set
L9FC7:  RES     CMXPND,(IY+$24) ; clear it
L9FCB:  JP      L136A           ; THEN #2 to re-entry point for ??
; end of ( INDEXER AND VISABLE MONSTER WRITER ) !!

; { BLOCK 0208 }
; ( USEFULL MONSTER STUFF )
; ( MONSTER CLASSIFY ROUTINE )
; BTABLE CLSTB 1 B, 0 B, 0 B, 0 B, 2 B,
;
; CLSTB 5-byte table for "USEFULL MONSTER STUFF"
L9FCE:  DB       $01
        DB       $00
        DB       $00
        DB       $00
        DB       $02

; : CLASS? SELF MON#? CLSTB B@ ;
;
; CLASS? does "monster CLASSify routine"
L9FD3:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L8363           ; MON#? do ??
        ;
        DW      L00CD           ; CLSTB "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      L9FCE           ; 5-byte table for "USEFULL MONSTER STUFF"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; HEX
; : IMP SELF MON#? MZP @ 4 + + B@
;  DUP 0F AND SWAP SWAN 0F AND ;
;
; IMP does ??
L9FE0:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L8363           ; MON#? do ??
        ;
        DW      L8446           ; MZP do "get CURRENT MaZe Pointer"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0507           ; 15 "BYTE Pusher" for ??
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L1969           ; do "Multiply Low byte of Top of Stack by 16"
        ;
        DW      L0507           ; 15 "BYTE Pusher" for ??
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L00B0           ; ... TerseRETurn

; : SPOTMONS H-P-D DISPF VB!
;  CLASS? IF Src
;  ELSE IMP THEN
;  DUP INTC VB! NOWC VB!
;  DUP INTR VB! NOWR VB! ESTPOS ;
;
; DECIMAL
; -->
;
; SPOTMONS does ??
LA001:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; H-P-D "pushBYTE to System stack"
        DB      $10             ; constant 16 for ( Hostage to Player Distance )
        ;
        DW      L00C5           ; DISPF "pushBYTE to System stack"
        DB      $56             ; offset 86 for ( DISPlacement Factor )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L9FD3           ; CLASS? do "monster CLASSify routine"
        ; IF False to ELSE
        DW      L03CD,LA016     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L84EE           ; Src do ??
        ; (done so Jump to THEN)
        DW      L03C5,LA018     ; TerseJUMP to ??
        ; ELSE
LA016:  DW      L9FE0           ; IMP do ??
        ; THEN
LA018:  DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00C5           ; INTC "pushBYTE to System stack"
        DB      $3D             ; offset 61 for ( INiTiaL Column )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00C5           ; NOWC "pushBYTE to System stack"
        DB      $3F             ; offset 63 for ( CURRENT Column )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00C5           ; INTR "pushBYTE to System stack"
        DB      $3C             ; offset 60 for ( INiTiaL Row )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00C5           ; NOWR "pushBYTE to System stack"
        DB      $3E             ; offset 62 for ( CURRENT Row )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L88DF           ; ESTPOS do ??
        ;
        DW      L00B0           ; ... TerseRETurn
; end of ( USEFULL MONSTER STUFF )

; { BLOCK 0211 }
; ( MONSTER VECTOR ROUTINE )
; ( FREEZE IF PLAYER DEAD OR MAGIC ACTIVE )
; F= Mfz
; SUBR MON-VR
; <ASSEMBLE
;  PSW PUSH,
;  MAFLG LDA,
;  A ANA,
;  Mfz JRNZ,
;  P-S LDA,
;  PLDOA CPI,
;  0=, IF,
;   Y PUSHX,
;   H POP,
;   MONV1 D LXI,
;   A ANA,
;   D DSBC,
;   Mfz JRNZ,
;   OBJSV Y A LDX,
;   MSSNA CPI,
;   Mfz JRNZ,
;  THEN,
;  DISTVECT CALL,
;  OBJSV Y A LDX,
;  MSSNA CPI,
;  LKBUN CZ,
;  PSW POP,
;  RET,
; LABEL Mfz
;  B PUSH,
;  CALCXY CALL,
;  B POP,
;  PSW POP,
;  RET,
; ASSEMBLE>
;
; MON-VR does "MONster VECTOR" Routine
LA034:  PUSH    AF
        LD      A,($EEC3)       ; MAFLG read ( MAgic in use FLaG ) Byte-Variable
        AND     A               ; FREEZE IF MAGIC ACTIVE
        JR      NZ,LA061                ; (+$26) if ?? to Mfz
        LD      A,($EEE6)       ; P-S read ( Player State ) Byte-Variable in Static RAM
        CP      $03             ; PLDOA for "PLayer Dead On Arrival"
        JR      NZ,LA054                ; (+$12) IF 0= False to THEN
        PUSH    IY
        POP     HL
        LD      DE,$FD51        ; MONV1 point to "MONster Vector" #1 in Static RAM
        AND     A               ; FREEZE IF PLAYER DEAD
        SBC     HL,DE
        JR      NZ,LA061                ; (+$14) if ?? to Mfz
        LD      A,(IY+$5D)      ; OBJSV offset 93 for ( OBJect State Variable )
        CP      $03             ; MSSNA constant for ( Monster State SNAtch hostage )
        JR      NZ,LA061                ; (+$0d) if ?? to Mfz ??
; THEN ??
LA054:  CALL    L8897           ; DISTVECT do "DISTance VECToring"
        LD      A,(IY+$5D)      ; OBJSV offset 93 for ( OBJect State Variable )
        CP      $03             ; MSSNA constant for ( Monster State SNAtch hostage )
        CALL    Z,L9107         ; if ?? LKBUN do ??
        POP     AF
        RET

; Mfz does ??
LA061:  PUSH    BC
        CALL    L8764           ; CALCXY do "CALCulate X Y position of object"
        POP     BC
        POP     AF
        RET

; : MVECT-ON MON-VR CV-ON ;
;
; MVECT-ON does "turn Monster VECTor ON"
LA068:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; MON-VR "pushWORD to System stack"
        DW      LA034           ; do "MONster VECTOR" Routine
        ;
        DW      L88C1           ; CV-ON do "write CUSVEC and ACTIVATE Distance Vectoring"
        ;
        DW      L00B0           ; ... TerseRETurn

; CODE EXX
;  RET,
; NEXT
; -->
;
; EXX does NULL routine ?? that's a stupid name !!
LA071:  RET

; LA072: would do "Terse exit"
        JP      (IY)            ; indexed RETurn
; end of { BLOCK 0211 } !!

; { BLOCK 0214 }
; ( HOOK ROUTINE TO FUDGE MONSTERS VELOCITY IF IN REVEALED ZONE )
; F= Mfs
; SUBR MONSPD
; <ASSEMBLE
;  EXX,
;  NOWD Y C LDX,
;  NOWC Y E LDX,
;  NOWR Y D LDX,
;  noder^ CALL,
;  M A MOV,
;  DISTANCE Y 1+ CMPX,
;  Mfs JRNC,
;  move:node CALL,
;  C A MOV,
;  CMA,
;  3 ANI,
;  A C MOV,
;  noder^ CALL,
;  A B MOV,
;  noded^ CALL,
;  M A MOV,
;  B SUB,
;  DISTANCE 1+ Y CMPX,
;  CY~, IF,
;  LABEL Mfs
;   MSPDS Y E LDX,
;   MSPDS 1+ Y D LDX,
;  ELSE,
;   MSPDF Y E LDX,
;   MSPDF 1+ Y D LDX,
;  THEN,
;  E DELTADIST Y STX,
;  D DELTADIST 1+ Y STX,
;  EXX,
;  RET,
; ASSEMBLE>
; HEX
;
; MONSPD does "fudge MONsters velocity if in revealed zone" routine
LA074:  EXX
        LD      C,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        CALL    L8696           ; noder^ do ??
        LD      A,(HL)
        CP      (IY+$4B)        ; DISTANCEH offset 75
        JR      NC,LA09D                ; (+$16) to Mfs do ??
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        LD      A,C
        CPL
        AND     $03
        LD      C,A
        CALL    L8696           ; noder^ do ??
        LD      B,A
        CALL    L868C           ; noded^ do ??
        LD      A,(HL)
        SUB     B
        CP      (IY+$4B)        ; DISTANCEH offset 75
        JR      C,LA0A5                 ; (+$08) IF CY~ False to ELSE
; Mfs label to read Word MSPDS for ( Monster Slow SPeeD ) Variable below
LA09D:  LD      E,(IY-$03)      ; MSPDS offset -3 MINUS ??
        LD      D,(IY-$02)      ; MSPDSH offset -2 ??
        JR      LA0AB                   ; (+$06) to THEN

; ELSE read Word MSPDF for ( Monster Fast SPeeD ) Variable below
LA0A5:  LD      E,(IY-$05)      ; MSPDF offset -5 MINUS ??
        LD      D,(IY-$04)      ; MSPDFH offset -4 ??
; THEN ??
LA0AB:  LD      (IY+$4C),E      ; DELTADIST offset 76
        LD      (IY+$4D),D      ; DELTADISTH offset 77
        EXX
        RET

; : MVSET SPEEDE B@ 7 MIN 30 * MMSV VB@ MMSCU = IF 80 + THEN
; CLASS? 40 * + GA# B@ IF 180 ELSE 100 THEN + DUP MSPDS V!
; 40 + MSPDF V! MONSPD HOOK!-ON ;
; DECIMAL
; -->
;
; MVSET does ??
LA0B3:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; SPEEDE "pushWORD to System stack" ?? should be $EEEA !!
        DW      $EEE9           ; for ( non accelerating SPEED valuE ) Byte-Variable in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $30             ; 48 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L8171           ; VB@ do ??
        ;
        DW      L00C5           ; MMSCU "pushBYTE to System stack"
        DB      $05             ; constant 5 for ( Monster Motion state SCUrrying )
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; IF False to THEN
        DW      L03CD,LA0D7     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $80             ; 128 for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ; THEN
LA0D7:  DW      L9FD3           ; CLASS? do "monster CLASSify routine"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $40             ; 64 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; IF False to ELSE
        DW      L03CD,LA0F0     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0180           ; 384 for ??
        ; (done so Jump to THEN)
        DW      L03C5,LA0F4     ; TerseJUMP to ??
        ; ELSE
LA0F0:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $0100           ; 256 for ??
        ; THEN
LA0F4:  DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00BC           ; MSPDS "pushWORD to System stack" MINUS ??
        DW      $FFFD           ; offset -3 for ( Monster Slow SPeeD ) Variable
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $40             ; 64 for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00BC           ; MSPDF "pushWORD to System stack" MINUS ??
        DW      $FFFB           ; offset -5 for ( Monster Fast SPeeD ) Variable
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L00BC           ; MONSPD "pushWORD to System stack"
        DW      LA074           ; point to "fudge MONsters velocity if in revealed zone"
        ;
        DW      L1BCF           ; HOOK!-ON do ??
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0214 } !!

; { BLOCK 0107 }
; ( SUBROUTINE TO CHECK FOR VALID BANISHMENT POINT )
; F= AARF
; F= NULRET
; SUBR OKBAN
; <ASSEMBLE
;  B PUSH,
;  D A MOV,
;  A ANA,
;  AARF JRZ,
;  NROWS 1- CPI,
;  AARF JRZ,
;  START-ROW CPI,
;  E A MOV,
;  0=, IF,
;   START-COL CPI,
;   AARF JRZ,
;  THEN,
;  A ANA,
;  AARF JRZ,
;  NCOLS 1- CPI,
;  AARF JRZ,
;  X PUSHX,
;  XCHG, ( HL= COORDS )
;  EXX,
;  PCONFT H LXI,
;  NEARBYLIST CALL,
;  X POPX,
;  AARF JRNZ,
;  Y PUSHX,
;  MON-LS H LXI,
;  TRC X B LDX,
;  B A MOV,
;  15 ANI,
;  A C MOV,
;  B A MOV,
;  RRC,
;  RRC,
;  RRC,
;  RRC,
;  15 ANI,
;  A B MOV,
;  BEGIN,
;   M E MOV,
;   H INX,
;   M D MOV,
;   H INX,
;   D A MOV,
;   E ORA,
;  0<>, WHILE,
;   D PUSH,
;   Y POPX,
;   OBJSV Y A LDX,
;   MSSNA CPI,
;   0=, IF,
;    INTR Y A LDX,
;    B CMP,
;    0=, IF,
;     INTC Y A LDX,
;     C CMP,
;     0=, IF,
;      Y POPX,
;      AARF JMPR,
;     THEN,
;    THEN,
;   THEN,
;  REPEAT,
; -->
;
; { BLOCK 0215 }
;  Y POPX, ( WE PASS )
;  B INTR Y STX,
;  C INTC Y STX,
;  X PUSHX,
;  D POP,
;  E FNDPTR Y STX,
;  D FNDPTR 1+ Y STX,
; LABEL AARF
;  B POP,
; LABEL NULRET
;  RET,
; ASSEMBLE>
;
; OKBAN does "CHECK for valid BANishment point" routine
LA111:  PUSH    BC
        LD      A,D
        AND     A
        JR      Z,LA181                 ; (+$6b) if ?? to AARF
        CP      $05             ; NROWS - 1 (6 - 1) for 5
        JR      Z,LA181                 ; (+$67) if ?? to AARF
        CP      $05             ; START-ROW constant 5 for "START ROW"
        LD      A,E
        JR      NZ,LA123                ; (+$04) IF 0= False skip
        CP      $05             ; START-COL 5 for ??
        JR      Z,LA181                 ; (+$5e) if ?? to AARF
LA123:  AND     A
        JR      Z,LA181                 ; (+$5b) if ?? to AARF
        CP      $0A             ; NCOLS - 1 (11 - 1) for 10
        JR      Z,LA181                 ; (+$57) if ?? to AARF
        PUSH    IX
        EX      DE,HL           ; HL= COORDS
        EXX
        LD      HL,L9354        ; PCONFT point to 10-Word "PCONF vector Table" ??
        CALL    L931F           ; NEARBYLIST do "--"
        POP     IX
        JR      NZ,LA181                ; (+$49) if ?? to AARF
        PUSH    IY
        LD      HL,L910B        ; MON-LS point to 5-Word "MONster-LS" table ??
        LD      B,(IX+$02)      ; TRC offset 2
        LD      A,B
        AND     $0F
        LD      C,A
        LD      A,B
        RRCA
        RRCA
        RRCA
        RRCA
        AND     $0F
        LD      B,A
LA14C:  LD      E,(HL)          ; BEGIN loop
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      A,D
        OR      E
        JR      Z,LA170                 ; (+$1c) WHILE 0<> False to loop Exit
        PUSH    DE
        POP     IY
        LD      A,(IY+$5D)      ; OBJSV offset 93 for ( OBJect State Variable )
        CP      $03             ; MSSNA constant for ( Monster State SNAtch hostage )
        JR      NZ,LA16E                ; (+$10) IF 0= False to THEN
        LD      A,(IY+$3C)      ; INTR offset 60 for ( INiTiaL Row )
        CP      B
        JR      NZ,LA16E                ; (+$0a) IF 0= False to THEN also
        LD      A,(IY+$3D)      ; INTC offset 61 for ( INiTiaL Column )
        CP      C
        JR      NZ,LA16E                ; (+$04) IF 0= False to THEN again
        POP     IY
        JR      LA181                   ; (+$13) to AARF routine EXIT

LA16E:  JR      LA14C                   ; (-$24) REPEAT to BEGIN and 3 THENs

LA170:  POP     IY              ; (loop Exit) because WE PASS
        LD      (IY+$3C),B      ; INTR offset 60 for ( INiTiaL Row )
        LD      (IY+$3D),C      ; INTC offset 61 for ( INiTiaL Column )
        PUSH    IX
        POP     DE
        LD      (IY-$09),E      ; FNDPTR offset -9 MINUS ??
        LD      (IY-$08),D      ; FNDPTRH offset -8 MINUS ??
LA181:  POP     BC              ; AARF routine EXIT
LA182:  RET                     ; NULRET to RETurn (used by B:M below !!)
; end of ( SUBROUTINE TO CHECK FOR VALID BANISHMENT POINT ) !!

; ( FIND NEAT PLACE OF BANISHMENT AT LEAST N MOVES AWAY )
; : B:M NULRET FPSS SYNC LAH SYNC
; LAH SYNC GA# B@ 3 > IF LAH SYNC THEN OKBAN TREECK V!
; BEGIN SYNC LAH END TRACKPTR V!
; DIVG COGO ;
; -->
;
; B:M does "find neat place of Banishment at least n Moves away"
LA183:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; NULRET "pushWORD to System stack"
        DW      LA182           ; point to ?? (RETurn !!)
        ;
        DW      L9A15           ; FPSS do "Find Path"
        ;
        DW      L1660           ; SYNC do ??
        ;
        DW      L9ACA           ; LAH do ??
        ;
        DW      L1660           ; SYNC do ??
        ;
        DW      L9ACA           ; LAH do ??
        ;
        DW      L1660           ; SYNC do ??
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ; IF False to THEN
        DW      L03CD,LA1A4     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L9ACA           ; LAH do ??
        ;
        DW      L1660           ; SYNC do ??
        ; THEN
LA1A4:  DW      L00BC           ; OKBAN "pushWORD to System stack"
        DW      LA111           ; point to "CHECK for valid BANishment point"
        ;
        DW      L00BC           ; TREECK "pushWORD to System stack"
        DW      $FFF3           ; offset -13 for ?? MINUS ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ; BEGIN loop
LA1AE:  DW      L1660           ; SYNC do ??
        ;
        DW      L9ACA           ; LAH do ??
        ; END or loop to BEGIN if False
        DW      L03CD,LA1AE     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; TRACKPTR "pushWORD to System stack"
        DW      $FFF5           ; offset -11 for ?? MINUS ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0215 } !!

; { BLOCK 0218 }
; ( MORE MONSTER STUFF )
; ( COMPARE POSITION IN D AND E WITH POSITION IN VECTOR )
; SUBR compos
;  D A MOV,
;  NOWR Y CMPX,
;  RNZ,
;  E A MOV,
;  NOWC Y CMPX,
;  RET,
;
; compos does "COMPare POSition in D and E with position in vector" routine
LA1C2:  LD      A,D
        CP      (IY+$3E)        ; NOWR offset 62 for ( CURRENT Row )
        RET     NZ
        LD      A,E
        CP      (IY+$3F)        ; NOWC offset 63 for ( CURRENT Column )
        RET

; CODE CHASEPLAYER
; <ASSEMBLE
;  EXX,
;  X PUSHX,
;  Y PUSHX,
;  PLYRV X LXIX,
;  vaddr LIYD,
;  NOWR X D LDX,
;  NOWC X E LDX,
;  NOWD X C LDX,
;  move:node CALL,
;  movecheck CALL,
;  CY, IF,
;   NODMSK C MVI,
;   node^ CALL,
;   NMEXS M BIT,
;   0<>, IF,
;    compos CALL,
;    0=, IF, ( IF AT PLAYERS DEST, GRAB HIS SOURCE )
;     NOWR X D LDX,
;     NOWC X E LDX,
;    THEN,
;    D INTR Y STX,
;    E INTC Y STX,
;   THEN,
;  THEN,
;  EXX,
;  Y POPX,
;  X POPX,
; NEXT
; ASSEMBLE>
; DECIMAL
;
; CHASEPLAYER does "CHASE PLAYER"
LA1CC:  EXX
        PUSH    IX
        PUSH    IY
        LD      IX,$F12D        ; PLYRV point to "PLaYer Vector" base for IndeX in Static RAM
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      D,(IX+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IX+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      C,(IX+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        CALL    L8D90           ; movecheck do "MOVE CHECKer"
        JR      NC,LA204                ; (+$1a) IF CY False exit to THEN #1
        LD      C,$18           ; NODMSK constant 24 for ??
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        BIT     7,(HL)          ; NMEXS bit 7 for ??
        JR      Z,LA204                 ; (+$11) IF 0<> False exit to THEN #2
        CALL    LA1C2           ; compos do "COMPare POSition in D and E with position in vector"
        JR      NZ,LA1FE                ; (+$06) IF 0= False exit to THEN #3
; AT PLAYERS DEST, GRAB HIS SOURCE
        LD      D,(IX+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IX+$3F)      ; NOWC offset 63 for ( CURRENT Column )
; THEN #3 exit
LA1FE:  LD      (IY+$3C),D      ; INTR offset 60 for ( INiTiaL Row )
        LD      (IY+$3D),E      ; INTC offset 61 for ( INiTiaL Column )
; THEN #1 and #2 exits
LA204:  EXX
        POP     IY
        POP     IX
        JP      (IY)            ; indexed RETurn

; : EXV? OBJSV VB@ MSRIP = IF 1535 ELSE 1024 THEN ;
; -->
;
; EXV? does ??
LA20B:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L8171           ; VB@ do ??
        ;
        DW      L00C5           ; MSRIP "pushBYTE to System stack"
        DB      $01             ; constant 1 for ( Monster State Return Initial Position )
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; IF False to ELSE
        DW      L03CD,LA222     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $05FF           ; 1535 for ??
        ; (done so Jump to THEN)
        DW      L03C5,LA226     ; TerseJUMP to ??
        ; ELSE
LA222:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $0400           ; 1024 for ??
        ; THEN
LA226:  DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0218 } !!

; { BLOCK 0237 }
; ( ROUTE MONSTER TO TARGET ) DECIMAL
; : rmon
; 4 TIMEBMAX!
; PMOD VB@ IF FOLLOWTRACK NOWD VB@ <> IF ( REVERSE WANTED )
; R:D THEN
; EXV? DELTADIST V!
; BEGIN MVECT-ON
; VM-W ZGO DIVG DEST? END ARRIVE:NODE
; THEN
; BEGIN ESTPOS
; ON:TARGET? NOT IF FOLLOWTRACK NOWD VB!
; DEPART:NODE EXV? DELTADIST V!
; BEGIN MVECT-ON VM-W ZGO DIVG DEST? END ARRIVE:NODE
; 0 ELSE 1 THEN END 0 TIMEBMAX! COGO ;
;
; rmon does "Route MONster to target"
LA228:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L1F22           ; TIMEBMAX! do ??
        ;
        DW      L00BC           ; PMOD "pushWORD to System stack"
        DW      $FFF9           ; offset -7 for ?? MINUS ??
        ;
        DW      L8171           ; VB@ do ??
        ; IF False to THEN #1
        DW      L03CD,LA25F     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L9AFD           ; FOLLOWTRACK do ??
        ;
        DW      L00C5           ; NOWD "pushBYTE to System stack"
        DB      $40             ; offset 64 for ( CURRENT Direction )
        ;
        DW      L8171           ; VB@ do ??
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ; _IF False skip to THEN #2
        DW      L03CD,LA246     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L8956           ; R:D do "Reverse Direction"
        ; _THEN #2
LA246:  DW      LA20B           ; EXV? do ??
        ;
        DW      L00C5           ; DELTADIST "pushBYTE to System stack"
        DB      $4C             ; offset 76 for ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ; _BEGIN loop #1
LA24D:  DW      LA068           ; MVECT-ON do "turn Monster VECTor ON"
        ;
        DW      L00BC           ; VM-W "pushWORD to System stack"
        DW      L9F8A           ; point to "Visable Monster Writer"
        ;
        DW      L80FE           ; ZGO do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L1B95           ; DEDEST?ST do ??
        ; _END #1 or loop to BEGIN #1 if False
        DW      L03CD,LA24D     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L8915           ; ARRIVE:NODE do "ARRIVE at NODE"
        ; THEN #1
LA25F:  DW      L88DF           ; ESTPOS do ??
        ;
        DW      L84CD           ; ON:TARGET? do ??
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; IF False to ELSE #3
        DW      L03CD,LA291     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L9AFD           ; FOLLOWTRACK do ??
        ;
        DW      L00C5           ; NOWD "pushBYTE to System stack"
        DB      $40             ; offset 64 for ( CURRENT Direction )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L8906           ; DEPART:NODE do "travel AWAY from NODE"
        ;
        DW      LA20B           ; EXV? do ??
        ;
        DW      L00C5           ; DELTADIST "pushBYTE to System stack"
        DB      $4C             ; offset 76 for ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ; _BEGIN loop #2
LA279:  DW      LA068           ; MVECT-ON do "turn Monster VECTor ON"
        ;
        DW      L00BC           ; VM-W "pushWORD to System stack"
        DW      L9F8A           ; point to "Visable Monster Writer"
        ;
        DW      L80FE           ; ZGO do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L1B95           ; DEDEST?ST do ??
        ; _END #2 or loop to BEGIN #2 if False
        DW      L03CD,LA279     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L8915           ; ARRIVE:NODE do "ARRIVE at NODE"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; (done so Jump to THEN #3)
        DW      L03C5,LA293     ; TerseJUMP to ??
        ; ELSE #3
LA291:  DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; THEN #3
LA293:  DW      L03CD,LA25F     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L1F22           ; TIMEBMAX! do ??
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00B0           ; ... TerseRETurn

; : RMON ' rmon SETCO ;
; -->
;
; RMON does "Route MONster as COroutine" with a built-in COGO ??
LA29F:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; rmon "pushWORD to System stack"
        DW      LA228           ; point to "Route MONster to target" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0237 } !!

; { BLOCK 0229 }
; CODE CLOSE?
;  EXX,
;  B POP,
;  XTIX,
;  Y PUSHX,
;  vaddr LIYD,
;  0 H LXI,
;  NOWR Y A LDX,
;  NOWR X SUBX,
;  BABS CALL,
;  C CMP,
;  CY, IF,
;   NOWC Y A LDX,
;   NOWC X SUBX,
;   BABS CALL,
;   C CMP,
;   CY, IF,
;    1 H LXI,
;   THEN,
;  THEN,
;  Y POPX,
;  X POPX,
;  H PUSH,
;  EXX,
; NEXT
;
; CLOSE? does ?? routine
LA2A8:  EXX
        POP     BC
        EX      (SP),IX
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      HL,$0000        ; 0 for ?? False
        LD      A,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        SUB     (IX+$3E)        ; NOWR offset 62 for ( CURRENT Row )
        CALL    L8717           ; BABS do "turn Byte in A ABSolute"
        CP      C
        JR      NC,LA2D0                ; (+$0f) IF #1 CY False to THEN
        LD      A,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        SUB     (IX+$3F)        ; NOWC offset 63 for ( CURRENT Column )
        CALL    L8717           ; BABS do "turn Byte in A ABSolute"
        CP      C
        JR      NC,LA2D0                ; (+$03) IF #2 CY False to THEN too
        LD      HL,$0001        ; 1 for ?? True
LA2D0:  POP     IY              ; THEN exits for both IF #1 and #2
        POP     IX
        PUSH    HL
        EXX
        JP      (IY)            ; indexed RETurn

; CODE RANMOVE
;  EXX,
;  Y PUSHX,
;  vaddr LIYD,
;  LDAR,
;  3 ANI,
;  A C MOV,
;  NOWR Y D LDX,
;  NOWC Y E LDX,
;  BEGIN,
;   noder^ CALL,
;   M A MOV,
;   A ANA,
;  0=, WHILE,
;   C A MOV,
;   A INR,
;   3 ANI,
;   A C MOV,
;  REPEAT,
;  move:node CALL,
;  E INTC Y STX,
;  D INTR Y STX,
;  Y POPX,
;  EXX,
; NEXT
; -->
;
; RANMOVE does ??
LA2D8:  EXX
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      A,R
        AND     $03
        LD      C,A
        LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
; BEGIN loop for ??
LA2EA:  CALL    L8696           ; noder^ do ??
        LD      A,(HL)
        AND     A
        JR      NZ,LA2F8                ; (+$07) WHILE 0= False to loop Exit
        LD      A,C
        INC     A
        AND     $03
        LD      C,A
        JR      LA2EA                   ; (-$0e) REPEAT to BEGIN

; (loop Exit)
LA2F8:  CALL    L86D2           ; move:node do "C=DIR, D=ROW, E=COL"
        LD      (IY+$3D),E      ; INTC offset 61 for ( INiTiaL Column )
        LD      (IY+$3C),D      ; INTR offset 60 for ( INiTiaL Row )
        POP     IY
        EXX
        JP      (IY)            ; indexed RETurn
; end of { BLOCK 0229 } !!

; { BLOCK 0099 }
; ( SPIDERS MOVE ROUTINE )
; HEX DATA B2DP 00 B, 02 B, 22 B, 23 B, 33 B, 13 B, 11 B, 01 B,
;
; B2DP 8-byte SPIDERS table
LA306:  DB      $00
        DB      $02
        DB      $22
        DB      $23
        DB      $33
        DB      $13
        DB      $11
        DB      $01

; DECIMAL
; F= Sm0
; F= Sm1
; F= Sm2
; F= Sm3
; CODE SPDMOV
; <ASSEMBLE
;  EXX,
;  Y PUSHX,
;  X PUSHX,
;  vaddr LIYD,
;  RMctr Y A LDX,
;  A ANA,
;  Sm0 JRNZ, ( RANDOMLY MOVING )
;  LDAR,
;  7 ANI,
;  3 CPI,
;  Sm0 JRZ, ( RANDOM BREAK )
; ( SPIDER CHASE PLAYER ROUTINE )
;  PLYRV X LXIX,
;  BEARV CALL,
;  A E MOV,
;  0 D MVI,
;  B2DP H LXI,
;  D DAD,
;  LDAR,
;  1 ANI,
;  M A MOV,
;  0<>, IF,
;   RRC,
;   RRC,
;   RRC,
;   RRC,
;  THEN,
;  A B MOV,
;  NOWR Y D LDX,
;  NOWC Y E LDX,
;  3 ANI,
;  A C MOV,
;  noded^ CALL,
;  M A MOV,
;  A ANA,
;  Sm3 JRNZ,
;  B A MOV,
;  RRC,
;  RRC,
;  RRC,
;  RRC,
;  3 ANI,
;  A C MOV,
;  noded^ CALL,
;  M A MOV,
;  A ANA,
;  Sm3 JRNZ,
;  LDAR,
;  RRC,
;  RRC,
;  RRC,
;  3 ANI,
;  1 ADI, ( SET RANDOM MOVE COUNTER )
; -->
;
; { BLOCK 0102 }
; ( SPIDERS MOVE ROUTINE )
; LABEL Sm0
;  A DCR,
;  A RMctr Y STX,
;  LDAR,
;  3 ANI,
;  A C MOV,
;  0 B MVI,
;  NOWR Y D LDX,
;  NOWC Y E LDX,
; LABEL Sm1
;  noder^ CALL,
;  M A MOV,
;  A ANA,
;  Sm2 JRZ,
;  B A MOV,
;  5 CPI,
;  Sm3 JRNC,
;  NOWD Y A LDX,
;  CMA,
;  3 ANI,
;  C CMP,
;  Sm3 JRNZ,
; LABEL Sm2
;  C A MOV,
;  A INR,
;  3 ANI,
;  A C MOV,
;  B INR,
;  Sm1 JMPR,
; LABEL Sm3
;  C NOWD Y STX,
;  X POPX,
;  Y POPX,
;  EXX,
; NEXT
; ASSEMBLE>
; -->
;
; SPDMOV does "SPiDers MOVE routine"
LA30E:  EXX
        PUSH    IY
        PUSH    IX
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      A,(IY-$06)      ; RMctr offset -6 for ( hostage guarding state ) Variable MINUS ??
        AND     A
        JR      NZ,LA367                ; (+$4a) if ?? to Sm0 "RANDOMLY MOVING"
        LD      A,R
        AND     $07
        CP      $03
        JR      Z,LA367                 ; (+$42) if ?? to Sm0 "RANDOM BREAK"
; SPIDER CHASE PLAYER ROUTINE
        LD      IX,$F12D        ; PLYRV point to "PLaYer Vector" base for IndeX in Static RAM
        CALL    L9005           ; BEARV do "more BEARing Vector stuff"
        LD      E,A
        LD      D,$00
        LD      HL,LA306        ; point to 8-Byte SPIDERS table
        ADD     HL,DE
        LD      A,R
        AND     $01             ; random bit 0
        LD      A,(HL)
        JR      Z,LA33E                 ; (+$04) IF 0<> False skip
        RRCA
        RRCA
        RRCA
        RRCA
LA33E:  LD      B,A
        LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        AND     $03
        LD      C,A
        CALL    L868C           ; noded^ do ??
        LD      A,(HL)
        AND     A
        JR      NZ,LA395                ; (+$46) if ?? to Sm3
        LD      A,B
        RRCA
        RRCA
        RRCA
        RRCA
        AND     $03
        LD      C,A
        CALL    L868C           ; noded^ do ??
        LD      A,(HL)
        AND     A
        JR      NZ,LA395                ; (+$37) if ?? to Sm3
        LD      A,R
        RRCA
        RRCA
        RRCA
        AND     $03
        ADD     A,$01           ; SET RANDOM MOVE COUNTER
; Sm0 label ?? SPIDERS MOVE ROUTINE
LA367:  DEC     A
        LD      (IY-$06),A      ; RMctr offset -6 for ( hostage guarding state ) Variable MINUS ??
        LD      A,R
        AND     $03
        LD      C,A
        LD      B,$00
        LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
; Sm1 label ??
LA378:  CALL    L8696           ; noder^ do ??
        LD      A,(HL)
        AND     A
        JR      Z,LA38D                 ; (+$0e) if ?? to Sm2
        LD      A,B
        CP      $05
        JR      NC,LA395                ; (+$11) if ?? to Sm3
        LD      A,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        CPL
        AND     $03
        CP      C
        JR      NZ,LA395                ; (+$08) if ?? to Sm3
; Sm2 label ??
LA38D:  LD      A,C
        INC     A
        AND     $03
        LD      C,A
        INC     B
        JR      LA378                   ; (-$1d) to Sm1

; Sm3 label ??
LA395:  LD      (IY+$40),C      ; NOWD offset 64 for ( CURRENT Direction )
        POP     IX
        POP     IY
        EXX
        JP      (IY)            ; indexed RETurn
; end of ( SPIDERS MOVE ROUTINE ) !!

; { BLOCK 0171 }
; ( ANIMATION ACTIVATION TABLES )
; XC? NOT IFTRUE ( CLUDGO )
;  DATA A.REST Spa , Zwa , Jaw ,
;  A.REST C= A.WALK A.REST C= A.SCUR
; OTHERWISE
;  DATA A.REST Spa-r , Zwa , Jaw ,
;
; A.REST 3-word animation ACTIVATION table #1
LA39F:  DW      L832B           ; Spa-r for SPIDERS and Spider EYES #3 display
        DW      L8332           ; Zwa for s-l-o-w TROLLS and EYES animation
        DW      L8340           ; Jaw for TEETH 2 DIE and TEETH HOLLOW animation

;  DATA A.WALK Spa , Zwa , Jaw ,
;
; A.WALK 3-word WALK Animation ACTIVATION table #2
LA3A5:  DW      L8324           ; Spa for SPIDERS and Spider EYES #3 display also
        DW      L8332           ; Zwa for s-l-o-w TROLLS and EYES animation again
        DW      L8340           ; Jaw for TEETH 2 DIE and HOLLOW animation again

;  DATA A.SCUR Spa , Zwa-s , Jaw ,
; IFEND
;
; A.SCUR 3-word animation ACTIVATION table #3
LA3AB:  DW      L8324           ; Spa for SPIDERS and Spider EYES #3 display again
        DW      L8339           ; Zwa-s for fast(er) TROLLS and EYES animation also
        DW      L8340           ; Jaw for TEETH 2 DIE and HOLLOW animation again & again

; : MASET CLASS? 2* + @ ANIM! ;
; -->
;
; MASET does ??
LA3B1:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L9FD3           ; CLASS? do "monster CLASSify routine"
        ;
        DW      L016B           ; 2* do "Double Top of System stack"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L1BE2           ; ANIM! do Set up ?? Pattern for ??
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0171 } !!

; { BLOCK 0048 }
; ( TROLL AND JAWS COMMANDER )
; : TJ:B
;  MMSV VB@ MMONT CASE ESTPOS ( MONSTER ON TARGET POS )
;  A.REST MASET
;  CHASEPLAYER
;  ON:TARGET? IF RANMOVE THEN
;  BE? FPSS MMTHK MMSV VB! 1 TIMER!-ON 1
;  ELSE MMTHK CASE
;  LAH
;  IF TRACKPTR V!
;   MMINC MMSV VB! ( GO INTO IN CHAMBER ) THEN
;   1 TIMER!-ON 1
;  ELSE MMSTP CASE
;   A.REST MASET
;   180 TIMER!-ON MMINC MMSV VB! 1
; -->
;
; { BLOCK 0050 }
; ( INCHAMBER )
; ELSE MMINC CASE ESTPOS
; ( RANDOMLY DECIDE TO STOP )
; CLASS? IF 1 ELSE 32 RND THEN
; 0= IF MMSTP ( ENTER STOP STATE )
; ELSE
; FOLLOWTRACK NOWD VB! DEPART:NODE
; SOB B@ IF MMSCU ( ALWAYS SCURRY WHEN MAD )
; ELSE PLYRV 2 CLOSE? IF MMWLK ELSE
; 16 RND SMARTS B@ 8 MIN 4 +
; > IF MMWLK ELSE MMSCU THEN THEN THEN MMSV VB!
; THEN 0
; ELSE MMWLK CASE A.WALK MASET MVSET 1
; ELSE MMSCU CASE A.SCUR MASET MVSET 1
; -->
;
; { BLOCK 0174 }
; ( STUFF )
; ELSE ( FLAKEY ) DROP
; THEN THEN THEN THEN THEN THEN
; IF ( EXECUTE WANTED FLAG PASSED )
;  MVECT-ON POA VM-W ZGO DIVG 0 DELTADIST V!
;  DEST? IF ARRIVE:NODE MMINC MMSV VB!
;  CLASS? 2 = IF MMONT MMSV VB! ELSE
;  20 RND SMARTS B@ 2 + CLASS? IF 6 + THEN 12 MIN
; < IF MMONT MMSV VB! THEN
; ON:TARGET? IF MMONT MMSV VB! THEN
; THEN THEN THEN COGO ; -->
;
; TJ:B does "Troll and Jaws commander"
LA3BE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L8171           ; VB@ do ??
        ;
        DW      L00C5           ; MMONT "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Monster Motion state ON Target )
        ; CASE "TEST State = 0 and Skip Over if False ?? or Continue if True"
        DW      L0427,LA3F7     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ; MONSTER ON TARGET POS
        DW      L88DF           ; ESTPOS do ??
        ;
        DW      L00BC           ; A.REST "pushWORD to System stack"
        DW      LA39F           ; for 3-word REST Animation table #1
        ;
        DW      LA3B1           ; MASET do ??
        ;
        DW      LA1CC           ; CHASEPLAYER do "CHASE PLAYER"
        ;
        DW      L84CD           ; ON:TARGET? do ??
        ; _IF False skip to THEN #1
        DW      L03CD,LA3DE     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LA2D8           ; RANMOVE do ??
        ; _THEN #1
LA3DE:  DW      L00BC           ; BE? "pushWORD to System stack"
        DW      L9AE9           ; point to "find BEst path towards target" routine
        ;
        DW      L9A15           ; FPSS do "Find Path"
        ;
        DW      L00C5           ; MMTHK "pushBYTE to System stack"
        DB      $01             ; constant 1 for ( Monster Motion state THinKing )
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; (end of CASE = 0 so ...)
        DW      L03C5,LA4ED     ; TerseJUMP to THENs
        ; (Case = 0 ELSE label)
LA3F7:  DW      L00C5           ; MMTHK "pushBYTE to System stack"
        DB      $01             ; constant 1 for ( Monster Motion state THinKing )
        ; CASE "TEST State = 1 and Skip Over if False ?? or Continue if True"
        DW      L0427,LA41D     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L9ACA           ; LAH do ??
        ; _IF False skip to THEN #2
        DW      L03CD,LA413     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; TRACKPTR "pushWORD to System stack"
        DW      $FFF5           ; offset -11 for ?? MINUS ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L00C5           ; MMINC "pushBYTE to System stack"
        DB      $03             ; constant 3 for ( Monster Motion state IN Chamber )
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L817C           ; VB! do ??
        ; _THEN #2
LA413:  DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; (end of CASE = 1 so ...)
        DW      L03C5,LA4ED     ; TerseJUMP to THENs
        ; (Case = 1 ELSE label)
LA41D:  DW      L00C5           ; MMSTP "pushBYTE to System stack"
        DB      $02             ; constant 2 for ( Monster Motion state SToPped )
        ; CASE "TEST State = 2 and Skip Over if False ?? or Continue if True"
        DW      L0427,LA43E     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00BC           ; A.REST "pushWORD to System stack"
        DW      LA39F           ; for 3-word REST Animation table #1
        ;
        DW      LA3B1           ; MASET do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $B4             ; 180 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L00C5           ; MMINC "pushBYTE to System stack"
        DB      $03             ; constant 3 for ( Monster Motion state IN Chamber )
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; (end of CASE = 2 so ...)
        DW      L03C5,LA4ED     ; TerseJUMP to THENs
        ; (Case = 2 ELSE label)
LA43E:  DW      L00C5           ; MMINC "pushBYTE to System stack"
        DB      $03             ; constant 3 for ( Monster Motion state IN Chamber )
        ; CASE "TEST State = 3 and Skip Over if False ?? or Continue if True"
        DW      L0427,LA4C1     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L88DF           ; ESTPOS do ??
        ;
        DW      L9FD3           ; CLASS? do "monster CLASSify routine"
        ; _IF False skip to ELSE #3
        DW      L03CD,LA453     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; _(done so Jump to THEN #3)
        DW      L03C5,LA458     ; TerseJUMP to ??
        ; _ELSE #3
LA453:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ?? Range ??
        ;
        DW      L1A5B           ; RND does "SHIFT and limit RANGE for Next Pseudo-RANDOM Number"
        ; _THEN #3
LA458:  DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; _IF False skip to ELSE #4
        DW      L03CD,LA465     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; MMSTP "pushBYTE to System stack"
        DB      $02             ; constant 2 for ( Monster Motion state SToPped )
        ; _(done so Jump to THEN #4)
        DW      L03C5,LA4BB     ; TerseJUMP to ??
        ; _ELSE #4
LA465:  DW      L9AFD           ; FOLLOWTRACK do ??
        ;
        DW      L00C5           ; NOWD "pushBYTE to System stack"
        DB      $40             ; offset 64 for ( CURRENT Direction )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L8906           ; DEPART:NODE do "travel AWAY from NODE"
        ;
        DW      L00BC           ; SOB "pushWORD to System stack"
        DW      $EEBD           ; for ( S.O.B. ) Byte-Variable
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; _IF False skip to ELSE #5
        DW      L03CD,LA47F     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; MMSCU "pushBYTE to System stack"
        DB      $05             ; constant 5 for ( Monster Motion state SCUrrying )
        ; _(done so Jump to THEN #5)
        DW      L03C5,LA4B5     ; TerseJUMP to ??
        ; _ELSE #5
LA47F:  DW      L00BC           ; PLYRV "pushWORD to System stack"
        DW      $F12D           ; for Word "PLaYeR Vector" base in Static RAM
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      LA2A8           ; CLOSE? do ??
        ; __IF False skip to ELSE #6
        DW      L03CD,LA492     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; MMWLK "pushBYTE to System stack"
        DB      $04             ; constant 4 for ( Monster Motion state WaLKing )
        ; __(done so Jump to THEN #6)
        DW      L03C5,LA4B5     ; TerseJUMP to ??
        ; __ELSE #6
LA492:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $10             ; 16 for ?? Range ??
        ;
        DW      L1A5B           ; RND does "SHIFT and limit RANGE for Next Pseudo-RANDOM Number"
        ;
        DW      L00BC           ; SMARTS "pushWORD to System stack"
        DW      $EEE9           ; for ( monster SMARTneSs ) Byte-Variable in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ; ___IF False skip to ELSE #7
        DW      L03CD,LA4B2     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; MMWLK "pushBYTE to System stack"
        DB      $04             ; constant 4 for ( onster Motion state WaLKing )
        ; ___(done so Jump to THEN #7)
        DW      L03C5,LA4B5     ; TerseJUMP to ??
        ; ___ELSE #7
LA4B2:  DW      L00C5           ; MMSCU "pushBYTE to System stack"
        DB      $05             ; constant 5 for ( Monster Motion state SCUrrying )
        ; __THEN #5 THEN #6 and THEN #7
LA4B5:  DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L817C           ; VB! do ??
        ; _THEN #4
LA4BB:  DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; (end of CASE = 3 so ...)
        DW      L03C5,LA4ED     ; TerseJUMP to THENs
        ; (Case = 3 ELSE label)
LA4C1:  DW      L00C5           ; MMWLK "pushBYTE to System stack"
        DB      $04             ; constant 4 for ( Monster Motion state WaLKing )
        ; CASE "TEST State = 4 and Skip Over if False ?? or Continue if True"
        DW      L0427,LA4D6     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00BC           ; A.WALK "pushWORD to System stack"
        DW      LA3A5           ; for 3-word WALK Animation table #2
        ;
        DW      LA3B1           ; MASET do ??
        ;
        DW      LA0B3           ; MVSET do ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; (end of CASE = 4 so ...)
        DW      L03C5,LA4ED     ; TerseJUMP to THENs
        ; (Case = 4 ELSE label)
LA4D6:  DW      L00C5           ; MMSCU "pushBYTE to System stack"
        DB      $05             ; constant 5 for ( Monster Motion state SCUrrying )
        ; CASE "TEST State = 5 and Skip Over if False ?? or Continue if True"
        DW      L0427,LA4EB     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00BC           ; A.SCUR "pushWORD to System stack"
        DW      LA3AB           ; for 3-word SCURry Animation table #3
        ;
        DW      LA3B1           ; MASET do ??
        ;
        DW      LA0B3           ; MVSET do ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; (end of CASE = 5 so ...)
        DW      L03C5,LA4ED     ; TerseJUMP to THENs
        ; (Case = 5 ELSE label) !! no CASE found so adjust System Stack !!
LA4EB:  DW      L00F6           ; DROP do "Pop HL from System stack"
        ; IF False to THEN #8 and THENs for 6 CASEs !!
LA4ED:  DW      L03CD,LA568     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LA068           ; MVECT-ON do "turn Monster VECTor ON"
        ;
        DW      L84E4           ; POA do ??
        ;
        DW      L00BC           ; VM-W "pushWORD to System stack"
        DW      L9F8A           ; point to "Visable Monster Writer"
        ;
        DW      L80FE           ; ZGO do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; DELTADIST "pushBYTE to System stack"
        DB      $4C             ; offset 76 for ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L1B95           ; DEDEST?ST do ??
        ; _IF False to THEN #9
        DW      L03CD,LA568     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L8915           ; ARRIVE:NODE do "ARRIVE at NODE"
        ;
        DW      L00C5           ; MMINC "pushBYTE to System stack"
        DB      $03             ; constant 3 for ( Monster Motion state IN Chamber )
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L9FD3           ; CLASS? do "monster CLASSify routine"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; __IF False skip to THEN #10
        DW      L03CD,LA52C     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; MMONT "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Monster Motion state ON Target )
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L03C5,LA568     ; TerseJUMP to ??
        ; __THEN #10
LA52C:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ?? Range ??
        ;
        DW      L1A5B           ; RND does "SHIFT and limit RANGE for Next Pseudo-RANDOM Number"
        ;
        DW      L00BC           ; SMARTS "pushWORD to System stack"
        DW      $EEE9           ; for ( monster SMARTneSs ) Byte-Variable in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L9FD3           ; CLASS? do "monster CLASSify routine"
        ; __IF False skip to THEN #11
        DW      L03CD,LA545     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ; __THEN #11
LA545:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; __IF False skip to THEN #12
        DW      L03CD,LA559     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; MMONT "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Monster Motion state ON Target )
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L817C           ; VB! do ??
        ; __THEN #12
LA559:  DW      L84CD           ; ON:TARGET? do ??
        ; __IF False skip to THEN #13
        DW      L03CD,LA568     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; MMONT "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Monster Motion state ON Target )
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L817C           ; VB! do ??
        ; THEN #8 THEN #9 and THEN #13
LA568:  DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of ( TROLL AND JAWS COMMANDER ) !!

; { BLOCK 0049 }
; ( SPIDER BRAIN )
; : SP:B
; SPDMOV MMSV VB! A.WALK MASET MVSET
; DEPART:NODE
; MVECT-ON POA VM-W ZGO DIVG 0 DELTADIST V!
; DIVG
; DEST? IF ARRIVE:NODE MMINC MMSV VB! THEN
; COGO ;
; -->
;
; SP:B does "SPIDER BRAIN"
LA56C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LA30E           ; SPDMOV do "SPiDers MOVE routine"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $04             ; 4 for ?? (!! NOT in Terse source !!)
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00BC           ; A.WALK "pushWORD to System stack"
        DW      LA3A5           ; for 3-word WALK Animation table #2
        ;
        DW      LA3B1           ; MASET do ??
        ;
        DW      LA0B3           ; MVSET do ??
        ;
        DW      L8906           ; DEPART:NODE do "travel AWAY from NODE"
        ;
        DW      LA068           ; MVECT-ON do "turn Monster VECTor ON"
        ;
        DW      L84E4           ; POA do ??
        ;
        DW      L00BC           ; VM-W "pushWORD to System stack"
        DW      L9F8A           ; point to "Visable Monster Writer"
        ;
        DW      L80FE           ; ZGO do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; DELTADIST "pushBYTE to System stack"
        DB      $4C             ; offset 76 for ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L1B95           ; DEDEST?ST do ??
        ; IF False to THEN
        DW      L03CD,LA5A8     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L8915           ; ARRIVE:NODE do "ARRIVE at NODE"
        ;
        DW      L00C5           ; MMINC "pushBYTE to System stack"
        DB      $03             ; constant 3 for ( Monster Motion state IN Chamber )
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L817C           ; VB! do ??
        ; THEN
LA5A8:  DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of ( SPIDER BRAIN ) !!

; { BLOCK 0172 }
; ( IMPROVED MONSTER TASK )
; : IM-T ;TASK: SPOTMONS
;  0 TIMEBMAX! 2 TIMEBSCALE!
;  XOR-ON
;  CLASS? 2 = IF JAWSF BONE THEN
;  BEGIN DIVG
;  OBJSV VB@ MSPRO CASE ( MONSTER ON DA PROWL )
;  CLASS? IF ' TJ:B ELSE ' SP:B THEN SETCO COGO
; -->
;
; { BLOCK 0193 }
; ( RETURN TO INITIAL POSITION )
;  ELSE MSRIP CASE 0 DELTADIST V!
;  IMP INTC VB! INTR VB!
;  ON:TARGET? NOT IF
;  A.SCUR MASET BE? FPSS BEGIN SYNC LAH END TRACKPTR V! DIVG
;  RMON COGO THEN A.REST MASET
;  MSAIP OBJSV VB!
;  ELSE MSAIP CASE
; ( WAIT FOR MONSTER RELEASE )
;  BEGIN P.S B@ DUP PLIC = SWAP PLMV = OR NOT WHILE
;  5 TIMER!-ON WAIT DIVG REPEAT
; ( CLEAR MY POINTER ) 0 BEHIND V!
;  MMONT MMSV VB! MSPRO OBJSV VB!
; -->
;
; { BLOCK 0125 }
; ELSE MSSNA CASE ( SNATCHER !! )
;  0 DELTADIST V! A.SCUR MASET ' B:M SETCO COGO RMON COGO
;  1 DRPO VB!
;  30 TIMER!-ON GO MSPRO OBJSV VB! MMONT MMSV VB!
; ELSE
;  THEN THEN THEN THEN 0 END ;
;
; IM-T does "Improved Monster Task"
LA5AC:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      LA001           ; SPOTMONS do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L1F22           ; TIMEBMAX! do ??
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L1F0A           ; TIMEBSCALE! do ??
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L9FD3           ; CLASS? do "monster CLASSify routine"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; IF False skip to THEN #1
        DW      L03CD,LA5CB     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; JAWSF "pushWORD to System stack"
        DW      $EEC1           ; for ( JAWs on Screen Flag ) Byte-Variable
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ; THEN #1 and BEGIN loop
LA5CB:  DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L8171           ; VB@ do ??
        ;
        DW      L00C5           ; MSPRO "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Monster State on da PROwl )
        ; _CASE "TEST State = 0 and Skip Over if False ?? or Continue if True"
        DW      L0427,LA5F3     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ; MONSTER ON DA PROWL
        DW      L9FD3           ; CLASS? do "monster CLASSify routine"
        ; __IF False skip to THEN #2
        DW      L03CD,LA5E7     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; TJ:B "pushWORD to System stack"
        DW      LA3BE           ; point to "Troll and Jaws commander"
        ;
        DW      L03C5,LA5EB     ; TerseJUMP to ??
        ; __THEN #2
LA5E7:  DW      L00BC           ; SP:B do "pushWORD to System stack"
        DW      LA56C           ; point to "SPIDER BRAIN" routine
        ;
LA5EB:  DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ; _(end of CASE = 0 so ...)
        DW      L03C5,LA6D3     ; TerseJUMP to THENs
        ; _(Case = 0 ELSE label)
LA5F3:  DW      L00C5           ; MSRIP "pushBYTE to System stack"
        DB      $01             ; constant 1 for ( Monster State Return Initial Position )
        ; _CASE "TEST State = 1 and Skip Over if False ?? or Continue if True"
        DW      L0427,LA647     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ; RETURN TO INITIAL POSITION
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; DELTADIST "pushBYTE to System stack"
        DB      $4C             ; offset 76 for ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L9FE0           ; IMP do ??
        ;
        DW      L00C5           ; INTC "pushBYTE to System stack"
        DB      $3D             ; offset 61 for ( INiTiaL Column )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00C5           ; INTR "pushBYTE to System stack"
        DB      $3C             ; offset 60 for ( INiTiaL Row )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L84CD           ; ON:TARGET? do ??
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; __IF False to THEN #3
        DW      L03CD,LA635     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; A.SCUR "pushWORD to System stack"
        DW      LA3AB           ; for 3-word SCURry Animation table #3
        ;
        DW      LA3B1           ; MASET do ??
        ;
        DW      L00BC           ; BE? "pushWORD to System stack"
        DW      L9AE9           ; point to "find BEst path towards target" routine
        ;
        DW      L9A15           ; FPSS do "Find Path"
        ; ___BEGIN loop
LA621:  DW      L1660           ; SYNC do ??
        ;
        DW      L9ACA           ; LAH do ??
        ; ___END or loop to BEGIN if False
        DW      L03CD,LA621     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; TRACKPTR "pushWORD to System stack"
        DW      $FFF5           ; offset -11 for ?? MINUS ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      LA29F           ; RMON do "Route MONster as COroutine" (built in COGO ??)
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ; __THEN #3
LA635:  DW      L00BC           ; A.REST "pushWORD to System stack"
        DW      LA39F           ; for 3-word REST Animation table #1
        ;
        DW      LA3B1           ; MASET do ??
        ;
        DW      L00C5           ; MSAIP "pushBYTE to System stack"
        DB      $02             ; constant 2 for ( Monster State At Initial Position )
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L817C           ; VB! do ??
        ; _(end of CASE = 1 so ...)
        DW      L03C5,LA6D3     ; TerseJUMP to THENs
        ; _(Case = 1 ELSE label)
LA647:  DW      L00C5           ; MSAIP "pushBYTE to System stack"
        DB      $02             ; constant 2 for ( Monster State At Initial Position )
        ; _CASE "TEST State = 2 and Skip Over if False ?? or Continue if True"
        DW      L0427,LA690     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ; __BEGIN (WHILE REPEAT) loop WAIT FOR MONSTER RELEASE
LA64E:  DW      L83FF           ; P.S do "Get Rlayer State variable-address"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00C5           ; PLIC "pushBYTE to System stack"
        DB      $01             ; constant 1 for "PLayer state = In Chamber"
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L00C5           ; PLMV "pushBYTE to System stack"
        DB      $02             ; constant 2 for "PLayer state = MoVeabout"
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; __WHILE False to loop Exit (aka WHILE True continue in BEGIN ... REPEAT loop)
        DW      L03CD,LA674     ; WHILE NOT False ConditionalJUMP to loop Exit
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ; __REPEAT loop to BEGIN always
        DW      L03C5,LA64E     ; REPEAT do "TerseJUMP to TerseBEGIN label"
        ; __(loop Exit) so CLEAR MY POINTER
LA674:  DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; BEHIND "pushBYTE to System stack"
        DB      $59             ; offset 89 for ( fellow BEHIND me )
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L00C5           ; MMONT "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Monster Motion state ON Target )
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00C5           ; MSPRO "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Monster State on da PROwl )
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L817C           ; VB! do ??
        ; _(end of CASE = 2 so ...)
        DW      L03C5,LA6D3     ; TerseJUMP to THENs
        ; _(Case = 2 ELSE label)
LA690:  DW      L00C5           ; MSSNA "pushBYTE to System stack"
        DB      $03             ; constant 3 for ( Monster State SNAtch hostage )
        ; _CASE "TEST State = 3 and Skip Over if False ?? or Continue if True"
        DW      L0427,LA6D3     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ; SNATCHER !!
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; DELTADIST "pushBYTE to System stack"
        DB      $4C             ; offset 76 for ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ;
        DW      L00BC           ; A.SCUR "pushWORD to System stack"
        DW      LA3AB           ; for 3-word SCURry Animation table #3
        ;
        DW      LA3B1           ; MASET do ??
        ;
        DW      L00BC           ; B:M "pushWORD to System stack"
        DW      LA183           ; point to "find neat place of Banishment for Monster" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      LA29F           ; RMON do "Route MONster as COroutine" (built in COGO ??)
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00C5           ; DRPO "pushBYTE to System stack"
        DB      $55             ; offset 85 for ( DRoP Off flag )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00C5           ; MSPRO "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Monster State on da PROwl )
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00C5           ; MMONT "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Monster Motion state ON Target )
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L817C           ; VB! do ??
        ; _(end of CASE = 3 so ...)
        DW      L03C5,LA6D3     ; TerseJUMP to RIGHT HERE !!
        ; _THENs for 4 CASEs
LA6D3:  DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; END or loop to BEGIN if False
        DW      L03CD,LA5CB     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of ( IMPROVED MONSTER TASK ) !!

; ( ACTIVATOR FOR SPIDERS )
; : M-T ;TASK: 1STWRITE MSAIP OBJSV VB! SELF IM-T ;
; -->
;
; M-T does "activator for spiders"
LA6DB:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L00C5           ; MSAIP "pushBYTE to System stack"
        DB      $02             ; constant 2 for ( Monster State At Initial Position )
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      LA5AC           ; IM-T do "Improved Monster Task"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of ( ACTIVATOR FOR SPIDERS ) !!

; { BLOCK 0181 }
; ( ROUTINE TO AVOID SENDING IN MONSTER TILL ZONE CLEAR )
; : W-CL ( WAIT FOR PLAYER TO CLEAR ENTRY CHAMBER )
;  Src Snm
;  0 WTCTR VB! ( RESET THE IMPATIENCE COUNTER )
;  BEGIN
;  PLYRV 2 CLOSE? NOT
;  IF 0 1 ELSE ( RESET IF PLAYER NOT IN MAZE )
;  P.S B@ DUP PLIC = SWAP PLMV = OR NOT IF 0 WTCTR VB! THEN
;  WTCTR VB@ 1+ DUP WTCTR VB! 10 >
;  IF 1 1 ELSE 5 TIMER!-ON WAIT DIVG 0 THEN THEN END COGO ;
; -->
;
; W-CL does "Wait for player to CLear entry chamber"
LA6EE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L84EE           ; Src do ??
        ;
        DW      L84AF           ; Snm do ??
        ; RESET THE IMPATIENCE COUNTER
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; WTCTR "pushWORD to System stack"
        DW      $FFF3           ; constant -13 aka TREECK for ?? MINUS ??
        ;
        DW      L817C           ; VB! do ??
        ; BEGIN loop
LA6FB:  DW      L00BC           ; PLYRV "pushWORD to System stack"
        DW      $F12D           ; for Word "PLaYeR Vector" base in Static RAM
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      LA2A8           ; CLOSE? do ??
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; _IF False to ELSE #1 to RESET IF PLAYER NOT IN MAZE
        DW      L03CD,LA711     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; _(done so Jump to THEN #1)
        DW      L03C5,LA75E     ; TerseJUMP to ??
        ; _ELSE #1
LA711:  DW      L83FF           ; P.S do "Get Rlayer State variable-address"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00C5           ; PLIC "pushBYTE to System stack"
        DB      $01             ; constant 1 for "PLayer state = In Chamber"
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L00C5           ; PLMV "pushBYTE to System stack"
        DB      $02             ; constant 2 for "PLayer state = MoVeabout"
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; __IF False skip to THEN #2
        DW      L03CD,LA733     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; WTCTR "pushWORD to System stack"
        DW      $FFF3           ; constant -13 aka TREECK for ?? MINUS ??
        ;
        DW      L817C           ; VB! do ??
        ; __THEN #2
LA733:  DW      L00BC           ; WTCTR "pushWORD to System stack"
        DW      $FFF3           ; constant -13 aka TREECK for ?? MINUS ??
        ;
        DW      L8171           ; VB@ do ??
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00BC           ; WTCTR "pushWORD to System stack"
        DW      $FFF3           ; constant -13 aka TREECK for ?? MINUS ??
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ; __IF False to ELSE #3
        DW      L03CD,LA754     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; __(done so Jump to THEN #3)
        DW      L03C5,LA75E     ; TerseJUMP to ??
        ; __ELSE #3
LA754:  DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; THEN #1, THEN #3 and END or loop to BEGIN if False
LA75E:  DW      L03CD,LA6FB     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { ROUTINE TO AVOID SENDING IN MONSTER TILL ZONE CLEAR ) !!

; { BLOCK 0128 }
; ( JAWS TASK ) XC? NOT IFTRUE
; ( JAWS TASK ) : JAW-S ; IFEND
; XC? IFTRUE : J-T ;TASK: DIVG
;  MSAIP OBJSV VB! 4 TIMEBMAX! 2 TIMEBSCALE!
;  ST-X X! RQ-Y Y! 1STWRITE XOR-ON NULPAT ANIM!
;  18 GA# B@ 7 MIN 2* -
;  30 * TIMER!-ON WAIT JAW-S
;  ' W-CL SETCO COGO Jaw ANIM! IF 60 TIMER!-ON GO THEN
;  DIVG ' OPDR SETCO COGO EMOV
;  ST-X DESTX! ST-Y DESTY! 40 TIMER!-ON
;  A->DEST/TIME GO ( ENTER CHAMB ) EMOV
;  ( IF KEY NOT USED CLOSE DOOR BEHIND )
;  KEY OBJSV OVB@ KYOPEN <> IF ' CLDR SETCO COGO THEN DIVG
;  MMONT MMSV VB! MSPRO OBJSV VB! SPOTMONS SELF IM-T ;
; IFEND
; -->
;
; J-T does "Jaws Task"
LA766:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00C5           ; MSAIP "pushBYTE to System stack"
        DB      $02             ; constant 2 for ( Monster State At Initial Position )
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L1F22           ; TIMEBMAX! do ??
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L1F0A           ; TIMEBSCALE! do ??
        ;
        DW      L00C5           ; ST-X "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      L00C5           ; RQ-Y "pushBYTE to System stack"
        DB      $52             ; constant 82 for ??
        ;
        DW      L1D10           ; Y! do ??
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L00BC           ; NULPAT "pushWORD to System stack"
        DW      L81AD           ; for un-colored 0x0 BLANK pattern
        ;
        DW      L1BE2           ; ANIM! do Set up BLANK Pattern for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $12             ; 18 for ??
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L016B           ; 2* do "Double Top of System stack"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L354D           ; JAW-S do ??
        ;
        DW      L00BC           ; W-CL "pushWORD to System stack"
        DW      LA6EE           ; point to "Wait for player to CLear entry chamber" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00BC           ; Jaw "pushWORD to System stack"
        DW      L8340           ; for TEETH 2 DIE and TEETH HOLLOW animation
        ;
        DW      L1BE2           ; ANIM! do Set up TEETH TWO Animation Loop for ??
        ; IF False skip to THEN #1
        DW      L03CD,LA7C2     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3C             ; 60 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ; THEN #1
LA7C2:  DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00BC           ; OPDR "pushWORD to System stack"
        DW      L9EA4           ; point to "OPen DooR" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L8517           ; EMOV do ??
        ;
        DW      L00C5           ; ST-X "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L1B71           ; DESTX! do "convert +/- X REL to ABSolute PIXELs and save in VDESTX ??"
        ;
        DW      L00C5           ; ST-Y "pushBYTE to System stack"
        DB      $34             ; constant 52 for ??
        ;
        DW      L1B83           ; DESTY! do "convert +/- Y REL to PIXEL lines and save in VDESTY ??"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $28             ; 40 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ; ENTER CHAMBer
        DW      L85BD           ; A->DEST/TIME do "vector between position and DEST in TIME given"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L8517           ; EMOV do ??
        ; IF KEY NOT USED CLOSE DOOR BEHIND
        DW      L00BC           ; KEY "pushWORD to System stack"
        DW      $F06F           ; for "KEY Vector" base in Static RAM
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L819D           ; OVB@ do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $01             ; 1 for ??
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ; IF False skip to THEN #2
        DW      L03CD,LA7FD     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; CLDR "pushWORD to System stack"
        DW      L9E5B           ; point to "CLose DooR" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ; THEN #2
LA7FD:  DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00C5           ; MMONT "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Monster Motion state ON Target )
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00C5           ; MSPRO "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Monster State on da PROwl )
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      LA001           ; SPOTMONS do ??
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      LA5AC           ; IM-T do "Improved Monster Task"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of ( JAWS TASK ) !!

; { BLOCK 0063 }
; ( JAWS ELIMINATORS )
; XC? IFTRUE
;  : J-ER ;TASK: JAWSF BZERO NULPAT ANIM! 1 TIMER!-ON GO ;
;
; J-ER does "Jaws EliminatoR"
LA818:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L00BC           ; JAWSF "pushWORD to System stack"
        DW      $EEC1           ; for ( JAWs on Screen Flag ) Byte-Variable in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00BC           ; NULPAT "pushWORD to System stack"
        DW      L81AD           ; for un-colored 0x0 BLANK pattern
        ;
        DW      L1BE2           ; ANIM! do Set up BLANK Pattern for ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00B0           ; ... TerseRETurn

;  : J-RV ;TASK: DIVG 500 INCSCORE NULPAT ANIM! ERASEWRITE
;  DIVG SELF J-T ;
;
; J-RV does ??
LA82F:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L8C9B           ; INCSCORE do "INCrement SCORE times (SCore MULT + 1)"
        ;
        DW      L00BC           ; NULPAT "pushWORD to System stack"
        DW      L81AD           ; for un-colored 0x0 BLANK pattern
        ;
        DW      L1BE2           ; ANIM! do Set up BLANK Pattern for ??
        ;
        DW      L1DFC           ; ERASEWRITE do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      LA766           ; J-T do "Jaws Task"
        ;
        DW      L00B0           ; ... TerseRETurn

; OTHERWISE
;  : J-ER DROP ; : J-RV DROP ; : J-T DROP ; 0 C= JAWSV
; IFEND
; -->
;
; end of { JAWS ELIMINATORS } !!

; { BLOCK 0205 }
; ( TROLL TASK )
; : R-T ;TASK: MSAIP OBJSV VB! DIVG 4 TIMEBMAX! 2 TIMEBSCALE!
; ST-X X! RQ-Y Y! 1STWRITE XOR-ON NULPAT ANIM!
; 26 DIF B@ 2* - GA# B@ 7 MIN 2* - 30 * DUP
; 0<= IF DROP 30 THEN TIMER!-ON WAIT
; ' W-CL SETCO COGO
; EMOV ( HOLD FOR 2 SECONDS OF WARNING )
; ROTFLY ANIM! RODAN-S
; IF 60 TIMER!-ON GO DIVG THEN ' OPDR SETCO COGO
; ST-X DESTX! ST-Y DESTY! 40 TIMER!-ON
; A->DEST/TIME GO ( ENTER CHAMB ) EMOV
; ( IF KEY NOT USED CLOSE DOOR BEHIND )
; KEY OBJSV OVB@ KYOPEN <> IF ' CLDR SETCO COGO THEN
; DIVG SPOTMONS
; MMONT MMSV VB! MSPRO OBJSV VB! JAWSV J-T
; SELF IM-T
; -->
;
; R-T does "tRoll Task"
LA84A:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L00C5           ; MSAIP "pushBYTE to System stack"
        DB      $02             ; constant 2 for ( Monster State At Initial Position )
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L1F22           ; TIMEBMAX! do ??
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L1F0A           ; TIMEBSCALE! do ??
        ;
        DW      L00C5           ; ST-X "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      L00C5           ; RQ-Y "pushBYTE to System stack"
        DB      $52             ; constant 82 for ??
        ;
        DW      L1D10           ; Y! do ??

        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L00BC           ; NULPAT "pushWORD to System stack"
        DW      L81AD           ; for un-colored 0x0 BLANK pattern
        ;
        DW      L1BE2           ; ANIM! do Set up BLANK Pattern for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1A             ; 26 for ??
        ;
        DW      L00BC           ; DIF "pushWORD to System stack"
        DW      $E3EB           ; for ( DIFficulty factor ) 0-9 in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L016B           ; 2* do "Double Top of System stack"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L016B           ; 2* do "Double Top of System stack"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L020E           ; do "TEST ZERO Less or Equal (SP) return in (SP)"
        ; IF False skip to THEN #1
        DW      L03CD,LA89E     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ; THEN #1
LA89E:  DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; W-CL "pushWORD to System stack"
        DW      LA6EE           ; point to "Wait for player to CLear entry chamber" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L8517           ; EMOV do ??
        ; HOLD FOR 2 SECONDS OF WARNING
        DW      L00BC           ; ROTFLY "pushWORD to System stack"
        DW      L25E8           ; animation table for 2 BIRD animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up BIRD (VOLTAR) Animation Loop for ??
        ;
        DW      L3841           ; RODAN-S do ??
        ; IF False skip to THEN #2
        DW      L03CD,LA8C1     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3C             ; 60 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ; THEN #2
LA8C1:  DW      L00BC           ; OPDR do "pushWORD to System stack"
        DW      L9EA4           ; point to "OPen DooR" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00C5           ; ST-X "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L1B71           ; DESTX! do "convert +/- X to REL Bytes and save in +/- Y to REL line ??"
        ;
        DW      L00C5           ; ST-Y "pushBYTE to System stack"
        DB      $34             ; constant 52 for ??
        ;
        DW      L1B83           ; DESTY! do "convert +/- Y REL to PIXEL lines and save in VDESTY ??"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $28             ; 40 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L85BD           ; A->DEST/TIME do "vector between position and DEST in TIME given"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L8517           ; EMOV do ??
        ;
        DW      L00BC           ; KEY "pushWORD to System stack"
        DW      $F06F           ; for "KEY Vector" base in Static RAM
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L819D           ; OVB@ does ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $01             ; 1 for ??
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ; IF False skip to THEN #3
        DW      L03CD,LA8F8     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; CLDR "pushWORD to System stack"
        DW      L9E5B           ; point to "CLose DooR" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ; THEN #3
LA8F8:  DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      LA001           ; SPOTMONS do ??
        ;
        DW      L00C5           ; MMONT "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Monster Motion state ON Target )
        ;
        DW      L00BC           ; MMSV "pushWORD to System stack" MINUS ??
        DW      $FFFF           ; offset -1 for ( Monster Motion State ) Byte-Variable
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00C5           ; MSPRO "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Monster State on da PROwl )
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00BC           ; JAWSV "pushWORD to System stack"
        DW      $F529           ; for "JAWS Vector" base in Static RAM
        ;
        DW      LA766           ; J-T do "Jaws Task"
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      LA5AC           ; IM-T do "Improved Monster Task"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of ( TROLL TASK ) !!

; { BLOCK 0132 }
; ( SLUT ROUTINE AND ROUTINE TO FORCE OTHERS BACK TO INIT POS )
; HEX DATA CKA 0 B,
;
; CKA for ChecKsum A ??
        SBC     A,(HL)          ; eh??

; : SLUT SELF DX@ 0 > IF 0 ELSE 80 THEN ANGLE! ;
;
; SLUT does "SLUT" routine
LA91A:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L1D9F           ; DX@ do "get ( vector address --- Delta X )"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ; IF False to ELSE
        DW      L03CD,LA92D     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; (done so Jump to THEN)
        DW      L03C5,LA930     ; TerseJUMP to ??
        ; ELSE
LA92D:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $80             ; 128 for ??
        ; THEN
LA930:  DW      L1AF9           ; ANGLE! do "SET ANGLE"
        ;
        DW      L00B0           ; ... TerseRETurn

; ( RETURN UGLY NERDS TO INITIAL POSITION )
; : FLGEM DO I I:M OBJSV OVB@ MSPRO = IF
; MSRIP I I:M OBJSV OVB! 1 I I:M MYFLAG OVB! THEN LOOP ;
;
; FLGEM does ( RETURN UGLY NERDS TO INITIAL POSITION )
LA934:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L8352           ; I:M do ??
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L819D           ; OVB@ does ??
        ;
        DW      L00C5           ; MSPRO "pushBYTE to System stack"
        DB      $00             ; constant 0 for ( Monster State on da PROwl )
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; _IF False to THEN
        DW      L03CD,LA960     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; MSRIP "pushBYTE to System stack"
        DB      $01             ; constant 1 for ( Monster State Return Initial Position )
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L8352           ; I:M do ??
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L81A6           ; OVB do ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L8352           ; I:M do ??
        ;
        DW      L00C5           ; MYFLAG "pushBYTE to System stack"
        DB      $54             ; offset 84 for ( build in neato FLAG )
        ;
        DW      L81A6           ; OVB do ??
        ; THEN and TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
LA960:  DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00B0           ; ... TerseRETurn

; ( BANISH MONSTERS TO LOWER SCREEN POSITION )
; XC? IFTRUE : KICKBK 4 1 FLGEM ;
;
; KICKBK does ( FORCE OTHERS BACK TO INIT POS )
LA964:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      LA934           ; FLGEM do ( RETURN UGLY NERDS TO INITIAL POSITION )
        ;
        DW      L00B0           ; ... TerseRETurn

;  : BANTOP 5 0 FLGEM ;
; OTHERWISE : KICKBK 1 1 FLGEM ; : BANTOP 1 0 FLGEM ; IFEND
;
; BANTOP does "BANish monsters TO lower screen Position"
LA96D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      LA934           ; FLGEM do ( RETURN UGLY NERDS TO INITIAL POSITION )
        ;
        DW      L00B0           ; ... TerseRETurn

; ( MONSTER MASH ROUTINE )
; : M:M MONV1 R-T
; MZP @ 3 + B@ 1+ 1 DO I I:M M-T LOOP ;
; DECIMAL
; -->
;
; M:M does "Monster Mash" routine
LA976:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; MONV1 "pushWORD to System stack"
        DW      $FD51           ; for "MONster Vector" #1 base in Static RAM
        ;
        DW      LA84A           ; R-T do ??
        ;
        DW      L8446           ; MZP do "get CURRENT MaZe Pointer"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L8352           ; I:M do ??
        ;
        DW      LA6DB           ; M-T does "activator for spiders"
        ; TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { SLUT ROUTINE AND ROUTINE TO FORCE OTHERS BACK TO INIT POS } !!

; { BLOCK 0224 }
; ( GRAB PLAYER AND LEAVE PLAYFIELD )
; : DEPARTSKI ST-X DESTX! RQ-Y DESTY! SELF Y@ 40 > IF 256 ELSE
; 512 THEN A->DEST SLUT GO EMOV
; NULPAT ANIM! 1 TIMER!-ON GO DIVG COGO ;
; DECIMAL
;
; DEPARTSKI does "grab player and leave playfield"
LA997:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; ST-X "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L1B71           ; DESTX! do "convert +/- X to REL Bytes and save in +/- Y to REL line ??"
        ;
        DW      L00C5           ; RQ-Y "pushBYTE to System stack"
        DB      $52             ; constant 82 for ??
        ;
        DW      L1B83           ; DESTY! do "convert +/- Y REL to PIXEL lines and save in VDESTY ??"
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L1D90           ; Y@ do "get ( vector address --- Y )"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $28             ; 40 for ??
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ; IF False to ELSE
        DW      L03CD,LA9B7     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0100           ; 256 for ??
        ; (done so Jump to THEN)
        DW      L03C5,LA9BB     ; TerseJUMP to ??
        ; ELSE
LA9B7:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $0200           ; 512 for ??
        ; THEN
LA9BB:  DW      L1CB2           ; A->DEST do ??
        ;
        DW      LA91A           ; SLUT do ??
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L8517           ; EMOV do ??
        ;
        DW      L00BC           ; NULPAT "pushWORD to System stack"
        DW      L81AD           ; for un-colored 0x0 BLANK pattern
        ;
        DW      L1BE2           ; ANIM! do Set up BLANK Pattern for ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00B0           ; ... TerseRETurn

; : RAVISH ;TASK: DIVG 0 TIMEBSCALE! BKC BZERO KICKBK
; PLYRV X@ DESTX! PLYRV Y@ DESTY!
; EMOV DVECT-OFF
; ( GO FOR THE PLAYER )
; ROTFLY ANIM! 60 TIMER!-ON
; 512 A->DEST
; SLUT GO EMOV CARRY-S JAWSV ACTIVE? IF JAWSV J-ER THEN
; ( ONCE WE GET THERE FLAG 'EM )
; MYFLAG PLYRV + BONE
; ' DEPARTSKI SETCO COGO 250 BKC B! SHUTUP SELF R-T ;
; -->
;
; RAVISH does ??
LA9D5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L1F0A           ; TIMEBSCALE! do ??
        ;
        DW      L00BC           ; BKC "pushWORD to System stack"
        DW      $EEE0           ; for ( BacKground Color ) Byte-Variable
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      LA964           ; KICKBK do ( FORCE OTHERS BACK TO INIT POS )
        ;
        DW      L00BC           ; PLYRV "pushWORD to System stack"
        DW      $F12D           ; for Word "PLaYeR Vector" base in Static RAM
        ;
        DW      L1D81           ; X@ do "get ( vector address --- X )"
        ;
        DW      L1B71           ; DESTX! do "convert +/- X to REL Bytes and save in +/- Y to REL line ??"
        ;
        DW      L00BC           ; PLYRV "pushWORD to System stack"
        DW      $F12D           ; for Word "PLaYeR Vector" base in Static RAM
        ;
        DW      L1D90           ; Y@ do "get ( vector address --- Y )"
        ;
        DW      L1B83           ; DESTY! do "convert +/- Y REL to PIXEL lines and save in VDESTY ??"
        ;
        DW      L8517           ; EMOV do ??
        ;
        DW      L88B3           ; DVECT-OFF do "DE-ACTIVATE Distance Vectoring"
        ;
        DW      L00BC           ; ROTFLY "pushWORD to System stack"
        DW      L25E8           ; animation table for 2 BIRD animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up BIRD (VOLTAR) Animation Loop for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3C             ; 60 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0200           ; 512 for ??
        ;
        DW      L1CB2           ; A->DEST do ??
        ;
        DW      LA91A           ; SLUT do ??
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L8517           ; EMOV do ??
        ;
        DW      L38F5           ; CARRY-S do ??
        ;
        DW      L00BC           ; JAWSV "pushWORD to System stack"
        DW      $F529           ; for "JAWS Vector" base in Static RAM
        ;
        DW      L1EFA           ; ACTIVE? do ??
        ; IF False skip to THEN
        DW      L03CD,LAA23     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; JAWSV "pushWORD to System stack"
        DW      $F529           ; for "JAWS Vector" base in Static RAM
        ;
        DW      LA818           ; J-ER do "Jaws EliminatoR"
        ; THEN
LAA23:  DW      L00C5           ; MYFLAG "pushBYTE to System stack"
        DB      $54             ; offset 84 for ( build in neato FLAG )
        ;
        DW      L00BC           ; PLYRV "pushWORD to System stack"
        DW      $F12D           ; for Word "PLaYeR Vector" base in Static RAM
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      L00BC           ; DEPARTSKI "pushWORD to System stack"
        DW      LA997           ; point to "grab player and leave playfield" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $FA             ; 250 for ??
        ;
        DW      L00BC           ; BKC "pushWORD to System stack"
        DW      $EEE0           ; for ( BacKground Color ) Byte-Variable in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L32F3           ; SHUTUP does "SHUT UP all sounds"
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      LA84A           ; R-T do ??
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0224 } !!

; { BLOCK 0233 }
; ( CHANGE VECTORS PERSPECTIVE INDEX ROUTINE )
; SUBR CH-PX
;  VPERINX Y CMPX,
;  0<>, IF,
;   A VPERINX Y STX,
;   0 VANIMINX Y MVIX,
;   1 VANIMTIMER Y MVIX,
;  THEN,
;  RET,
;
; CH-PX does "CHange vectors Perspective indeX" routine
LAA47:  CP      (IY+$3A)        ; VPERINX offset 58 for "VECTORS PERspective INdeX"
        JR      Z,LAA57                 ; (+$0b) IF 0<> False RETurn
        LD      (IY+$3A),A      ; VPERINX offset 58 again
        LD      (IY+$38),$00    ; VANIMINX offset 56
        LD      (IY+$37),$01    ; VANIMTIMER offset 55
LAA57:  RET

; SUBR CH-HX
;  OBJSV Y A LDX,
;  HSATP CPI,
;  RNZ,
;  L A MOV,
;  CH-PX JMPR,
;
; CH-HX does ?? routine
LAA58:  LD      A,(IY+$5D)      ; OBJSV offset 93 for ( OBJect State Variable )
        CP      $01             ; HSATP constant 1 for ( HoStage Attached to Player )
        RET     NZ
        LD      A,L
        JR      LAA47                   ; (-$1a) to CH-PX ??

; CODE GHOST
;  H POP,
;  Y PUSHX,
;  P-S LDA,
;  A DCR,
;  2 CPI,
;  CY, IF,
;   L A MOV,
;   RLC,
;   A H MOV,
;   PLYRV Y LXIX,
;   VPERINX Y A LDX,
;   1 ANI,
;   H ORA,
;   CH-PX CALL,
;   HOSV1 Y LXIX,
;   CH-HX CALL,
; XC? IFTRUE
;  HOSV2 Y LXIX,
;  CH-HX CALL,
;  HOSV3 Y LXIX,
;  CH-HX CALL,
; IFEND
;  THEN,
;  Y POPX,
; NEXT
; -->
;
; GHOST does ??
LAA61:  POP     HL
        PUSH    IY
        LD      A,($EEE6)       ; P-S read ( Player State ) Byte-Variable in Static RAM
        DEC     A
        CP      $02
        JR      NC,LAA91                ; (+$25) IF CY False exit
        LD      A,L
        RLCA
        LD      H,A
        LD      IY,$F12D        ; PLYRV point to "PLaYer Vector" base for IndexY in Static RAM
        LD      A,(IY+$3A)      ; VPERINX offset 58
        AND     $01
        OR      H
        CALL    LAA47           ; CH-PX do "CHange vectors Perspective indeX"
        LD      IY,$EFB1        ; HOSV1 point to "HOStage Vector" #1 base for IndexY in Static RAM
        CALL    LAA58           ; CH-HX do ??
        LD      IY,$EF51        ; HOSV2 point to "HOStage Vector" #2 base for IndexY in Static RAM
        CALL    LAA58           ; CH-HX do ??
        LD      IY,$EEF1        ; HOSV3 point to "HOStage Vector" #3 base for IndexY in Static RAM
        CALL    LAA58           ; CH-HX do ??
LAA91:  POP     IY
        JP      (IY)            ; indexed RETurn
; end of { BLOCK 0233 } !!

; { BLOCK 0186 }
; DECIMAL
; : MPT1 -118 SWAP 12 * - 82 ;
;
; MPT1 does ??
LAA95:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF8A           ; -118 for ??
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $52             ; 82 for ??
        ;
        DW      L00B0           ; ... TerseRETurn

; : MPT2 118 SWAP 12 * + 82 ;
;
; MPT2 does ??
LAAA8:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $76             ; 118 for ??
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $52             ; 82 for ??
        ;
        DW      L00B0           ; ... TerseRETurn

; : MAGw 96 MAGM WRITEP ;
;
; MAGw does ??
LAABA:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $60             ; 96 for ??
        ;
        DW      L00BC           ; MAGM "pushWORD to System stack"
        DW      L82BE           ; for 4-color "Remaining MAGIC Spells" (facing left) pattern
        ;
        DW      L8B40           ; WRITEP do "Determine location and COPY MAGIC REMAINING"
        ;
        DW      L00B0           ; ... TerseRETurn

; : M-POS NERDUP IF MPT2 ELSE MPT1 THEN ;
;
; M-POS does ??
LAAC6:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ; IF False to ELSE
        DW      L03CD,LAAD3     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LAAA8           ; MPT2 do ??
        ; (done so Jump to THEN)
        DW      L03C5,LAAD5     ; TerseJUMP to ??
        ; ELSE
LAAD3:  DW      LAA95           ; MPT1 do ??
        ; THEN
LAAD5:  DW      L00B0           ; ... TerseRETurn

; : P1FL -96 95 32 P1UP WRITEP ;
;
; P1FL does "draw PLAYER 1 box on the Screen at the X , Y , and COLOR pushed"
LAAD7:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFA0           ; -96 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5F             ; 95 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L82E3           ; Player ONE UP pattern
        ;
        DW      L8B40           ; WRITEP do "Determine location and COPY P1 box"
        ;
        DW      L00B0           ; ... TerseRETurn

; : P2FL 96 95 32 P2UP WRITEP ;
;
; P2FL does "draw PLAYER 2 box at the RELative XY Screen location given"
LAAEA:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $60             ; 96 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5F             ; 95 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L82FF           ; Player TWO UP pattern
        ;
        DW      L8B40           ; WRITEP do "Determine location and COPY P2 box"
        ;
        DW      L00B0           ; ... TerseRETurn

; : FLSHR NERDUP IF P2FL ELSE P1FL THEN ;
;
; FLSHR does ??
LAAFC:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ; IF False to ELSE
        DW      L03CD,LAB09     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LAAEA           ; P2FL do "draw PLAYER 2 box on the Screen"
        ; (done so Jump to THEN)
        DW      L03C5,LAB0B     ; TerseJUMP to ??
        ; ELSE
LAB09:  DW      LAAD7           ; P1FL do "draw PLAYER 1 box on the Screen"
        ; THEN
LAB0B:  DW      L00B0           ; ... TerseRETurn

; HEX
; SUBR Ijs
;  INVERT LDA,
;  A ANA,
;  0=, IF,
;   12 IN,
;  ELSE,
;   11 IN,
;  THEN,
;  RET,
; DECIMAL
;
; Ijs does (Z-80 called) read COCKTAIL mode - then "Input P1 OR P2 JoyStick port"
LAB0D:  LD      A,($FEFF)       ; bit 0 = 1 for P2 in COCKTAIL mode ONLY !!
        AND     A
        JR      NZ,LAB17                ; (+$04) IF 0= False to ELSE
        IN      A,(SW2)         ; =&(18) for SWitch bank 2 for Player 1 4WAY controls
        JR      LAB19                   ; (+$02) to THEN

; ELSE P2 JoyStick
LAB17:  IN      A,(SW1)         ; =&(17) for SWitch bank 1 for Player 2 4WAY controls instead
LAB19:  RET                     ; THEN

; CODE IJS
;  Ijs CALL,
;  A L MOV,
;  0 H MVI,
;  H PUSH,
; NEXT
; DECIMAL
;
; IJS does (TERSE-called) Input JoyStick (by COCKTAIL mode) where IY is the TersePC !!
LAB1A:  CALL    LAB0D           ; Ijs do "Input CURRENT JoyStick port"
        LD      L,A
        LD      H,$00
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; XC? IFTRUE
;  : FLSHT ;TASK: BEGIN DIVG FLSHR 30 TIMER!-ON WAIT 0 END ;
; IFEND
; -->
;
; LAB23: FLSHT does "FLaSHer Task" (not used !!)
        RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ; BEGIN loop LINK TO FLASHER
LAB26:  DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      LAAFC           ; FLSHR do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; END or loop to BEGIN if False
        DW      L03CD,LAB26     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn
;
; TERSE notes: ASCII Colon replaced by RST  $08 "begins ASSEMBLED TerseCODE ..."
; FLSHT is the name, and TASK is commented out ( parenthesis do the same )
; BEGIN just sets a LABEL to LOOP back to at the next instruction Word
; DIVG writes a word of $0100 (decimal 256) for ?? in Static RAM
; FLSHR reads NERDUP and displays a BOX with either a 1 or 2 in it
; 30 if a number has appeared enough, a Word- or Byte-PUSHer might have been used
; TIMER!-ON starts a down-counter for (JIFFY's ?? or) SECONDs as read from Stack
; WAIT locks-up until the built-in TIMER has run its course
; 0 actually means FALSE (another Word pushes a 1 for TRUE)
; END reads the top of System Stack and LOOPs until FALSE
; and ASCII SemiColon replaced with DW  L00B0 "... to TerseRETurn"
;
; end of { BLOCK 0186 } !!

; { BLOCK 0246 }
; ( INTERRUPT MAGIC MONITOR AND COLOR CHANGER )
; HEX
; SUBR MS-F
;  MAFLG LDA,
;  A ANA,
;  0=, IF,
;   Ijs CALL,
;   5 A BIT,
;   RNZ, ( CHECK BUTT DOWN )
;   FREEZE? CALL,
;   RNZ,
;   0 ma# H LXI,
;   nerd+ CALL,
;   M A MOV,
;   A ANA,
;   RZ,
;   P-S LDA,
;   A DCR,
;   2 CPI,
;   RNC,
;   FREEZE CALL,
;   1 A MVI,
;   SFXV MYFLAG + STA,
;   MAFLG STA,
;   RET,
;  THEN, ( MAFLG SET ! )
;  MASCL LDA,
;  A INR,
;  2 CPI,
;  CY, IF,
;   MASCL STA,
;   RET,
;  THEN,
;  A XRA,
;  MASCL STA, ( RESET PRESCALER )
;  MACT LDA,
;  0FA CPI,
;  RZ,
;  0F8 ANI,
;  2 ORI,
;  8 ADI,
;  MACT STA,
;  1F ANI,
;  2 CPI,
;  MACT LDA,
;  0=, IF,
;   3 ADI,
;  THEN,
;  BKC STA,
;  RET,
; DECIMAL
; -->
;
; MS-F does "interrupt Magic monitor and color changer" routine
LAB39:  LD      A,($EEC3)       ; MAFLG read ( MAgic in use FLaG ) Byte-Variable in Static RAM
        AND     A
        JR      NZ,LAB65                ; (+$26) IF 0= False to THEN
        CALL    LAB0D           ; Ijs do Read CURRENT JoyStick (by COCKTAIL mode)
        BIT     5,A             ; check P1BUTT (or P2BUTT) for MAGIC BUTTon(s)
        RET     NZ              ; if not CHECK BUTT DOWN
        CALL    L8523           ; FREEZE? do "TEST F-F for Freeze Flag"
        RET     NZ
        LD      HL,$E38A        ; ma# point to ( MAgics left ) 2-Byte Array base in High WRITE-protected NV RAM
        CALL    L071E           ; nerd+ do "ADD 1 to HL if plup is 1 for P2"
        LD      A,(HL)          ; ... and read "MAgics left for CURRENT player"
        AND     A
        RET     Z
        LD      A,($EEE6)       ; P-S read ( Player State ) Byte-Variable in Static RAM
        DEC     A
        CP      $02
        RET     NC
        CALL    L851E           ; FREEZE do "INCrement F-F for Freeze Flag"
        LD      A,$01
        LD      ($F27B),A       ; SFXV + MYFLAG ($F227 + 84) = 1 for ?? in Static RAM
        LD      ($EEC3),A       ; MAFLG write 1 into ( MAgic in use FLaG ) Byte-Variable in Static RAM
        RET

; THEN ?? MAFLG SET !
LAB65:  LD      A,($EEC2)       ; MASCL read ( MAgic interrupt preSCaLer ) Byte-Variable
        INC     A
        CP      $02
        JR      NC,LAB71                ; (+$04) IF CY False skip
        LD      ($EEC2),A       ; MASCL write ( MAgic interrupt preSCaLer ) Byte-Variable in Static RAM
        RET

; skip ?? to RESET PRESCALER
LAB71:  XOR     A
        LD      ($EEC2),A       ; MASCL write 0 into ( MAgic interrupt preSCaLer ) Byte-Variable in Static RAM
        LD      A,($EEE1)       ; MACT read ( MAgic Color counTer ) Byte-Variable in Static RAM
        CP      $FA
        RET     Z
        AND     $F8
        OR      $02
        ADD     A,$08
        LD      ($EEE1),A       ; MACT write 8 into ( MAgic Color counTer ) Byte-Variable in Static RAM
        AND     $1F
        CP      $02
        LD      A,($EEE1)       ; MACT read ( MAgic Color counTer ) Byte-Variable in Static RAM
        JR      NZ,LAB8F                ; (+$02) IF 0= False skip
        ADD     A,$03
LAB8F:  LD      ($EEE0),A       ; BKC write 3 into "( BacKground Color ) Byte-Variable in Static RAM
        RET
; end of ( INTERRUPT MAGIC MONITOR AND COLOR CHANGER ) !!

; { BLOCK 0070 }
; ( MAGIC STUFF ) HEX XC? IFTRUE
;  : jCK JAWSF B@ 2 = IF JAWSV J-RV JAWSF BZERO THEN ;
; OTHERWISE : jCK ; IFEND
;
; jCK does ??
LAB93:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; JAWSF "pushWORD to System stack"
        DW      $EEC1           ; for ( JAWs on Screen Flag ) Byte-Variable in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; IF False skip to THEN
        DW      L03CD,LABAE     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; JAWSV "pushWORD to System stack"
        DW      $F529           ; for "JAWS Vector" base in Static RAM
        ;
        DW      LA82F           ; J-RV do ??
        ;
        DW      L00BC           ; JAWSF "pushWORD to System stack"
        DW      $EEC1           ; for ( JAWs on Screen Flag ) Byte-Variable in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ; THEN
LABAE:  DW      L00B0           ; ... TerseRETurn

; : MA-T ;TASK: 5 TIMEBSCALE! 0FA MACT B!
;  BEGIN BEGIN 6 TIMER!-ON POA WAIT DIVG
;  DIGSCR B@ 2/ DUP IF DIGSCR BZERO INCSCORE ELSE DROP THEN
;  FLSHR FLAG? END
;  480 Vpf ! 320 Vps ! ( SOUP UP PLAYER SPEED )
;  BEGIN MAGIC-S DIVG MA# 1-WPB! MA# B@ DUP 4 < IF
;  M-POS MAGw ELSE DROP THEN 2 MACT B!
;  BEGIN MACT B@ 0FA <> P.S B@ PLESC <> AND WHILE 1 GHOST
;  2 TIMER!-ON WAIT DIVG jCK
;  REPEAT 0FA DUP BKC B! MACT B!
;  IJS 20 AND 0<> MA# B@ 0= OR P.S B@ PLESC = OR END
;  SHUTUP UNFREEZE MAFLG BZERO 0 GHOST 0 END ; DECIMAL -->
; DECIMAL
; -->
;
; MA-T does "MAgic Task"
LABB0:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L1F0A           ; TIMEBSCALE! do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $FA             ; 250 for ??
        ;
        DW      L00BC           ; MACT "pushWORD to System stack"
        DW      $EEE1           ; for ( MAgic Color counTer ) Byte-Variablein Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; BEGIN loops #1 and #2
LABC0:  DW      L04F5           ; 6 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L84E4           ; POA do ??
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00BC           ; DIGSCR "pushWORD to System stack"
        DW      $EEC9           ; for "DIG SCoRe" Byte-Variable in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0170           ; 2/MOD do "Divide by 2 Top of System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ; __IF False skip to ELSE #1
        DW      L03CD,LABE4     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; DIGSCR "pushWORD to System stack"
        DW      $EEC9           ; for "DIG SCoRe" Byte-Variable in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L8C9B           ; INCSCORE do "INCrement SCORE times (SCore MULT + 1)"
        ; __(done so Jump to THEN #1)
        DW      L03C5,LABE6     ; TerseJUMP to ??
        ; __ELSE #1
LABE4:  DW      L00F6           ; DROP do "Pop HL from System stack"
        ; __THEN #1
LABE6:  DW      LAAFC           ; FLSHR do ??
        ;
        DW      L1B5F           ; FLAG? do ??
        ; _END #2 or loop to BEGIN #2 if False
        DW      L03CD,LABC0     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0480           ; 1152 for ??
        ;
        DW      L00BC           ; Vpf "pushWORD to System stack"
        DW      $EEEF           ; for ( Player Fast Velocity ) Variable in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0320           ; 800 for ??
        ;
        DW      L00BC           ; Vps "pushWORD to System stack"
        DW      $EEED           ; for "Player Slow Velocity" Variable in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ; _BEGIN loop #3
LAC02:  DW      L3998           ; MAGIC-S do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L0739           ; MA# do "get MAgics left for CURRENT player"
        ;
        DW      L07CE           ; 1-WPB! do "DECREMENT WRITE-protectedBYTE in (SP)"
        ;
        DW      L0739           ; MA# do "get MAgics left for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; __IF False skip to ELSE #2
        DW      L03CD,LAC20     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LAAC6           ; M-POS do ??
        ;
        DW      LAABA           ; MAGw do ??
        ; __(done so Jump to THEN #2)
        DW      L03C5,LAC22     ; TerseJUMP to ??
        ; __ELSE #2
LAC20:  DW      L00F6           ; DROP do "Pop HL from System stack"
        ; __THEN #2
LAC22:  DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; MACT "pushWORD to System stack"
        DW      $EEE1           ; for ( MAgic Color counTer ) Byte-Variablein Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; __BEGIN (WHILE REPEAT) loop #4
LAC2A:  DW      L00BC           ; MACT "pushWORD to System stack"
        DW      $EEE1           ; for ( MAgic Color counTer ) Byte-Variablein Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $FA             ; 250 for ??
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ;
        DW      L83FF           ; P.S do "Get Rlayer State variable-address"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00C5           ; PLESC "pushBYTE to System stack"
        DB      $04             ; constant 4 for "PLayer ESCaped"
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ; __WHILE False to loop Exit #4 (aka WHILE True continue in BEGIN ... REPEAT loop)
        DW      L03CD,LAC56     ; WHILE AND False ConditionalJUMP to loop Exit #4
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      LAA61           ; GHOST do ??
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      LAB93           ; jCK do ??
        ; __REPEAT #4 loop to BEGIN #4 always
        DW      L03C5,LAC2A     ; REPEAT do "TerseJUMP to TerseBEGIN label"
        ; __(loop Exit #4)
LAC56:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $FA             ; 250 for ??
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00BC           ; BKC "pushWORD to System stack"
        DW      $EEE0           ; for ( BacKground Color ) Byte-Variable in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; MACT "pushWORD to System stack"
        DW      $EEE1           ; for ( MAgic Color counTer ) Byte-Variablein Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      LAB1A           ; IJS do "Input CURRENT Joystick port"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L01F6           ; 0<> do "Pop HL, Push F on Zero or T on Not Zero"
        ;
        DW      L0739           ; MA# do "get MAgics left for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ;
        DW      L83FF           ; P.S do "Get Rlayer State variable-address"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00C5           ; PLESC "pushBYTE to System stack"
        DB      $04             ; constant 4 for "PLayer ESCaped"
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ; _END #3 or loop to BEGIN #3 if False
        DW      L03CD,LAC02     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L32F3           ; SHUTUP does "SHUT UP all sounds"
        ;
        DW      L852D           ; UNFREEZE do "DECrement F-F for Freeze Flag MIN Zero"
        ;
        DW      L00BC           ; MAFLG "pushWORD to System stack"
        DW      $EEC3           ; for ( MAgic in use FLaG ) Byte-Variable in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      LAA61           ; GHOST do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; END #1 or loop to BEGIN #1 if False
        DW      L03CD,LABC0     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0070 } !!

; { BLOCK 0270 }
; ( JOYSTICK ROUTINES )
; HEX
; DATA JOYTBL
;  -1 B, 0 B, 3 B, -1 B, 1 B, -1 B, -1 B, -1 B,
;  2 B, -1 B, -1 B, -1 B, -1 B, -1 B, -1 B, -1 B,
;
; ( JOYSTICK ROUTINES )
; JOYTBL 16-byte JOYstick TaBLe 4-way DIRECTIONAL (can 8-way be restored by fixing this ??)
LAC9D:  DB      $FF             ; 255 or -1's = illegal JOYSTICK combinations
        DB      $00             ; index 1 = Up
        DB      $03             ; index 2 = Down
        DB      $FF
        DB      $01             ; index 4 = Left
        DB      $FF
        DB      $FF
        DB      $FF
        DB      $02             ; index 8 = Right
        DB      $FF
        DB      $FF
        DB      $FF
        DB      $FF
        DB      $FF
        DB      $FF
        DB      $FF

; SUBR g;j
;  Ijs CALL,
;  CMA,
;  0F ANI,
;  A E MOV,
;  0 D MVI,
;  JOYTBL H LXI,
;  D DAD,
;  M A MOV,
;  A ANA,
;  RET,
; DECIMAL
; -->
;
; g;j does "Get Joystick and Convert to DIRECTION" routine
; gets 0 for Up, 1 for Left, 2 for Right, 3 for Down, and -1 for None or Other
LACAD:  CALL    LAB0D           ; Ijs do Read CURRENT JoyStick (by COCKTAIL mode)
        CPL
        AND     $0F             ; mask just Joystick
        LD      E,A
        LD      D,$00
        LD      HL,LAC9D        ; point to 4-way Directional ?? table
        ADD     HL,DE
        LD      A,(HL)
        AND     A
        RET
; end of { JOYSTICK ROUTINES } !!

; { BLOCK 0045 }
; ( PLAYER VELOCITY SETTER )
; HEX
; SUBR PVD
;  PSW PUSH,
;  B PUSH,
;  Hctr LDA,
;  3 ANI,
;  A INR,
;  A B MOV,
;  -20 A MVI,
;  BEGIN,
;   20 ADI,
;  LOOP,
;  A C MOV,
;  0 B MVI,
;  VPERINX PLYRV + LDA,
;  1 ANI,
;  0<>, IF,
;   Vps LHLD,
;  ELSE,
;   Vpf LHLD,
;  THEN,
;  A ANA,
;  B DSBC,
;  XCHG,
;  B POP,
;  PSW POP,
;  RET,
;
; PVD does ?? routine
LACBD:  PUSH    AF
        PUSH    BC
        LD      A,($EEC7)       ; Hctr read "Hostage CounTeR" Byte-Variable in Static RAM
        AND     $03
        INC     A               ; now 1 through 4
        LD      B,A
        LD      A,$E0           ; start at -20 ??
LACC8:  ADD     A,$20           ; BEGIN ??  loops
        DJNZ    LACC8                   ; (-$04) to BEGIN
        LD      C,A
        LD      B,$00
        LD      A,($F167)       ; VPERINX + PLYRV (58 + $F12D) read Byte ?? for ?? in Static RAM
        AND     $01
        JR      Z,LACDB                 ; (+$05) IF 0<> False to ELSE
        LD      HL,($EEED)      ; Vps read "Player Slow Velocity" Variable in Static RAM
        JR      LACDE                   ; (+$03) to THEN

; ELSE ??
LACDB:  LD      HL,($EEEF)      ; Vpf read ( Player Fast Velocity ) Variable in Static RAM
LACDE:  AND     A               ; THEN
        SBC     HL,BC
        EX      DE,HL
        POP     BC
        POP     AF
        RET

; more of { BLOCK 0045 } !!
; SUBR btrk?
;  PLYRV BEHIND + LHLD,
;  H A MOV,
;  L ORA,
;  RZ,
;  NOWD D LXI,
;  D DAD,
;  PLYRV NOWD + LDA,
;  CMA,
;  3 ANI,
;  M CMP,
;  RNZ,
;  HALTNOW JMP,
; DECIMAL
; -->
;
; btrk? does "check for BackTRacK mode" ??
LACE5:  LD      HL,($F186)      ; PLYRV + BEHIND ($F12D + 89) for ?? in Static RAM
        LD      A,H
        OR      L
        RET     Z
        LD      DE,$0040        ; NOWD offset 64 for ( CURRENT Direction )
        ADD     HL,DE
        LD      A,($F16D)       ; PLYRV + NOWD ($F12D + 64) read Byte for ?? in Static RAM
        CPL
        AND     $03
        CP      (HL)
        RET     NZ
        JP      L91A8           ; to HALTNOW ??

; { BLOCK 0055 }
; ( PLAYER VELOCITY SET UP )
; DECIMAL
; CODE EPLYRV
;  EXX,
;  SOB LDA,
;  A ANA,
;  0<>, IF,
;   448 H LXI,
;   320 D LXI,
;  ELSE,
;   0 g#m H LXI,
;   nerd+ CALL,
;   nerd+ CALL,
;   M A MOV,
;   2 CPI,
;   CY~, IF,
;    2 A MVI,
;   THEN,
;   RLC,
;   RLC,
;   RLC,
;   A C MOV,
;   0 B MVI,
;   XCHG,
;   320 H LXI,
;   B DAD,
;   RLC,
;   A C MOV,
;   B DAD,
;   D LDAX,
;   2 CPI,
;   CY~, IF,
;    2 A MVI,
;   THEN,
;   RLC,
;   RLC,
;   RLC,
;   A C MOV,
;   0 B MVI,
;   XCHG,
;   448 H LXI,
;   B DAD,
;   RLC,
;   A C MOV,
;   B DAD,
;  THEN, (
;  MAFLG LDA,
;  A ANA,
;  0<>, IF,
;   64 B LXI,
;   B DAD,
;   XCHG,
;   B DAD,
;   XCHG,
;  THEN, )
;  Vpf SHLD,
;  XCHG,
;  Vps SHLD,
;  PLYRV DELTADIST + SHLD,
;  1 A MVI,
;  O-M STA,
;  EXX,
; NEXT
; -->
;
; EPLYRV does "Establish PLaYeR Velocity set up"
LACFA:  EXX
        LD      A,($EEBD)       ; SOB read ( S.O.B. ) Byte-Variable in Static RAM
        AND     A
        JR      Z,LAD09                 ; (+$08) IF 0<> False to ELSE
        LD      HL,$01C0        ; 448 for ??
        LD      DE,$0140        ; PIXSPL for 320 PIXelS (not BITS) Per Line ??
        JR      LAD3C                   ; (+$33) to THEN

; ELSE ??
LAD09:  LD      HL,$E38C        ; g#m point to ( GaMe # for Player One ) in High WRITE-protected NV RAM
        CALL    L071E           ; nerd+ do "ADD 1 to HL if plup is 1 for P2"
        CALL    L071E           ; nerd+ do "ADD 1 to HL if plup is 1" again
        LD      A,(HL)          ; ... and use $E38E instead ( GaMe # for Player Two )
        CP      $02
        JR      C,LAD19                 ; (+$02) IF CY~ False skip next
        LD      A,$02
LAD19:  RLCA
        RLCA
        RLCA
        LD      C,A
        LD      B,$00
        EX      DE,HL
        LD      HL,$0140        ; for 320 PIXelS (not BITS) Per Line ??
        ADD     HL,BC
        RLCA
        LD      C,A
        ADD     HL,BC
        LD      A,(DE)
        CP      $02
        JR      C,LAD2E                 ; (+$02) IF CY~ False skip
        LD      A,$02
LAD2E:  RLCA
        RLCA
        RLCA
        LD      C,A
        LD      B,$00
        EX      DE,HL
        LD      HL,$01C0        ; 448 for ??
        ADD     HL,BC
        RLCA
        LD      C,A
        ADD     HL,BC
; THEN
LAD3C:  LD      ($EEEF),HL      ; Vpf write ( Player Fast Velocity ) Variable in Static RAM
        EX      DE,HL
        LD      ($EEED),HL      ; Vps write "Player Slow Velocity" Variable in Static RAM
        LD      ($F179),HL      ; PLYRV + DELTADIST ($F12D + 76) write Word ?? into ?? in Static RAM
        LD      A,$01
        LD      ($EEEB),A       ; O-M write 1 into ( Object Moving ) Byte-Variable in Static RAM
        EXX
        JP      (IY)            ; indexed RETurn
; end of { PLAYER VELOCITY SETTER } !!

; { BLOCK 0053 }
; ( INTERRUPT LEVEL JOY MONITOR )
; F= FDG
; F= F90
; F= Lsd
; SUBR JOYCHECK
; <ASSEMBLE
;  O-M LDA,
;  A ANA,
;  RZ,
;  P-S LDA,
;  A DCR,
;  2 CPI,
;  RNC, ( MAKE CERTAIN WE MOVING )
;  TBDEST TCHGSTAT Y BITX,
;  RNZ,
;  PLYRV DISTANCE 1+ + LDA,
;  A ANA,
;  RZ,
;  g;j CALL,
; .ABS
;  0<, IF,
;   0 H LXI, ( NOT IN COAST ZONE )
;   PLYRV DELTADIST + SHLD,
;   COPYDELTS JMP,
;  THEN,
; .REL ( JUMP IF SAME DIRECTION AS LAST TIME )
;  A C MOV,
;  PLYRV NOWD + LDA,
;  C CMP,
;  FDG JZ,
; -->
;
; { BLOCK 0303 }
; ( REVERSE ENTERED? )
;  PLYRV NOWD + LDA,
;  CMA,
;  3 ANI,
;  C CMP,
;  F90 JRNZ,
;  DIRFLAG LDA,
;  CMA,
;  DIRFLAG STA,
;  r:d CALL,
;  HALTNOW CALL,
;  FDG JMP, ( SHOULD WE CHECK FOR 90 ???? )
; LABEL F90
;  PLYRV DISTANCE 1+ + LDA,
;  JMLZ CPI,
;  FDG JNC,
; -->
;
; { BLOCK 0245 }
; ( MORE OF 90 CHECK )
;  DIRFLAG LDA,
;  A ANA,
;  FDG JRNZ, ( ONLY OUTBOUND )
;  NOWR Y D LDX,
;  NOWC Y E LDX,
;  KEY OBJSV + LDA,
;  KYOPEN CPI,
;  Lsd JRZ,
;  MAFLG LDA,
;  A ANA,
;  0<>, IF,
;  LABEL Lsd
;   D A MOV,
;   START-ROW CPI,
;   0=, IF,
;    E A MOV,
;    START-COL CPI,
;    0=, IF,
;     C A MOV,
;     A ANA,
;     0=, IF,
;      PLESC A MVI,
;      P-S STA,
;      1 A MVI,
;      PLYRV MYFLAG + STA,
;      HALTNOW JMP,
;     THEN,
;    THEN,
;   THEN,
;  THEN,
;  noded^ CALL,
;  M A MOV,
;  A ANA,
;  FDG JZ, ( BAD DIR )
;  C NOWD Y STX, ( VALID - ESTABLISH IT )
;  NEWPATH CALL, ( CHANGE ALL INNER PARAMETERS OF THANG )
;  btrk? CALL,  ( CHECK FOR BACKTRACK MODE )
;  FDG JMP, ( GO HOME, CHANGE ROT )
; -->
;
; { BLOCK 0057 }
; LABEL FDG
;  DIRFLAG LDA,
;  A ANA,
;  0<>, IF,
;   PVD CALL,
;  ELSE, ( ONLY WORRY ABOUT REVEALER OUTBOUND )
;   NOWR Y D LDX,
;   NOWC Y E LDX,
;   NOWD Y C LDX,
;   noder^ CALL,
;   M A MOV,
;   DISTANCE 1+ Y SUBX,
;   0 D LXI,
;  .ABS
;   0>=, IF,
;    PVD CALL,
;   THEN,
; .REL
;  THEN,
;  PLYRV DELTADIST + LHLD,
;  PLYRV DELTADIST + SDED,
;  A ANA,
;  D DSBC,
;  0<>, IF,
;   XCHG,
;   COPYDELTS CALL,
;  THEN,
;  NOWD Y E LDX,
;  0 D MVI,
;  0 ROTN H LXI,
;  D DAD,
;  M A MOV,
;  A VANGLE Y STX,
;  RET,
; ASSEMBLE>
; -->
;
; JOYCHECK does "interrupt level JOYstick MONITOR" routine
LAD4E:  LD      A,($EEEB)       ; O-M read ( Object Moving ) Byte-Variable in Static RAM
        AND     A
        RET     Z
        LD      A,($EEE6)       ; P-S read ( Player State ) Byte-Variable in Static RAM
        DEC     A
        CP      $02
        RET     NC              ; MAKE CERTAIN WE MOVING
        BIT     2,(IY+$12)      ; TBDEST bit 2 of TCHGSTAT offset 18
        RET     NZ
        LD      A,($F178)       ; PLYRV + DISTANCEH ($F12D + )75 read Byte for ?? in Static RAM
        AND     A
        RET     Z
        CALL    LACAD           ; g;j do "Get Joystick and Convert to DIRECTION"
        JP      P,LAD73         ; IF 0< False skip to continue if valid Direction
 ; NOT IN COAST ZONE
        LD      HL,$0000        ; 0 for ?? NONE or OTHER
        LD      ($F179),HL      ; PLYRV + DELTADIST ($F12D + 76) write Word 0 into ? in Static RAM
        JP      L918C           ; to COPYDELTS routine ??

; continue with A = 0 for Up, 1 for Left, 2 for Right, or 3 for Down
LAD73:  LD      C,A             ; UMP IF SAME DIRECTION AS LAST TIME
        LD      A,($F16D)       ; PLYRV + NOWD ($F12D + 64) read Byte for ?? in Static RAM
        CP      C
        JP      Z,LADE4         ; IF 0<> False to FDG
; REVERSE ENTERED?
        LD      A,($F16D)       ; PLYRV + NOWD ($F12D + 64) read Byte for ?? in Static RAM again
        CPL
        AND     $03
        CP      C
        JR      NZ,LAD94                ; (+$10) IF ?? to F90
        LD      A,($EEEC)       ; DIRFLAG read ( player DIRection FLAG ) Byte-Variable in Static RAM
        CPL
        LD      ($EEEC),A       ; DIRFLAG write ( player DIRection FLAG ) Byte-Variable in Static RAM
        CALL    L8925           ; r:d do "Reverse Direction"
        CALL    L91A8           ; HALTNOW do ??
        JP      LADE4           ; THEN to FDG

; F90 label SHOULD WE CHECK FOR 90 ???? )
LAD94:  LD      A,($F178)       ; PLYRV + DISTANCEH ($F12D + )75 read Byte for ?? in Static RAM
        CP      $08             ; JMLZ constant 8 for ( LEAP ZONE )
        JP      NC,LADE4        ; if ?? to FDG
        LD      A,($EEEC)       ; DIRFLAG read ( player DIRection FLAG ) Byte-Variable in Static RAM
        AND     A
        JR      NZ,LADE4                ; (+$42) if ?? to FDG ONLY OUTBOUND
        LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      A,($F0CC)       ; KEY + OBJSV (offset 93) read Byte ?? for ?? in Static RAM
        CP      $01
        JR      Z,LADB5                 ; (+$06) to Lsd
        LD      A,($EEC3)       ; MAFLG read ( MAgic in use FLaG ) Byte-Variable in Static RAM
        AND     A
        JR      Z,LADD0                 ; (+$1b) IF 0<> False to THEN #1
LADB5:  LD      A,D             ; Lsd label
        CP      $05             ; START-ROW constant 5 for "START ROW"
        JR      NZ,LADD0                ; (+$16) IF 0= False to THEN #1
        LD      A,E
        CP      $05             ; START-COL 5 for ??
        JR      NZ,LADD0                ; (+$11) IF 0= False to THEN #1
        LD      A,C
        AND     A
        JR      NZ,LADD0                ; (+$0d) IF 0= False to THEN #1
        LD      A,$04           ; PLESC for "PLayer ESCaped"
        LD      ($EEE6),A       ; P-S write 4 into ( Player State ) Byte-Variable in Static RAM
        LD      A,$01
        LD      ($F181),A       ; PLYRV + MYFLAG ($F109 + 84) = 1 for ?? in Static RAM
        JP      L91A8           ; to HALTNOW ??

; THEN #1 for 4 IFs
LADD0:  CALL    L868C           ; noded^ do ??
        LD      A,(HL)
        AND     A
        JP      Z,LADE4         ; if ?? to FDG BAD DIR
;  VALID - ESTABLISH IT
        LD      (IY+$40),C      ; NOWD offset 64 for ( CURRENT Direction )
; CHANGE ALL INNER PARAMETERS OF THANG )
        CALL    L8817           ; NEWPATH do "establish NEW base positions and deltas"
; CHECK FOR BACKTRACK MODE
        CALL    LACE5           ; btrk? do "check for BackTRacK mode"
; GO HOME, CHANGE ROT
        JP      LADE4           ; to FDG (already there !!)

; FDG label
LADE4:  LD      A,($EEEC)       ; DIRFLAG read ( player DIRection FLAG ) Byte-Variable in Static RAM
        AND     A
        JR      Z,LADEF                 ; (+$05) IF 0<> False to ELSE
        CALL    LACBD           ; PVD do ??
        JR      LAE08                   ; (+$19) to THEN #2

; ELSE ONLY WORRY ABOUT REVEALER OUTBOUND
LADEF:  LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      C,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        CALL    L8696           ; noder^ do ??
        LD      A,(HL)
        SUB     (IY+$4B)        ; DISTANCEH offset 75
        LD      DE,$0000        ; 0 for ??
        JP      M,LAE08         ; IF 0>= False to THEN #2
        CALL    LACBD           ; PVD do ??
; THEN #2
LAE08:  LD      HL,($F179)      ; PLYRV + DELTADIST ($F12D + 76) read Word ?? for ?? in Static RAM
        LD      ($F179),DE      ; PLYRV + DELTADIST ($F12D + 76) write Word ?? into ?? in Static RAM
        AND     A
        SBC     HL,DE
        JR      Z,LAE18                 ; (+$04) IF 0<> False skip
        EX      DE,HL
        CALL    L918C           ; COPYDELTS do ??
LAE18:  LD      E,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        LD      D,$00
        LD      HL,L8713        ; ROTN point to ?? 4-Byte table ??
        ADD     HL,DE
        LD      A,(HL)
        LD      (IY+$3B),A      ; VANGLE offset 59 for "Vector ANGLE"
        RET
; end of ( INTERRUPT LEVEL JOY MONITOR ) !!

; { BLOCK 0256 }
; ( PLAYER INTERRUPT ROUTINE )
; SUBR PL-M
;  JOYCHECK CALL,
;  Pac CALL,
;  PILOTC CALL,
;  MS-F CALL, ( CHECK MAGIC BUTTON )
;  SMTMR LHLD,
;  H A MOV,
;  L ORA,
;  RZ,
;  H DCX,
;  H A MOV,
;  L ORA,
;  0=, IF,
;   SMARTS H LXI,
;   M INR,
;   ASSH H LXI,
;   M INR,
;   M A MOV,
;   9 CPI,
;   CY~, IF,
;    SOB STA,
;   THEN,
;   SMTMRV LHLD,
;  THEN,
;  SMTMR SHLD,
;  RET,
; DECIMAL
; -->
;
; PL-M does "PLayer interrupt Monitor" routine
LAE26:  CALL    LAD4E           ; JOYCHECK do "interrupt level JOYstick CHECK"
        CALL    L9729           ; Pac does ??
        CALL    L9184           ; PILOTC do ??
; CHECK MAGIC BUTTON
        CALL    LAB39           ; MS-F do "interrupt Magic monitor and color changer"
        LD      HL,($EEE7)      ; SMTMR read ( monster SMartness TMmeR ) Variable in Static RAM
        LD      A,H
        OR      L
        RET     Z
        DEC     HL
        LD      A,H
        OR      L
        JR      NZ,LAE50                ; (+$13) IF 0= False to end
        LD      HL,$EEE9        ; SMARTS point to ( monster SMARTneSs ) Byte-Variable in Static RAM
        INC     (HL)
        LD      HL,$EEBE        ; ASSH point to ( meanness counter ) Byte-Variable
        INC     (HL)
        LD      A,(HL)
        CP      $09             ; ASSH*** topped out ?
        JR      C,LAE4D                 ; (+$03) IF CY~ False skip
        LD      ($EEBD),A       ; SOB write ( S.O.B. ) Byte-Variable in Static RAM
LAE4D:  LD      HL,($EEE4)      ; SMTMRV read ( monster Smarts TMmeR resetter ) Variable in Static RAM
; end ??
LAE50:  LD      ($EEE7),HL      ; SMTMR write ( monster SMartness TMmeR ) Variable in Static RAM
        RET
; end of ( PLAYER INTERRUPT ROUTINE ) !!

; { BLOCK 0268 }
; ( CHECK FOR PLAYER ESCAPING INTO EXIT CHAMBER )
; F= etw
; SUBR ESCAPE?
; <ASSEMBLE
;  KEY OBJSV + LDA,
;  KYOPEN CPI,
;  etw JRZ,
;  MAFLG LDA,
;  A ANA,
;  RZ,
; LABEL etw
;  PLYRV NOWC + LDA,
;  START-COL CPI,
;  RNZ,
;  PLYRV NOWR + LDA,
;  START-ROW CPI,
;  RNZ, ( WE WIN! - SHAZAM! )
;  PLESC A MVI,
;  P-S STA,
;  RET,
; ASSEMBLE>
; HEX
;
; ESCAPE? does "check for player ESCAPing into Exit chamber" routine
LAE54:  LD      A,($F0CC)       ; KEY + OBJSV (offset 93) read Byte ?? for ?? in Static RAM
        CP      $01
        JR      Z,LAE60                 ; (+$05)
        LD      A,($EEC3)       ; MAFLG read ( MAgic in use FLaG ) Byte-Variable in Static RAM
        AND     A
        RET     Z
LAE60:  LD      A,($F16C)       ; PLYRV + NOWC ($F12D + 63) read Byte ?? for ?? in Static RAM
        CP      $05             ; START-COL 5 for ??
        RET     NZ
        LD      A,($F16B)       ; PLYRV + NOWR ($F12D + 62) read Byte ?? for ?? in Static RAM
        CP      $05             ; START-ROW constant 5 for "START ROW"
        RET     NZ              ; WE WIN! - SHAZAM!
        LD      A,$04           ; PLESC for "PLayer ESCaped"
        LD      ($EEE6),A       ; P-S write 4 into ( Player State ) Byte-Variable in Static RAM
        RET
; end of ( CHECK FOR PLAYER ESCAPING INTO EXIT CHAMBER ) !!

; ( CHECK FOR REVENGE AGAINST JAWS )
; SUBR RJAW?
;  XC? IFTRUE
;   JAWSF LDA,
;   1 CPI,
;   RNZ,
;   JAWSV X LXIX,
;   0200 B LXI,
;   PRXC CALL,
;   RZ,
;   2 A MVI,
;   JAWSF STA,
;  IFEND
;  RET,
; DECIMAL
; -->
;
; RJAW? does "check for Revenge against JAWS" routine
LAE72:  LD      A,($EEC1)       ; JAWSF read ( JAWs on Screen Flag ) Byte-Variable in Static RAM
        CP      $01
        RET     NZ
        LD      IX,$F529        ; JAWSV point to "JAWS Vector" base for IndeX in Static RAM
        LD      BC,$0200        ; 512 for ??
        CALL    L814B           ; PRXC do ??
        RET     Z
        LD      A,$02
        LD      ($EEC1),A       ; write Byte 2 for ?? in Static RAM
        RET
; end of { CHECK FOR REVENGE AGAINST JAWS } !!

; { BLOCK 0082 }
; ( PLAYER TASK JOYSTICK CHECKER )
; SUBR g:jc
;  g;j CALL,
;  0 H LXI,
;  RM,
;  A C MOV,
;  PLYRV NOWR + LDA,
;  A D MOV,
;  PLYRV NOWC + LDA,
;  A E MOV,
;  noded^ CALL,
;  M A MOV,
;  A ANA,
;  0=, IF,
;   C A MOV,
;   A ANA,
;   0=, IF,
;    ESCAPE? CALL,
;    0 H LXI,
;    P-S LDA,
;    PLESC CPI,
;    RZ,
;   THEN,
;   PLYRV NOWD + LDA,
;   A C MOV,
;   noded^ CALL,
;   M A MOV,
;   A ANA,
;  THEN,
;  0 H LXI,
;  RZ,
;  C A MOV,
;  PLYRV NOWD + STA,
;  A E MOV,
;  0 D MVI,
;  0 ROTN H LXI,
;  D DAD,
;  M A MOV,
;  PLYRV VANGLE + STA,
;  btrk? CALL,
;  1 H LXI,
;  RET,
;
; g:jc does "Player task Joystick Checker" routine
LAE89:  CALL    LACAD           ; g;j do "Get Joystick and Convert to DIRECTION"
        LD      HL,$0000        ; 0 for ?? False
        RET     M               ; bail if -1 for NONE or OTHER
        LD      C,A
        LD      A,($F16B)       ; PLYRV + NOWR ($F109 + 62) read Byte ?? for ?? in Static RAM
        LD      D,A
        LD      A,($F16C)       ; PLYRV + NOWC ($F109 + 62)read Byte ?? for ?? in Static RAM
        LD      E,A
        CALL    L868C           ; noded^ do ??
        LD      A,(HL)
        AND     A
        JR      NZ,LAEB9                ; (+$19) IF 0= False to THEN
        LD      A,C
        AND     A
        JR      NZ,LAEB0                ; (+$0c) IF 0= False skip
        CALL    LAE54           ; ESCAPE? do "check for player ESCAPing into Exit chamber"
        LD      HL,$0000        ; 0 for ?? False
        LD      A,($EEE6)       ; P-S read ( Player State ) Byte-Variable in Static RAM
        CP      $04             ; PLESC for "PLayer ESCaped"
        RET     Z
LAEB0:  LD      A,($F16D)       ; PLYRV + NOWD ($F12D + 64) read Byte ?? for ?? in Static RAM
        LD      C,A
        CALL    L868C           ; noded^ do ??
        LD      A,(HL)
        AND     A
LAEB9:  LD      HL,$0000        ; THEN 0 for ?? False
        RET     Z
        LD      A,C
        LD      ($F16D),A       ; PLYRV + NOWD ($F12D + 64) write Byte ?? for ?? in Static RAM
        LD      E,A
        LD      D,$00
        LD      HL,L8713        ; ROTN point to ?? 4-Byte table ??
        ADD     HL,DE
        LD      A,(HL)
        LD      ($F168),A       ; PLYRV + VANGLE ($F12D + 59) write Byte ?? for ?? in Static RAM
        CALL    LACE5           ; btrk? do "check for BackTRacK mode"
        LD      HL,$0001        ; 1 for ?? True
        RET

; CODE G:JC
;  B PUSH,
;  g:jc CALL,
;  B POP,
;  H PUSH,
; NEXT
; -->
;
; G:JC does "Player task Joystick Checker" from Terse
LAED3:  PUSH    BC
        CALL    LAE89           ; g:jc do "Player task Joystick Checker"
        POP     BC
        PUSH    HL
        JP      (IY)            ; indexed RETurn
; end of { PLAYER TASK JOYSTICK CHECKER } !!

; { BLOCK 0240 }
; ( CHECK PLAYER INTERCEPT WITH HOSTAGES )
; ( ROUTINE TO FIND INTERCEPTORS, IF ANY )
; ( ENTRY: BC= NEARNESS X AND Y, HL= CHECKLIST ADDR )
; ( IY= SUBJECT VECTOR )
; ( RETURNS Z= NOFIND NZ= FIND, IX= FOUND THANG )
; F= C:UH
; F= C:UL
; SUBR C:U:H
; <ASSEMBLE
; LABEL C:UH
;  M E MOV,
;  H INX,
;  M D MOV,
;  H INX,
;  D A MOV,
;  E ORA,
;  RZ,
;  D PUSH,
;  X POPX,
;  OBJSV X A LDX,
;  HSFREE CPI,
;  C:UL JRZ,
;  HSATM CPI,
;  C:UH JRNZ,
;  MAFLG LDA,
;  A ANA,
;  C:UH JRZ,
; LABEL C:UL
;  PRXC CALL,
;  RNZ,
;  C:UH JMPR,
; ASSEMBLE>
; -->
;
; C:U:H does "Check Player intercept with Hostages" routine
; ( ROUTINE TO FIND INTERCEPTORS, IF ANY )
; ( ENTRY: BC= NEARNESS X AND Y, HL= CHECKLIST ADDR )
; ( IY= SUBJECT VECTOR )
; ( RETURNS Z= NOFIND NZ= FIND, IX= FOUND THANG )
LAEDB:  LD      E,(HL)
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      A,D
        OR      E
        RET     Z
        PUSH    DE
        POP     IX
        LD      A,(IX+$5D)      ; OBJSV offset 93 for ( OBJect State Variable )
        CP      $00             ; HSFREE constant 0 for ( HoStage FREE )
        JR      Z,LAEF6                 ; (+$0a)
        CP      $02             ; HSATM constant 2 for ( HoSTagE Attached to Monster )
        JR      NZ,LAEDB                ; (-$15) if ?? to C:U:H for "Check Player & Hostages"
        LD      A,($EEC3)       ; MAFLG read ( MAgic in use FLaG ) Byte-Variable in Static RAM
        AND     A
        JR      Z,LAEDB                 ; (-$1b) if ?? to C:U:H for "Check Player & Hostages"
LAEF6:  CALL    L814B           ; PRXC do ??
        RET     NZ
        JR      LAEDB                   ; (-$21) to C:U:H for "Check Player (User ??) & Hostages"
; end of ( CHECK PLAYER INTERCEPT WITH HOSTAGES ) !!

; { BLOCK 0276 }
; ( CHECK PLAYER INTERCEPT WITH OTHER VECTORS )
; HEX
; SUBR P:I:C
;  FREEZE? CALL,
;  EXX,
;  0=, IF,
;   P-S LDA,
;   A DCR,
;   2 CPI,
;   CY, IF,
;    0200 B LXI,
;    PX-M CALL,
;    0<>, IF,
;     LRDIST CALL,
;     8 CPI,
;     CY, IF,
;      1 A MVI,
;      MYFLAG PLYRV + STA,
;      FREEZE CALL,
;      PLDOA A MVI,
;      P-S STA,
;      EXX,
;      RET,
;     THEN,
;    THEN,
;   THEN,
;  THEN,
;  0 HOSTAB H LXI,
;  0202 B LXI,
;  C:U:H CALL,
;  0<>, IF,
;   1 MYFLAG X MVIX,
;   HSATP OBJSV X MVIX,
;   X PUSHX,
;   Y PUSHX,
;   H POP,
;   D POP,
;   FUZH CALL,
;   Hctr H LXI,
;   M INR,
;   HALTNOW CALL,
;  THEN,
;  MAFLG LDA,
;  A ANA,
;  RJAW? CNZ,
;  TR:CHK CALL,
;  EXX,
;  RET,
; DECIMAL
; -->
;
; P:I:C does "Check Player Intercept with other vectors" routine
LAEFC:  CALL    L8523           ; FREEZE? do "TEST F-F for Freeze Flag"
        EXX
        JR      NZ,LAF28                ; (+$26) IF 0= False to THEN
        LD      A,($EEE6)       ; P-S read ( Player State ) Byte-Variable in Static RAM
        DEC     A
        CP      $02
        JR      NC,LAF28                ; (+$1e) IF CY False to THEN
        LD      BC,$0200        ; 512 for ( NARROWER window for MON - HOS )
        CALL    L9117           ; PX-M do "set window for MON - HOS"
        JR      Z,LAF28                 ; (+$16) IF 0<> False to THEN
        CALL    L8F4F           ; LRDIST do ??
        CP      $08
        JR      NC,LAF28                ; (+$0f) IF CY False to THEN
        LD      A,$01
        LD      ($F181),A       ; MYFLAG + PLYRV (84 + $F109) = 1 for ?? in Static RAM
        CALL    L851E           ; FREEZE do "INCrement F-F for Freeze Flag"
        LD      A,$03           ; PLDOA for "PLayer Dead On Arrival"
        LD      ($EEE6),A       ; P-S write 3 into ( Player State ) Byte-Variable in Static RAM
        EXX
        RET

; THEN for 4 IFs ??
LAF28:  LD      HL,L8374        ; HOSTAB point to 3-word "HOStage vector TABle"
        LD      BC,$0202        ; 514 for ??
        CALL    LAEDB           ; C:U:H do "Check Player intercept with Hostages"
        JR      Z,LAF4B                 ; (+$18) IF 0<> False skip
        LD      (IX+$54),$01    ; MYFLAG offset 84 for "SET ME EATEN flag" = 1
        LD      (IX+$5D),$01    ; OBJSV offset 93 = HSATP for ( HoStage Attached to Player )
        PUSH    IX
        PUSH    IY
        POP     HL
        POP     DE
        CALL    L9294           ; FUZH do "Force Hostage to have same position as interceptor"
        LD      HL,$EEC7        ; Hctr point to "Hostage CounTeR" Byte-Variable in Static RAM
        INC     (HL)
        CALL    L91A8           ; HALTNOW do ??
LAF4B:  LD      A,($EEC3)       ; MAFLG read ( MAgic in use FLaG ) Byte-Variable in Static RAM
        AND     A
        CALL    NZ,LAE72        ; RJAW? do "check for Revenge against JAWS"
        CALL    L98E8           ; TR:CHK do "CHecK player intercept with TReasure"
        EXX
        RET
; end of ( CHECK PLAYER INTERCEPT WITH OTHER VECTORS ) !!

; { BLOCK 0217 }
; ( SETVEL, ETC )
; HEX
; CODE SETVEL
;  H POP,
;  PLYRV DELTADIST + SHLD,
; NEXT
;
; SETVEL does "SET VELocity"
LAF57:  POP     HL
        LD      ($F179),HL      ; PLYRV + DELTADIST ($F12D + 76) write Word ?? into ?? in Static RAM
        JP      (IY)            ; indexed RETurn

; ?? not included !!
; ( CODE BTRK?
;  btrk? CALL,
; NEXT )
;

; CODE HALTER
;  HALTNOW CALL,
; NEXT
;
; HALTER does "HALTer" from Terse
LAF5D:  CALL    L91A8           ; HALTNOW do "HALT NOW"
        JP      (IY)            ; indexed RETurn

; CODE PERZAP
;  Y PUSHX,
;  vaddr LIYD,
;  PLYRV VPERINX + LDA,
;  2 ANI,
;  CH-PX CALL,
;  Y POPX,
; NEXT
;
; PERZAP does ??
LAF62:  PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      A,($F167)       ; PLYRV + VPERINX ($F12D + 58) read Byte ?? for ?? in Static RAM
        AND     $02
        CALL    LAA47           ; CH-PX do "CHange vectors Perspective indeX"
        POP     IY
        JP      (IY)            ; indexed RETurn

; CODE WALKER
;  B PUSH,
;  Y PUSHX,
;  vaddr LIYD,
;  NOWR Y D LDX,
;  NOWC Y E LDX,
;  NOWD Y C LDX,
;  noder^ CALL,
;  M A MOV,
;  6 CPI,
;  CY~, IF,
;   walk-s CALL,
;  THEN,
;  Y POPX,
;  B POP,
; NEXT
; DECIMAL
; -->
;
; WALKER does ??
LAF74:  PUSH    BC
        PUSH    IY
        LD      IY,($FEE6)      ; vaddr read "Vector ADDRess" base for IndexY in Static RAM
        LD      D,(IY+$3E)      ; NOWR offset 62 for ( CURRENT Row )
        LD      E,(IY+$3F)      ; NOWC offset 63 for ( CURRENT Column )
        LD      C,(IY+$40)      ; NOWD offset 64 for ( CURRENT Direction )
        CALL    L8696           ; noder^ do ??
        LD      A,(HL)
        CP      $06
        JR      C,LAF8F                 ; (+$03) IF CY~ False to THEN
        CALL    L33F0           ; walk-s do ??
LAF8F:  POP     IY
        POP     BC
        JP      (IY)            ; indexed RETurn
; end of { SETVEL, ETC } !!

; { BLOCK 0134 }
; ( COUNT OFF THE TREASURES AND HOSTAGES )
; DECIMAL
; : END-ER ;TASK: ( RUN ON OUT )
; plup B@ 0= ROTN B@ ANGLE!
; THIS:LIFE ROTOPOS DESTY! DESTX!
; HM-T TIMER!-ON A->DEST/TIME GO ZERODXDYAXAY
; RR# B@ 4 > IF NULPAT ANIM! 1 TIMER!-ON GO THEN
; 20 TIMER!-ON WAIT 0 F#A B! VGER-OUT ;
;
; END-ER does ( COUNT OFF THE TREASURES AND HOSTAGES )
LAF94:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ; ( RUN ON OUT )
        DW      L00BC           ; plup "pushWORD to System stack"
        DW      $E399           ; for ( PLayer-1 UP ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ;
        DW      L00CD           ; ROTN "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      L8713           ; point to ?? 4-Byte table ??
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L1AF9           ; ANGLE! do "SET ANGLE"
        ;
        DW      L8D4F           ; THIS:LIFE do ??
        ;
        DW      L8D7F           ; ROTOPOS do ??
        ;
        DW      L1B83           ; DESTY! do "convert +/- Y REL to PIXEL lines and save in VDESTY ??"
        ;
        DW      L1B71           ; DESTX! do "convert +/- X to REL Bytes and save in +/- Y to REL line ??"
        ;
        DW      L00C5           ; HM-T "pushBYTE to System stack"
        DB      $28             ; constant 40 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L85BD           ; A->DEST/TIME do "vector between position and DEST in TIME given"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L1D2F           ; ZERODXDYAXAY do ??
        ;
        DW      L0742           ; RR# do "get Robby Rotos left for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ; IF False skip to THEN
        DW      L03CD,LAFD2     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; NULPAT "pushWORD to System stack"
        DW      L81AD           ; for un-colored 0x0 BLANK pattern
        ;
        DW      L1BE2           ; ANIM! do Set up BLANK Pattern for ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ; THEN
LAFD2:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L8405           ; F#A do "get CURRENT ??"
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L221F           ; VGER-OUT do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; XC? IFTRUE ( WAIT FOR ALL MONSTERS )
;  : W-AIP 0 5 0 DO I I:M ACTIVE? IF I I:M OBJSV OVB@
;  MSAIP <> IF DROP 1 THEN THEN LOOP IF 5 TIMER!-ON WAIT 0
;  ELSE 1 THEN COGO ; OTHERWISE
;  : W-AIP 0 2 0 DO I I:M ACTIVE? IF I I:M OBJSV OVB@
;  MSAIP <> IF DROP 1 THEN THEN LOOP IF 5 TIMER!-ON WAIT 0
;  ELSE 1 THEN COGO ; IFEND
; -->
;
;
; W-AIP does ( WAIT FOR ALL MONSTERS ) routine
LAFE3:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L8352           ; I:M do ??
        ;
        DW      L1EFA           ; ACTIVE? do ??
        ; IF False to THEN #1
        DW      L03CD,LB00C     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L8352           ; I:M do ??
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L819D           ; OVB@ does ??
        ;
        DW      L00C5           ; MSAIP "pushBYTE to System stack"
        DB      $02             ; constant 2 for ( Monster State At Initial Position )
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ; IF False skip to THEN #2
        DW      L03CD,LB00C     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; THEN #1, THEN #2 and TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
LB00C:  DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; IF False skip to ELSE #3
        DW      L03CD,LB01E     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; (done so Jump to THEN #3)
        DW      L03C5,LB020     ; TerseJUMP to ??
        ; ELSE #3
LB01E:  DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; THEN #3
LB020:  DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0134 } !!

; { BLOCK 0182 }
; ( DROP INTO CHAMBER )
; : DROPIN DIVG 0 DELTADIST V!
; ( 0 0 ARV Sim 2 ARS B! )
; 0 X! RP-Y Y!
; EMOV
; ROTROTY ANIM! XOR-ON
; ST-X DESTX! ST-Y DESTY! DC-T TIMER!-ON A->DEST/TIME GO
; EMOV
; H-P-D DISPF VB! ESTPOS
; PLIC P.S B! COGO ;
;
; DROPIN does "DROP INto chamber"
LB024:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; DELTADIST "pushBYTE to System stack"
        DB      $4C             ; offset 76 for ??
        ;
        DW      L8166           ; V! do "STORE (SP+2) into (SP) offset Vector ADDRess"
        ; commented out: ( 0 0 ARV Sim 2 ARS B! )
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      L00C5           ; RP-Y "pushBYTE to System stack"
        DB      $52             ; constant 82 for ??
        ;
        DW      L1D10           ; Y! do ??
        ;
        DW      L8517           ; EMOV do ??
        ;
        DW      L00BC           ; ROTROTY "pushWORD to System stack"
        DW      L2DC4           ; for "PAUSE then DIG ROTOS" animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGING ROTOS Animation Loop for ??
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L00C5           ; ST-X "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L1B71           ; DESTX! do "convert +/- X to REL Bytes and save in +/- Y to REL line ??"
        ;
        DW      L00C5           ; ST-Y "pushBYTE to System stack"
        DB      $34             ; constant 52 for ??
        ;
        DW      L1B83           ; DESTY! do "convert +/- Y REL to PIXEL lines and save in VDESTY ??"
        ;
        DW      L00C5           ; DC-T "pushBYTE to System stack"
        DB      $0F             ; constant 15 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L85BD           ; A->DEST/TIME do "vector between position and DEST in TIME given"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L8517           ; EMOV do ??
        ;
        DW      L00C5           ; H-P-D "pushBYTE to System stack"
        DB      $10             ; constant 16 for ( Hostage to Player Distance )
        ;
        DW      L00C5           ; DISPF "pushBYTE to System stack"
        DB      $56             ; offset 86 for ( DISPlacement Factor )
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L88DF           ; ESTPOS do ??
        ;
        DW      L00C5           ; PLIC "pushBYTE to System stack"
        DB      $01             ; constant 1 for "PLayer state = In Chamber"
        ;
        DW      L83FF           ; P.S do "Get Rlayer State variable-address"
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00B0           ; ... TerseRETurn

; XC? NOT IFTRUE : DROP-S ;
;  : VSEN ; : TRY-PA ;
;  : GO-SET GAMEOVER BONE ;
; IFEND
; ( FIX GAMEOVER AND VSEN SHIT )
; -->
; end of { BLOCK 0182 } !!

; { BLOCK 0258 }
; ( ROTO / PLAYER TASK )
; DECIMAL
; : R:B ;TASK: ( ESTABLISH SPEEDS )
; Src Snm REVV H:R BEGIN DIVG
; P.S B@ PLEM CASE
; DVECT-OFF
; RR# B@ 5 < IF THIS:LIFE ROTOPOS NERDUP IF 32 ELSE 96 THEN RTw
; THEN THIS:LIFE ROTOPOS DUP Y! DESTY! X! 0 DESTX!
; EMOV ENTER-S
; ROTROTY ANIM! XOR-ON plup B@ ROTN B@ ANGLE!
; HM-T TIMER!-ON A->DEST/TIME GO SFXV MA-T
; EMOV BEGIN KICKBK ' W-AIP SETCO COGO END ' OPDR SETCO COGO
; ' DROPIN SETCO COGO P-RTY ANIM!
; KEY OBJSV OVB@ KYOPEN <> IF ' CLDR SETCO COGO THEN PERZAP
; -->
;
; { BLOCK 0227 }
; ELSE PLIC CASE ( IN A CHAMBER CASE )
; PROPDELTAS DIRFLAG BZERO
; DIVG_CHECK JOYSTICK TO SEE IF WE CAN LEAVE )
; G:JC
; IF
; PLMV P.S B!
; -->
;
; { BLOCK 0269 }
; ( GO FROM INCHAM TO MOVEABOUT )
; EPLYRV ( ESTABLISH PLAYER VELOCITY )
; DEPART:NODE PERZAP P-RTY ANIM! 7 VROTINXSHF VB!
; WALKER ( SYNC )
; THEN
; -->
;
; { BLOCK 0253 }
; ( WE ARE DEAD STATE )
; ELSE PLDOA CASE
; PDOA ANIM! GRAB-S
; RR# 1-WPB! RR# B@ 0= IF
; botha B@ 0= IF GO-SET THEN SFXV GO-T THEN
; 0 SETVEL HALTER DISHOS
; BEGIN DSM4 B@ 0<> MONV1 OBJSV OVB@ MSSNA = OR
; WHILE SYNC REPEAT
; 0 MYFLAG VB! MONV1 RAVISH SYNC DIVG
; BEGIN POA GO FLAG? END 4 TIMER!-ON WAIT
; PLEM P.S B! ' DEPARTSKI SETCO COGO UNFREEZE
; botha B@ IF RR# B@ 0= IF 120 TIMER!-ON WAIT THEN VGER-OUT SLEEP
; ELSE RR# B@ 0= IF VSEN TRY-PA
; 240 TIMER!-ON WAIT VGER-OUT SLEEP
; ELSE GA# B@ 7 MIN SMARTS B!
; Src Snm ESTPOS THEN THEN
; -->
;
; { BLOCK 0187 }
; ( PLAYER ESCAPE INTO EXIT CHAMBER )
; ELSE PLESC CASE FREEZE 0 PERINX! ESTPOS 0 ASSMSV VB!
; SUCK-S
; ROTROTY ANIM!
; ( IF # HOSTAGES FREED IS > PREV MAX THEN UPDATE IT )
; Hctr B@ MH# B@ MAX MH# WPB!
; Hctr B@ IF BANTOP THEN ( KICKOUT MONSTERS )
; O-M BZERO EV:R
; GO DIVG EMOV
; -->
;
; { BLOCK 0170 }
; ( MORE ESCAPE STUFF )
; ( WAIT FOR HOSTAGES TO LEAVE )
; Hctr B@ IF Chw BZERO
; BEGIN Hctr B@ 0<> Chw B@ 60 < AND WHILE Chw 1+B! 5 TIMER!-ON
; WAIT DIVG BANTOP REPEAT
; FREDH B@ TOTAL-HOSTAGES = IF EOF BONE SELF END-ER SLEEP THEN
; BEGIN BANTOP ' W-AIP SETCO COGO END
; ELSE 5 TIMER!-ON WAIT SMARTS 1+B! THEN
; UNFREEZE
; 0 DRPO VB! ( CLEAR DROP IN FLAGOLA )
; DROP-S ( SECOND CHECK FOR FREED HOSTAGES )
; FREDH B@ TOTAL-HOSTAGES = IF EOF BONE SELF END-ER SLEEP THEN
; ' DROPIN SETCO COGO FREM
; -->
;
; { BLOCK 0046 }
; ( LAST PART OF PLAYER TASK )
; ELSE PLMV CASE ( MOVING AROUND - DO NOTHIN YET )
; ELSE ( XDI ." FLAKE" ) THEN THEN THEN THEN THEN
; ( IF NOT MOVING PAUSE FOR A BIT )
; P.S B@ PLMV <> IF 2 TIMER!-ON 0 SETVEL THEN
; P:I:C HOOK!-ON
; PROPDELTAS POA DVECT-ON mastersur IGO DIVG
; O-M BZERO
;
; ( YET MORE PLAYER CONTROLLER )
; DEST? IF ARRIVE:NODE CHRV C:RT
; P.S B@ PLDOA < IF PLIC P.S B! THEN
; ( ESCAPE? ) DIVG PERZAP P-RTY ANIM! THEN
; 0 END ;
; DECIMAL
; -->
;
; R:B does "ROTO / PLAYER TASK "
LB06B:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ; ( ESTABLISH SPEEDS )
        DW      L84EE           ; Src do ??
        ;
        DW      L84AF           ; Snm do ??
        ;
        DW      L00BC           ; REVV "pushWORD to System stack"
        DW      $F0CD           ; for "?? Vector" base in Static RAM
        ;
        DW      L9607           ; H:R does "bizarre revealer function" ??
        ; BEGIN loop #1
LB078:  DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L83FF           ; P.S do "Get Rlayer State variable-address"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00C5           ; PLEM "pushBYTE to System stack"
        DB      $00             ; constant 0 for "PLayer state variable ??"
        ; _CASE "TEST State = 0 and Skip Over if False ?? or Continue if True"
        DW      L0427,LB128     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L88B3           ; DVECT-OFF do "DE-ACTIVATE Distance Vectoring"
        ;
        DW      L0742           ; RR# do "get Robby Rotos left for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; __IF False to THEN #1
        DW      L03CD,LB0A9     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L8D4F           ; THIS:LIFE do ??
        ;
        DW      L8D7F           ; ROTOPOS do ??
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ; ___IF False skip to ELSE #2
        DW      L03CD,LB0A4     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ; ___(done so Jump to THEN #2)
        DW      L03C5,LB0A7     ; TerseJUMP to ??
        ; ___ELSE #2
LB0A4:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $60             ; 96 for ??
        ; ___THEN #2
LB0A7:  DW      L8D46           ; RTw do "display Remaining LIVES, and Terminate"
        ; __THEN #1
LB0A9:  DW      L8D4F           ; THIS:LIFE do ??
        ;
        DW      L8D7F           ; ROTOPOS do ??
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L1D10           ; Y! do ??
        ;
        DW      L1B83           ; DESTY! do "convert +/- Y REL to PIXEL lines and save in VDESTY ??"
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L1B71           ; DESTX! do "convert +/- X to REL Bytes and save in +/- Y to REL line ??"
        ;
        DW      L8517           ; EMOV do ??
        ;
        DW      L3A31           ; ENTER-S do ??
        ;
        DW      L00BC           ; ROTROTY "pushWORD to System stack"
        DW      L2DC4           ; for "PAUSE then DIG ROTOS" animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGING ROTOS Animation Loop for ??
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L00BC           ; plup "pushWORD to System stack"
        DW      $E399           ; for ( PLayer-1 UP ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00CD           ; ROTN "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      L8713           ; point to ?? 4-Byte table ??
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L1AF9           ; ANGLE! do "SET ANGLE"
        ;
        DW      L00C5           ; HM-T "pushBYTE to System stack"
        DB      $28             ; constant 40 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L85BD           ; A->DEST/TIME do "vector between position and DEST in TIME given"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00BC           ; SFXV "pushWORD to System stack"
        DW      $F227           ; for "?? Vector" base in Static RAM
        ;
        DW      LABB0           ; MA-T do "MAgic Task"
        ;
        DW      L8517           ; EMOV do ??
        ; __BEGIN short loop #2
LB0E4:  DW      LA964           ; KICKBK do ( FORCE OTHERS BACK TO INIT POS )
        ;
        DW      L00BC           ; W-AIP "pushWORD to System stack"
        DW      LAFE3           ; point to ( WAIT FOR ALL MONSTERS ) routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ; __END #2 or loop to BEGIN #2 if False
        DW      L03CD,LB0E4     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; OPDR "pushWORD to System stack"
        DW      L9EA4           ; point to "OPen DooR" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00BC           ; DROPIN "pushWORD to System stack"
        DW      LB024           ; point to "DROP INto chamber" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L00BC           ; P-RTY "pushWORD to System stack"
        DW      L8347           ; for 4-Word VARIOUS ROTOS animation loop
       ;
        DW      L1BE2           ; ANIM! do Set up Various ROTOS Animation Loop for ??
        ;
        DW      L00BC           ; KEY "pushWORD to System stack"
        DW      $F06F           ; for "KEY Vector" base in Static RAM
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L819D           ; OVB@ does ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $01             ; 1 for ??
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ; __IF False to THEN #3
        DW      L03CD,LB122     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; CLDR "pushWORD to System stack"
        DW      L9E5B           ; point to "CLose DooR" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ; __THEN #3
LB122:  DW      LAF62           ; PERZAP do ??
        ; _(end of CASE = 0 so ...)
        DW      L03C5,LB341     ; TerseJUMP to THENs
        ; _(Case = 0 ELSE label)
LB128:  DW      L00C5           ; PLIC "pushBYTE to System stack"
        DB      $01             ; constant 1 for "PLayer state = In Chamber"
        ; _CASE "TEST State = 1 and Skip Over if False ?? or Continue if True"
        DW      L0427,LB15F     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ; ( IN A CHAMBER CASE )
        DW      L91FB           ; PROPDELTAS do "interface to the terse world"
        ;
        DW      L00BC           ; DIRFLAG "pushWORD to System stack"
        DW      $EEEC           ; for ( player DIRection FLAG ) Byte-Variable in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ; ( CHECK JOYSTICK TO SEE IF WE CAN LEAVE )
        DW      LAED3           ; G:JC do "Player task Joystick Checker"
        ; __IF False to THEN #4
        DW      L03CD,LB15B     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ; ( GO FROM INCHAM TO MOVEABOUT )
        DW      L00C5           ; PLMV "pushBYTE to System stack"
        DB      $02             ; constant 2 for "PLayer state = MoVeabout"
        ;
        DW      L83FF           ; P.S do "Get Rlayer State variable-address"
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; ( ESTABLISH PLAYER VELOCITY )
        DW      LACFA           ; EPLYRV do "Establish PLaYeR Velocity set up"
        ;
        DW      L8906           ; DEPART:NODE do "travel AWAY from NODE"
        ;
        DW      LAF62           ; PERZAP do ??
        ;
        DW      L00BC           ; P-RTY "pushWORD to System stack"
        DW      L8347           ; for 4-Word VARIOUS ROTOS animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up Various ROTOS Animation Loop for ??
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for ??
        ;
        DW      L00C5           ; VROTINXSHF "pushBYTE to System stack"
        DB      $39             ; 57 for ?? ONLY reference to this !!
        ;
        DW      L817C           ; VB! do ??
        ; ( SYNC )
        DW      LAF74           ; WALKER do ??
        ; __THEN #4 and (end of CASE = 1 so ...)
LB15B:  DW      L03C5,LB341     ; TerseJUMP to THENs
        ; _(Case = 1 ELSE label)
LB15F:  DW      L00C5           ; PLDOA "pushBYTE to System stack"
        DB      $03             ; constant 3 for "PLayer Dead On Arrival"
        ; _CASE "TEST State = 3 and Skip Over if False ?? or Continue if True"
        DW      L0427,LB246     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ; ( WE ARE DEAD STATE )
        DW      L00BC           ; PDOA "pushWORD to System stack"
        DW      L229F           ; for "Player Dead On Arrival" animation table
        ;
        DW      L1BE2           ; ANIM! do Set up wrapped up ROBBY Animation Loop for ??
        ;
        DW      L377E           ; GRAB-S do ??
        ;
        DW      L0742           ; RR# do "get Robby Rotos left for CURRENT player"
        ;
        DW      L07CE           ; 1-WPB! do "DECREMENT WRITE-protectedBYTE in (SP)"
        ;
        DW      L0742           ; RR# do "get Robby Rotos left for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; __IF False to THEN #5
        DW      L03CD,LB190     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; botha "pushWORD to System stack"
        DW      $E398           ; for ( BOTH players Active ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; ___IF False skip to THEN #6
        DW      L03CD,LB18A     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0858           ; GO-SET do "Two pairs of 0's then a pair of 1's in NV-RAM"
        ; ___THEN #6
LB18A:  DW      L00BC           ; SFXV "pushWORD to System stack"
        DW      $F227           ; for "?? Vector" base in Static RAM
        ;
        DW      L8CAB           ; GO-T do ??
        ; __THEN #5
LB190:  DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      LAF57           ; SETVEL do "SET VELocity"
        ;
        DW      LAF5D           ; HALTER do "HALTer"
        ;
        DW      L9B5C           ; DISHOS do "player HOStage interface junk"
        ; __BEGIN (WHILE REPEAT) loop #3
LB198:  DW      L00BC           ; DSM4 "pushWORD to System stack"
        DW      $EEBF           ; for ( Door SeMiFORE ) Byte-Variable in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F6           ; 0<> do "Pop HL, Push F on Zero or T on Not Zero"
        ;
        DW      L00BC           ; MONV1 "pushWORD to System stack"
        DW      $FD51           ; for "MONster Vector" #1 base in Static RAM
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L819D           ; OVB@ does ??
        ;
        DW      L00C5           ; MSSNA "pushBYTE to System stack"
        DB      $03             ; constant 3 for ( Monster State SNAtch hostage )
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ; __WHILE False to loop #3 Exit (aka WHILE True continue in BEGIN ... REPEAT loop)
        DW      L03CD,LB1BA     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L1660           ; SYNC do ??
        ; __REPEAT loop #3 to BEGIN #3 always
        DW      L03C5,LB198     ; REPEAT do "TerseJUMP to TerseBEGIN label"
        ; __loop #3 Exit
LB1BA:  DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; MYFLAG "pushBYTE to System stack"
        DB      $54             ; offset 84 for "RE-SET ME EATEN flag"
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L00BC           ; MONV1 "pushWORD to System stack"
        DW      $FD51           ; for "MONster Vector" #1 base in Static RAM
        ;
        DW      LA9D5           ; RAVISH do ??
        ;
        DW      L1660           ; SYNC do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ; __BEGIN short loop #4
LB1CB:  DW      L84E4           ; POA do ??
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L1B5F           ; FLAG? do ??
        ; __END #4 or loop to BEGIN #4 if False
        DW      L03CD,LB1CB     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00C5           ; PLEM "pushBYTE to System stack"
        DB      $00             ; constant 0 for "PLayer state variable ??"
        ;
        DW      L83FF           ; P.S do "Get Rlayer State variable-address"
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; DEPARTSKI "pushWORD to System stack"
        DW      LA997           ; point to "grab player and leave playfield" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L852D           ; UNFREEZE do "DECrement F-F for Freeze Flag MIN Zero"
        ;
        DW      L00BC           ; botha "pushWORD to System stack"
        DW      $E398           ; for ( BOTH players Active ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; __IF False to ELSE #7
        DW      L03CD,LB20F     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0742           ; RR# do "get Robby Rotos left for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; ___IF False skip to THEN #8
        DW      L03CD,LB207     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $78             ; 120 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ; ___THEN #8
LB207:  DW      L221F           ; VGER-OUT do ??
        ;
        DW      L1670           ; SLEEP do ??
        ; __(done so Jump to THEN #7)
        DW      L03C5,LB242     ; TerseJUMP to ??
        ; __ELSE #7
LB20F:  DW      L0742           ; RR# do "get Robby Rotos left for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; ___IF False to ELSE #9
        DW      L03CD,LB22E     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; VSEN "pushWORD to System stack"
        DW      $FDB1           ; for Word ?? for ?? in Static RAM
        ;
        DW      L3C04           ; TRY-PA do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $F0             ; 240 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L221F           ; VGER-OUT do ??
        ;
        DW      L1670           ; SLEEP do ??
        ; ___(done so Jump to THEN #9)
        DW      L03C5,LB242     ; TerseJUMP to ??
        ; ___ELSE #9
LB22E:  DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L00BC           ; SMARTS "pushWORD to System stack"
        DW      $EEE9           ; for ( monster SMARTneSs ) Byte-Variable in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L84EE           ; Src do ??
        ;
        DW      L84AF           ; Snm do ??
        ;
        DW      L88DF           ; ESTPOS do ??
        ; __THEN #7, THEN #9 and (end of CASE = 3 so ...)
LB242:  DW      L03C5,LB341     ; TerseJUMP to THENs
        ; _(Case = 3 ELSE label)
LB246:  DW      L00C5           ; PLESC "pushBYTE to System stack"
        DB      $04             ; constant 4 for "PLayer ESCaped"
        ; _CASE "TEST State = 4 and Skip Over if False ?? or Continue if True"
        DW      L0427,LB336     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ; ( PLAYER ESCAPE INTO EXIT CHAMBER )
        DW      L00BC           ; FREEZE "pushWORD to System stack"
        DW      L851E           ; for "INCrement F-F for Freeze Flag"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L1C3A           ; PERINX! do ??
        ;
        DW      L88DF           ; ESTPOS do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5E             ; 94 for ??
        ;
        DW      L817C           ; VB! do ??
        ;
        DW      L3B88           ; SUCK-S do ??
        ;
        DW      L00BC           ; ROTROTY "pushWORD to System stack"
        DW      L2DC4           ; for "PAUSE then DIG ROTOS" animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGING ROTOS Animation Loop for ??
        ; ( IF # HOSTAGES FREED IS > PREV MAX THEN UPDATE IT )
        DW      L00BC           ; Hctr "pushWORD to System stack"
        DW      $EEC7           ; for "Hostage CounTeR" Byte-Variable in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L075D           ; MH# do "get Max Hostages FREED by CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L03F2           ; MAX do "keep on;y MAXimum of Top 2 on System Stack"
        ;
        DW      L075D           ; MH# do "get Max Hostages FREED by CURRENT player"
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ;
        DW      L00BC           ; Hctr "pushWORD to System stack"
        DW      $EEC7           ; for "Hostage CounTeR" Byte-Variablein Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; __IF False skip to THEN #10
        DW      L03CD,LB282     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ; ( KICKOUT MONSTERS )
        DW      LA96D           ; BANTOP do "BANish monsters TO lower screen Position"
        ; __THEN #10
LB282:  DW      L00BC           ; O-M "pushWORD to System stack"
        DW      $EEEB           ; for ( Object Moving ) Byte-Variable in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L92AF           ; EV:R do ??
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L8517           ; EMOV do ??
        ; ( MORE ESCAPE STUFF )
        DW      L00BC           ; Hctr "pushWORD to System stack"
        DW      $EEC7           ; for "Hostage CounTeR" Byte-Variable in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; __IF False to ELSE #11
        DW      L03CD,LB2F8     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ; ( WAIT FOR HOSTAGES TO LEAVE )
        DW      L00BC           ; Chw "pushWORD to System stack"
        DW      $EEC0           ; for "Hostage Wait Counter" Byte-Variable in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ; ___BEGIN (WHILE REPEAT) loop #5
LB2A0:  DW      L00BC           ; Hctr "pushWORD to System stack"
        DW      $EEC7           ; for "Hostage CounTeR" Byte-Variable in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F6           ; 0<> do "Pop HL, Push F on Zero or T on Not Zero"
        ;
        DW      L00BC           ; Chw "pushWORD to System stack"
        DW      $EEC0           ; for ( Hostage Wait Counter ) Byte-Variable
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3C             ; 60 for ??
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ; ___WHILE False to loop #5 Exit (aka WHILE True continue in BEGIN ... REPEAT loop)
        DW      L03CD,LB2CD     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; Chw "pushWORD to System stack"
        DW      $EEC0           ; for ( Hostage Wait Counter ) Byte-Variable in Static RAM
        ;
        DW      L0442           ; 1+B! do "Pop HL, ADD 1 to (HL)"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      LA96D           ; BANTOP do "BANish monsters TO lower screen Position"
        ; ___REPEAT loop #5 to BEGIN #5 always
        DW      L03C5,LB2A0     ; REPEAT do "TerseJUMP to TerseBEGIN label"
        ; ___loop #5 Exit
LB2CD:  DW      L843D           ; FREDH do "get FREeD Hostage counter"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00C5           ; TOTAL-HOSTAGES "pushBYTE to System stack"
        DB      $03             ; constant 3 for "TOTAL HOSTAGES"
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; ___IF False to THEN #12
        DW      L03CD,LB2E6     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; EOF "pushWORD to System stack"
        DW      $EEC8           ; for ( End Of Frame flag ) Byte-Variable
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      LAF94           ; END-ER do ( COUNT OFF THE TREASURES AND HOSTAGES )
        ;
        DW      L1670           ; SLEEP do ??
        ; ___THEN #12 and BEGIN short loop #6
LB2E6:  DW      LA96D           ; BANTOP do "BANish monsters TO lower screen Position"
        ;
        DW      L00BC           ; W-AIP "pushWORD to System stack"
        DW      LAFE3           ; point to ( WAIT FOR ALL MONSTERS ) routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ; ___END #6 or loop to BEGIN #6 if False
        DW      L03CD,LB2E6     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ; __(done so Jump to THEN #11)
        DW      L03C5,LB304     ; TerseJUMP to ??
        ; __ELSE #11
LB2F8:  DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; SMARTS "pushWORD to System stack"
        DW      $EEE9           ; for ( monster SMARTneSs ) Byte-Variable in Static RAM
        ;
        DW      L0442           ; 1+B! do "Pop HL, ADD 1 to (HL)"
        ; __THEN #11
LB304:  DW      L852D           ; UNFREEZE do "DECrement F-F for Freeze Flag MIN Zero"
        ;  ( CLEAR DROP IN FLAGOLA )
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; DRPO "pushBYTE to System stack"
        DB      $55             ; offset 85 for ( DRoP Off flag )
        ;
        DW      L817C           ; VB! do ??
        ; ( SECOND CHECK FOR FREED HOSTAGES )
        DW      L39AF           ; DROP-S do "SECOND CHECK FOR FREED HOSTAGES"
        ;
        DW      L843D           ; FREDH do "get FREeD Hostage counter"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00C5           ; TOTAL-HOSTAGES "pushBYTE to System stack"
        DB      $03             ; constant 3 for "TOTAL HOSTAGES"
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; __IF False skip to THEN #13
        DW      L03CD,LB328     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; EOF "pushWORD to System stack"
        DW      $EEC8           ; for ( End Of Frame flag ) Byte-Variable in Static RAM
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      LAF94           ; END-ER do ( COUNT OFF THE TREASURES AND HOSTAGES )
        ;
        DW      L1670           ; SLEEP do ??
        ; __THEN #13
LB328:  DW      L00BC           ; DROPIN "pushWORD to System stack"
        DW      LB024           ; point to "DROP INto chamber" routine
        ;
        DW      L848E           ; SETCO do "SET (SP)+1 as my COroutine"
        ;
        DW      L847E           ; COGO do "exchage BC with VCOR (my CORoutine cell)"
        ;
        DW      L9B94           ; FREM do "FREe hostages from Monster"
        ; _(end of CASE = 4 so ...)
        DW      L03C5,LB341     ; TerseJUMP to THENs
        ; _(Case = 4 ELSE label) so ( LAST PART OF PLAYER TASK )
LB336:  DW      L00C5           ; PLMV "pushBYTE to System stack"
        DB      $02             ; constant 2 for "PLayer state = MoVeabout"
        ; _CASE (empty !!) "TEST State = 2 and Skip Over if False ?? or Continue if True"
        DW      L0427,LB341     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ; _(end of CASE = 2 so ...) still ( MOVING AROUND - DO NOTHIN YET )
        DW      L03C5,LB341     ; TerseJUMP to HERE !! ( XDI ." FLAKE" )
        ; _(Case = 3 ELSE label) and THENs for 5 CASes ( IF NOT MOVING PAUSE FOR A BIT )
LB341:  DW      L83FF           ; P.S do "Get Rlayer State variable-address"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00C5           ; PLMV "pushBYTE to System stack"
        DB      $02             ; constant 2 for "PLayer state = MoVeabout"
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ; _IF False skip to THEN #14
        DW      L03CD,LB356     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      LAF57           ; SETVEL do "SET VELocity"
        ; _THEN #14
LB356:  DW      L00BC           ; do "pushWORD to System stack"
        DW      LAEFC           ; point to P:I:C for "Player Intercept Check"
        ;
        DW      L1BCF           ; HOOK!-ON do ??
        ;
        DW      L91FB           ; PROPDELTAS do "interface to the terse world"
        ;
        DW      L84E4           ; POA do ??
        ;
        DW      L88D6           ; DVECT-ON do "ACTIVATE Distance Vectoring"
        ;
        DW      L00BC           ; mastersur "pushWORD to System stack"
        DW      L1367           ; point to ?? routine ??
        ;
        DW      L8108           ; IGO do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00BC           ; O-M "pushWORD to System stack"
        DW      $EEEB           ; for ( Object Moving ) Byte-Variable in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ; ( YET MORE PLAYER CONTROLLER )
        DW      L1B95           ; DEST? do ??
        ; _IF False to THEN #15
        DW      L03CD,LB39C     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L8915           ; ARRIVE:NODE do "ARRIVE at NODE"
        ;
        DW      L00BC           ; CHRV "pushWORD to System stack"
        DW      $F2C1           ; for ( CHamber Reveal Vector )
        ;
        DW      L9641           ; C:RT do "Chamber Revealer Task"
        ;
        DW      L83FF           ; P.S do "Get Rlayer State variable-address"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00C5           ; PLDOA for "pushBYTE to System stack"
        DB      $03             ; constant 3 for "PLayer Dead On Arrival"
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; __IF False skip to THEN #16
        DW      L03CD,LB392     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; PLIC "pushBYTE to System stack"
        DB      $01             ; constant 1 for "PLayer state = In Chamber"
        ;
        DW      L83FF           ; P.S do "Get Rlayer State variable-address"
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; __THEN #16
LB392:  DW      L199F           ; DIVG do "clear ?? word"
        ; ( ESCAPE? )
        DW      LAF62           ; PERZAP do ??
        ;
        DW      L00BC           ; P-RTY "pushWORD to System stack"
        DW      L8347           ; for 4-Word VARIOUS ROTOS animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up Various ROTOS Animation Loop for ??
        ; _THEN #15
LB39C:  DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; END #1 or loop to BEGIN #1 if False
        DW      L03CD,LB078     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0258 } !!

; { BLOCK 0279 }
; ( PROCESS A HOT ROD MISSLE )
; SUBR HOTROD
;  TBMISSLE TSTAT Y BITX, ( are we ready to process )
;  RZ, ( NOT A MISSLE )
; ( A= timebase )
;  mastervmr CALL,
;  CMFLOP VLOGICSTAT Y BITX, ( time to write ? )
;  CMFLOP VLOGICSTAT Y RESX,
;  0<>, IF,
;   TSUR Y L LDX,
;   TSUR 1+ Y H LDX,
;   FORKETH CALL,
;  THEN,
;  RET,
; -->
;
; HOTROD does "process a HOT ROD missle" routine
LB3A4:  BIT     2,(IY+$04) ; TBMISSLE bit 2 of TSTAT offset 4 (are we ready to process)
        RET     Z               ; if   NOT A MISSLE )
        CALL    L18C0           ; mastervmr do ?? with ( A= timebase )
        BIT     CMFLOP,(IY+$24) ; is CMFLOP bit 5 of VLOGICSTAT offset 36 set ?
        RES     CMFLOP,(IY+$24) ; clear it regardless ( time to write ? )
        JR      Z,LB3BF                 ; (+$09) IF 0<> False to THEN no
        LD      L,(IY+$08)      ; TSUR offset 8
        LD      H,(IY+$09)      ; TSURH offset 9
        CALL    L993A           ; FORKETH do "JumP to (HL)" to TreaSURe ??
LB3BF:  RET                     ; THEN
; end of ( PROCESS A HOT ROD MISSLE ) !!

; { BLOCK 0280 }
; <STKH
; F= rDI
; SUBR MIS-INT
; <ASSEMBLE ( missle interrupt test )
;  PSW PUSH,
;  B PUSH,
;  D PUSH,
;  H PUSH,
;  EXX,
;  EXAF,
;  PSW PUSH,
;  B PUSH,
;  D PUSH,
;  H PUSH,
;  Y PUSHX,
;  X PUSHX,
;  BKC LDA,
;  4 OUT, ( REFRESH BACKGROUND COLOR )
;  SUI2L LDA,
;  INLIN OUT, ( set interrupt line )
;  SUI2V SWAB A MVI,
;  STAI, ( load I reg )
;  SUI2V A MVI,
;  INFBK OUT, ( load feedback port )
;  SU1flag LDA, ( inprogress )
;  1 CPI,
;  =, IF, ( overrun )
;   2 A MVI,
;   SU1flag STA,
;  THEN,
;  divg LDA,
;  A ORA,
;  0<>, IF, ( vger disabled )
;   rDI D LXI,
;   divgct H LXI,
;   E M MOV,
;   H INX,
;   D M MOV, ( tell eivg that we hit )
;   INout JMP,
;  THEN,
; LABEL rDI
; -->
;
; { BLOCK 0189 }
;  h-f H LXI,
;  M A MOV,
;  A INR,
;  3 CPI,
;  CY~, IF,
;   A XRA,
;  THEN,
;  A M MOV,
;  A ANA,
;  PLYRV Y LXIX,
;  0=, IF,
;   PL-M CALL,
;  ELSE,
;   A DCR,
;   0=, IF,
;    3 A MVI,
;    HOTROD CALL,
;   THEN,
;  THEN,
;  SUI2-DI JMP,
; ASSEMBLE>
;
; MIS-INT does ?? MISsle INTerrupt test ?? routine
LB3C0:  PUSH    AF
        PUSH    BC
        PUSH    DE
        PUSH    HL
        EXX
        EX      AF,AF'
        PUSH    AF
        PUSH    BC
        PUSH    DE
        PUSH    HL
        PUSH    IY
        PUSH    IX
; REFRESH BACKGROUND COLOR
        LD      A,($EEE0)       ; BKC read ( BacKground Color ) Byte-Variable in Static RAM
        OUT     (COL0L),A       ; &(4)=?? for COLor 0 Left ( REFRESH BACKGROUND COLOR )
        LD      A,($FEF6)       ; SUI2L read Byte (always 50 ??) for ?? in Static RAM
        OUT     (INLIN),A       ; &(15)=?? ( set interrupt line ) number
        LD      A,$FE           ; SUI2V SWAB (SWAp Bytes)
        LD      I,A             ; ( load I reg )
        LD      A,$FA           ; SUI2V for INterrupt Vector at $FEFA in RAM ?? (Third)
        OUT     (INFBK),A       ; &(13)= ( load feedback port )
        LD      A,($FEF1)       ; SU1flag read Byte for ( inprogress ) in Static RAM
        CP      $01
        JR      NZ,LB3EC                ; (+$05) IF 1= False skip to OK ( no overrun )
        LD      A,$02           ; ( overrun )
        LD      ($FEF1),A       ; SU1flag write Byte 2 for ( inprogress ) in Static RAM
; OK ( no overrun ) !!
LB3EC:  LD      A,($FEEA)       ; divg read Byte ?? for ?? in Static RAM
        OR      A
        JR      Z,LB3FE                 ; (+$0c) IF 0<> False skip to rDI THEN #1
        LD      DE,LB3FE        ; rDI point to label "rDI THEN #1" in ROM if "vger disabled"
        LD      HL,$FEE8        ; divgct point to Word "eivg ct ??" for ?? in Static RAM
        LD      (HL),E
        INC     HL
        LD      (HL),D          ;  ( tell eivg that we hit vger disabled )
        JP      L147F           ; INout to restore environment, EI and RETurn

; rDI label THEN #1 if  ( vger NOT disabled )
LB3FE:  LD      HL,$E791        ; h-f point to ?? Byte-Variable in NV RAM
        LD      A,(HL)
        INC     A
        CP      $03
        JR      C,LB408                 ; (+$01) IF CY~ False skip
        XOR     A
LB408:  LD      (HL),A          ; h-f still 0 through 3 Byte-Variable up-counter ??
        AND     A
        LD      IY,$F12D        ; PLYRV point to "PLaYer Vector" base for IndexY in Static RAM
        JR      NZ,LB415                ; (+$05) IF 0= False to ELSE
        CALL    LAE26           ; PL-M do "PLayer Monitor" (Once every Three passes !!)
        JR      LB41D                   ; (+$08) to THEN #2

; ELSE ??
LB415:  DEC     A
        JR      NZ,LB41D                ; (+$05) IF 0= False skip to THEN #2
        LD      A,$03
        CALL    LB3A4           ; HOTROD do "process a HOT ROD missle"
LB41D:  JP      L14E4           ; THEN #2 to SUI2-DI up in Second Interrupt Routine ??
; emd of ( missle interrupt test ) !!

; !! nice TERSE FORTH code !!
;
; : MYPUP PUP MIS-INT SUI1V ! INVERT-OFF
; #PLA B@ IF plup B@ IF 13 INP 8 AND 0= IF
; INVERT-ON THEN THEN THEN ;
;
; MYPUP does ??
LB420:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L333D           ; PUP do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LB3C0           ; MIS-INT point to MISsle INTerrupt test ?? routine
        ;
        DW      L00BC           ; SUI1V "pushWORD to System stack"
        DW      $FEFC           ; for Word ?? (an Interrupt Vector !!) in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L1F34           ; INVERT-OFF do "clear COCKTAIL mode for UPRIGHTs"
        ;
        DW      L00BC           ; #PLA "pushWORD to System stack"
        DW      $E39A           ; for ( # of PLAyers-1 ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; IF False to THEN #1
        DW      L03CD,LB454     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; plup "pushWORD to System stack"
        DW      $E399           ; for ( PLayer-1 UP ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; _IF False to THEN #2
        DW      L03CD,LB454     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $13             ; for =&(19) aka OPTIONS SW3 read
        ;
        DW      L02E3           ; INP do "Pop BC, INPort L,(C) byte, Push 0,L word"
        ;
        DW      L04F9           ; 8 "BYTE Pusher" to MASK bit 3 CABINet = COCKTAIL
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; __IF False skip to THEN #3
        DW      L03CD,LB454     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L1F2D           ; INVERT-ON does "set COCKTAIL mode for P2 ONLY" !!
        ; THEN #1, THEN #2 and THEN #3
LB454:  DW      L00B0           ; ... TerseRETurn

; CODE SETCOL
;  A XRA,
;  7 OUT,
;  7E A MVI,
;  6 OUT,
;  52 A MVI,
;  5 OUT,
;  0FA A MVI,
;  4 OUT,
;  BKC STA,
;  0CC A MVI,
;  VERBL OUT,
;  -1 A MVI,
;  HORCB OUT,
; NEXT
; STK>
; -->
;
; SETCOL does "SET Left COLors and ?? then VERBL and HORCB"
LB456:  XOR     A
        OUT     (COL3L),A       ; &(7)=0 for BLACK COLor 3 Left and BORDER Color, too!
        LD      A,$7E
        OUT     (COL2L),A       ; &(6)=126 for YELLOW COLor 2 Left
        LD      A,$52
        OUT     (COL1L),A       ; &(5)=82 for RED COLor 1 Left
        LD      A,$FA
        OUT     (COL0L),A       ; &(4)=250 for BLUE COLor 0 Left background
        LD      ($EEE0),A       ; BKC write 250 into ( BacKground Color ) Byte-Variable in Static RAM
        LD      A,$CC
        OUT     (VERBL),A       ; &(10)=204 for VERtical Blanking Line
        LD      A,$FF
        OUT     (HORCB),A       ; &(9)=255 for HORCB at Far Right and Border Color = 3
        JP      (IY)            ; indexed RETurn
; end of { BLOCK 0189 } !!

; { BLOCK 0149 }
; ( SWAP BYTES BETWEEN DE AND HL )
; SUBR SWPO
;  D LDAX,
;  A C MOV,
;  M A MOV,
;  D STAX,
;  C M MOV,
;  RET,
;
; SWPO does "SWAP bytes (DE) and (HL)" routine
LB472:  LD      A,(DE)
        LD      C,A
        LD      A,(HL)
        LD      (DE),A
        LD      (HL),C
        RET

; TABLE HID-T
;  HOSV1 ,
;  XC? IFTRUE
;   HOSV2 , HOSV3 , TRSV ,
;  IFEND
;  KEY , 0 ,
; ( CHANGE THIS BUGGER WITH CARE !!!!! )
;
; HID-T 5-word table for SWAP ?? INFOrmation in non-protected Static RAM
LB478:  DW      $EFB1           ; HOSV1 for "HOStage Vector" #1 in Static RAM
        DW      $EF51           ; HOSV2 for "HOStage Vector" #2 in Static RAM
        DW      $EEF1           ; HOSV3 for "HOStage Vector" #3 in Static RAM
        DW      $F011           ; TRSV for "TReasure Vector" in Static RAM
        DW      $F06F           ; KEY for "KEY Vector" base in Static RAM
        DW      $0000           ; NULL end of list ( CHANGE THIS BUGGER WITH CARE !!!!! )

; F= Dmr
; SUBR SV-V
; <ASSEMBLE
;  0 HID-T H LXI,
;  H PUSH,
; LABEL Dmr
;  XCHG,
;  XTHL,
;  M E MOV,
;  H INX,
;  M D MOV,
;  H INX,
;  D A MOV,
;  E ORA,
;  0=, IF,
;   PSW POP,
;   RET,
;  THEN,
;  XTHL,
;  XCHG,
;  NOWR B LXI,
;  B DAD,
;  SWPO CALL,
;  H INX,
;  D INX,
;  SWPO CALL,
;  H INX,
;  D INX,
;  SWPO CALL,
;  D INX,
;  OBJSV NOWD - B LXI,
;  B DAD,
;  SWPO CALL,
;  D INX,
;  DISTANCE OBJSV - B LXI,
;  B DAD,
;  SWPO CALL,
;  D INX,
;  H INX,
;  SWPO CALL,
;  D INX,
;  Dmr JMPR,
; ASSEMBLE>
;
; SV-V does "SWAP ?? INFOrmation in 5 Locations" routine
LB484:  LD      HL,LB478        ; point to 5-word HID-T table
        PUSH    HL
LB488:  EX      DE,HL           ; Dmr label to repeat for EACH entry in table
        EX      (SP),HL         ; push DE instead ??  HL = HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        INC     HL
        LD      A,D             ; NULL terminated table
        OR      E
        JR      NZ,LB494                ; (+$02) IF 0= False to THEN
        POP     AF              ; so eat HL and exit
        RET

; THEN SWAP ?? INFOrmation in ONLY 1 Location
LB494:  EX      (SP),HL
        EX      DE,HL
        LD      BC,$003E        ; NOWR offset 62 for ( CURRENT Row )
        ADD     HL,BC
        CALL    LB472           ; SWPO does "SWAP bytes (DE) and (HL)"
        INC     HL
        INC     DE
        CALL    LB472           ; SWPO does "SWAP bytes (DE) and (HL)"
        INC     HL
        INC     DE
        CALL    LB472           ; SWPO does "SWAP bytes (DE) and (HL)"
        INC     DE
        LD      BC,$001D        ; OBJSV - NOWD (93 - 64) = 29 for ??
        ADD     HL,BC
        CALL    LB472           ; SWPO does "SWAP bytes (DE) and (HL)"
        INC     DE
        LD      BC,$FFED        ; DISTANCE - OBJSV (75 - 93) = -19 for ??
        ADD     HL,BC
        CALL    LB472           ; SWPO does "SWAP bytes (DE) and (HL)"
        INC     DE
        INC     HL
        CALL    LB472           ; SWPO does "SWAP bytes (DE) and (HL)"
        INC     DE
        JR      LB488                   ; (-$37) to Dmr for EACH entry in table

; CODE swv
;  D POP,
;  B PUSH,
;  SV-V CALL,
;  B POP,
; NEXT
;
; swv does "SWAP ?? INFOrmation in 5 Locations" routine
LB4BF:  POP     DE
        PUSH    BC
        CALL    LB484           ; SV-V does "SWAP ?? INFOrmation in 5 Locations"
        POP     BC
        JP      (IY)            ; indexed RETurn
; end of { BLOCK 0149 } !!

; SWV does "SWAP ?? INFOrmation in 5 Locations" from FORTH
LB4C7:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L8428           ; XVSA do ??
        ;
        DW      LB4BF           ; swv does "SWAP ?? INFOrmation in 5 Locations"
        ;
        DW      L00B0           ; ... TerseRETurn

; { BLOCK 0158 }
; ( SWAP NODE MATRIX WITH SAVE AREA )
; XC? IFTRUE
;  SUBR S-NM
;   0 NODEMAT H LXI,
;   0 NMZ D LXI,
;   NNODES DO,
;    B PUSH,
;    SWPO CALL,
;    H INX,
;    D INX,
;    SWPO CALL,
;    H INX,
;    D INX,
;    SWPO CALL,
;    H INX,
;    D INX,
;    SWPO CALL,
;    H INX,
;    D INX,
;    H INX,
;    H INX,
;    H INX,
;    H INX,
;    RVMD MPL0 - DO,
;     0 M MVI,
;     H INX,
;    LOOP, ( ZAP DIST AND DELTS )
;    4 DO,
;     SWPO CALL,
;     H INX,
;     D INX,
;    LOOP, ( SWAP RVMDS )
;    SWPO CALL,
;    H INX,
;    D INX, ( DRAWFLG )
;    0 M MVI,
;    H INX,
;    0 M MVI,
;    H INX, ( NAIL >TREASURE )
;    B POP,
;   LOOP,
;   RET,
;
; S-NM does "SWAP Player 1&2 INFOrmation" routine
; note: ( Swap Node Matrix with save area )
LB4D0:  LD      HL,$E792        ; NODEMAT point to "NODE MATrix" NM-S Byte Array in NV RAM
        LD      DE,$E53F        ; NMZ point to Word NMS sized Byte Array base in NV RAM
        LD      B,$42           ; NROWS * NCOLS (6 * 11) = NNODES for 66
; DO loop #1 for NNODES
LB4D8:  PUSH    BC
        CALL    LB472           ; SWPO does "SWAP bytes (DE) and (HL)"
        INC     HL
        INC     DE
        CALL    LB472           ; SWPO does "SWAP bytes (DE) and (HL)"
        INC     HL
        INC     DE
        CALL    LB472           ; SWPO does "SWAP bytes (DE) and (HL)"
        INC     HL
        INC     DE
        CALL    LB472           ; SWPO does "SWAP bytes (DE) and (HL)"
        INC     HL
        INC     DE
        INC     HL
        INC     HL
        INC     HL
        INC     HL
        LD      B,$0C           ; RVMD - MPL0 (20 - 8) for 12
; DO loop #2 to ( ZAP DIST AND DELTS )
LB4F3:  LD      (HL),$00
        INC     HL
        DJNZ    LB4F3                   ; (-$05) LOOP to DO #2 for 12
        LD      B,$04
; DO loop #3 to ( SWAP RVMDS )
LB4FA:  CALL    LB472           ; SWPO does "SWAP bytes (DE) and (HL)"
        INC     HL
        INC     DE
        DJNZ    LB4FA                   ; (-$07) LOOP to DO #3 for 4 then ANOTHER ??
        CALL    LB472           ; SWPO does "SWAP bytes (DE) and (HL)"
        INC     HL
        INC     DE              ; ( DRAWFLG )
        LD      (HL),$00
        INC     HL
        LD      (HL),$00
        INC     HL              ; ( NAIL >TREASURE ) constant 25 ??
        POP     BC
        DJNZ    LB4D8                   ; (-$37) LOOP to DO #1 for 66
        RET

;  CODE SWAPO
;   B PUSH,
;   S-NM CALL,
;   B POP,
;  NEXT
; IFEND
; -->
;
; SWAPO does "SWAP Player 1&2 INFOrmation" from TERSE
LB510:  PUSH    BC
        CALL    LB4D0           ; S-NM do "SWAP Player 1&2 INFOrmation"
        POP     BC
        JP      (IY)            ; indexed RETurn
; end of ( SWAP NODE MATRIX WITH SAVE AREA ) !!

; { BLOCK 0066 }
; ( CLEAR BLOCK COMMAND - USES THE PATTERN BOARD )
; HEX ( THIS VERSION CLEARS A 1K BLOCK )
; DATA p&
;  0 B,
;
; p& NULL BYTE to CLEAR Screen with
; note: ( THIS VERSION CLEARS A 1K BLOCK )
LB517:  NOP

; more of { BLOCK 0066 } !!
; SUBR c1k
;  20 A MVI,
;  07A OUT,
;  p& H LXI,
;  L A MOV,
;  078 OUT,
;  H A MOV,
;  079 OUT,
;  E A MOV,
;  7B OUT,
;  D A MOV,
;  7C OUT,
;  1 A MVI,
;  7B OUT,
;  7F A MVI,
;  7D OUT,
;  7 A MVI,
;  7E OUT,
;  RET,
;
; c1k does "Clear 1K of screen using pattern board" routine
LB518:  LD      A,$20
        OUT     (CMODE),A       ; $7A for &(122)=32 for Pattern Board Copy MODE
        LD      HL,LB517        ; p& point to "NULL BYTE to CLEAR Screen with"
        LD      A,L
        OUT     (SRCLO),A       ; $78 for &(120)=23 for Low Source Addres
        LD      A,H
        OUT     (SRCHI),A       ; $79 for &(121)=181 for High Source Address
        LD      A,E
        OUT     (SKIPLO),A      ; $7B for &(123)=?? for Low Destination Address
        LD      A,D
        OUT     (DESTHI),A      ; $7C for &(124)=?? for High Destination Address
        LD      A,$01
        OUT     (SKIPLO),A      ; $7B for &(123)=1 for number of bytes to Skip
        LD      A,$7F
        OUT     (LENGTH),A      ; $7D for &(125)=127 for Width in bytes of each row
        LD      A,$07
        OUT     (LOOPS),A       ; $7E for &(126)=7 for Height-1, also Starts Xfer
        RET

; last of { BLOCK 0066 } !!
; F= cll
; CODE CL
;  4000 D LXI,
; <ASSEMBLE
; LABEL cll
;  c1k CALL,
;  D A MOV,
;  4 ADI,
;  A D MOV,
;  cll JP,
; NEXT
; ASSEMBLE>
; DECIMAL
; -->
;
; CL does "CLear screen in 1K increments"
LB538:  LD      DE,$4000        ; NORMEM for first 8 Line block
LB53B:  CALL    LB518           ; c1k do "Clear 1K of screen using pattern board"
        LD      A,D
        ADD     A,$04           ; add 1024 each pass
        LD      D,A
        JP      P,LB53B         ; to cll until DE rolls over to $8000
        JP      (IY)            ; indexed RETurn

; { BLOCK 0067 }
; ( GROWL OUT ALREADY DUG FEATURES )
; HEX
; F= Nrp
; F= rpE
; F= Rpm
; CODE f&
; <ASSEMBLE
;  H POP,
;  L A MOV,
;  RPDIR STA, ( A= DIR )
;  H POP,
;  D POP,
;  L D MOV,
;  B PUSH,
;  X PUSHX,
;  Y PUSHX, ( GET MAX DIST IF IT EXISTS )
;  A C MOV,
;  noder^ CALL,
;  M A MOV,
;  2 CPI,
;  Nrp JC,
;  RPMD STA, ( YES - IS IT EQUAL TO MAX DISTANCE )
;
; btw BLOCK 0059 dies here !!
;
;  MPL0 RVMD - B LXI,
;  B DAD,
;  M CMP,
;  CY~, IF,
;   M A MOV,
;   RPMD STA,
;   A ANA,
;   B DSBC,
;   A M MOV,
;   B DAD, ( FIX RVMD TO MAX ! )
;  ( IF SO ONLY REPAINT IF MY DIRECTION IS 2 THRU 3 )
;   RPDIR LDA,
;   2 CPI,
;   Nrp JC,
;  THEN,
; -->
;
; { BLOCK 0068 }
; ( THEN SET DELTAS )
; LABEL rpE
;  10 IN,
;  NDX0 MPL0 - B LXI,
;  B DAD,
;  M A MOV,
;  RPDX STA,
;  SGNA CALL,
;  RPDX 1+ STA,
;  NDY0 NDX0 - B LXI,
;  B DAD,
;  M A MOV,
;  RPDY STA,
;  SGNA CALL,
;  RPDY 1+ STA, ( AND THEN COORDINATE VALUES )
;  NBX C MVI,
;  node^ CALL,
;  M E MOV,
;  H INX,
;  M D MOV,
;  H INX,
;  RPX SDED,
;  M E MOV,
;  H INX,
;  M D MOV,
;  RPY SDED, ( LASTLY DISTANCE COUNTER )
;  A XRA,
;  RPD STA,
; -->
;
; { BLOCK 0069 }
; ( FUDGE DELTA VALUES TO SAVE TIME )
;  RPDX LHLD,
;  H DAD,
;  H DAD,
;  RPDX SHLD,
;  RPDY LHLD,
;  H DAD,
;  H DAD,
;  RPDY SHLD,
; ( LOOP TO DO THE MAD PAINTING )
; LABEL Rpm
;  RPX LHLD,
;  RPDX LDED,
;  D DAD,
;  RPX SHLD,
;  XCHG,
;  RPY LHLD,
;  RPDY LBCD,
;  B DAD,
;  RPY SHLD,
;  RPCOL LBCD,
;  rv-p X LXIX,
;  SLEZR2A CALL,
;  X INXX,
;  X INXX,
;  0 X E LDX,
;  X INXX,
;  0 X D LDX,
;  X INXX,
;  write CALL,
;  RPMD LDA,
;  A C MOV,
;  RPD LDA,
;  8 ADI,
;  RPD STA,
;  C SUB,
;  Rpm JM,
;  8 CPI,
;  Nrp JRNC,
;  C A MOV,
;  RPD STA,
;  Rpm JMPR,
; LABEL Nrp
;  Y POPX,
;  X POPX,
;  B POP,
; NEXT
; ASSEMBLE>
; -->
;
; f& does "Determine location and CLEAR Tunnel SHAFTS in New Maze ONLY"
; note: ( GROWL OUT ALREADY DUG FEATURES )
LB547:  POP     HL
        LD      A,L             ; ( A= DIR )
        LD      ($EE8C),A       ; RPDIR write ( RePaint DIRection chosen ) Byte-Variable in Static RAM
        POP     HL
        POP     DE
        LD      D,L
        PUSH    BC
        PUSH    IX
        PUSH    IY              ; ( GET MAX DIST IF IT EXISTS )
        LD      C,A
        CALL    L8696           ; noder^ do ??
        LD      A,(HL)
        CP      $02             ; ( REJECT GRUNGY VALUES )
        JP      C,LB60C                 ; if ?? to Nrp "some environment restore, then exit"
; ( YES - IS IT EQUAL TO MAX DISTANCE )
        LD      ($EE8D),A       ; RPMD write "RePaint Max Distance" Byte-Variable in Static RAM
        LD      BC,$FFF4        ; MPL0 - RVMD (8 - 20) = -12 for ??
        ADD     HL,BC
        CP      (HL)
        JR      C,LB579                 ; (+$11) IF CY~ False to THEN (also rpE !!)
        LD      A,(HL)
        LD      ($EE8D),A       ; RPMD write "RePaint Max Distance" Byte-Variable in Static RAM
        AND     A
        SBC     HL,BC
        LD      (HL),A
        ADD     HL,BC           ; ( FIX RVMD TO MAX ! )
;  ( IF SO ONLY REPAINT IF MY DIRECTION IS 2 THRU 3 )
        LD      A,($EE8C)       ; RPDIR read ( RePaint DIRection chosen ) Byte-Variablein Static RAM
        CP      $02
        JP      C,LB60C                 ; if ?? to Nrp "some environment restore, then exit"
; rpE label ( THEN SET DELTAS ) entry point for DRAW Tunnel SHAFTS in New Maze ONLY
LB579:  IN      A,(SW0)         ; inport =&(16) Control Port
        LD      BC,$0004        ; NDX0 - MPL0 (12 - 8) = 4 for ??
        ADD     HL,BC
        LD      A,(HL)
        LD      ($EE93),A       ; RPDX write "RePaint Delta X" Variable in Static RAM
        CALL    L8811           ; SGNA do "first A SiGN"
        LD      ($EE94),A       ; RPDXH write "RePaint Delta X High" Variable in Static RAM
        LD      BC,$0004        ; NDY0 - NDX0 (16 - 12) = 4 for ??
        ADD     HL,BC
        LD      A,(HL)
        LD      ($EE8F),A       ; RPDY write "RePaint Delta Y" Variable in Static RAM
        CALL    L8811           ; SGNA do "first A SiGN"
        LD      ($EE90),A       ; RPDYH write "RePaint Delta Y High" Variable in Static RAM
; ( AND THEN COORDINATE VALUES )
        LD      C,$04           ; NBX constant 4
        CALL    L865E           ; node^ do "NODE Zammer ( D= ROW E= COL C= DISP, OUT HL= ^ )"
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        INC     HL
; ( LASTLY DISTANCE COUNTER )
        LD      ($EE95),DE      ; RPX write "RePaint X" Variable in Static RAM
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        LD      ($EE91),DE      ; RPY write "RePaint Y" Variable in Static RAM
        XOR     A
        LD      ($EE8E),A       ; RPD write "RePaint Distance" Byte-Variable in Static RAM
; ( FUDGE DELTA VALUES TO SAVE TIME )
        LD      HL,($EE93)      ; RPDX read "RePaint Delta X" Variable in Static RAM
        ADD     HL,HL           ; times 4
        ADD     HL,HL
        LD      ($EE93),HL      ; RPDX write "RePaint Delta X" Variable in Static RAM
        LD      HL,($EE8F)      ; RPDY read "RePaint Delta Y" Variable in Static RAM
        ADD     HL,HL           ; times 4
        ADD     HL,HL
        LD      ($EE8F),HL      ; RPDY write "RePaint Delta Y" Variable in Static RAM
; Rpm label ( LOOP TO DO THE MAD PAINTING )
LB5BF:  LD      HL,($EE95)      ; RPX read "RePaint X" Variable in Static RAM
        LD      DE,($EE93)      ; RPDX read "RePaint Delta X" Variable in Static RAM
        ADD     HL,DE
        LD      ($EE95),HL      ; RPX write "RePaint X" Variable in Static RAM
        EX      DE,HL
        LD      HL,($EE91)      ; RPY read "RePaint Y" Variable in Static RAM
        LD      BC,($EE8F)      ; RPDY read "RePaint Delta Y" Variable in Static RAM
        ADD     HL,BC
        LD      ($EE91),HL      ; RPY write "RePaint Y" Variable in Static RAM
        LD      BC,($EE8A)      ; RPCOL read ( RePaint COLur ) Variable
        LD      IX,L8214        ; rv-p point to Monochrome CIRCLE pattern
        CALL    L8AD9           ; SLEZR2A do "SCALE DOWN Full-Scale X and Y locations to ABSolute"
        INC     IX
        INC     IX
        LD      E,(IX+$00)      ; read 3 Monochrome CIRCLE Width in Bytes
        INC     IX
        LD      D,(IX+$00)      ; read 16 Monochrome CIRCLE Height in Rows
        INC     IX
        CALL    L125B           ; write (routine) does "Pattern Board to COPY CIRCLE to Screen"
        LD      A,($EE8D)       ; RPMD read "RePaint Max Distance" Byte-Variable in Static RAM
        LD      C,A
        LD      A,($EE8E)       ; RPD read "RePaint Distance" Byte-Variable in Static RAM
        ADD     A,$08
        LD      ($EE8E),A       ; RPD write "RePaint Distance" Byte-Variable in Static RAM
        SUB     C
        JP      M,LB5BF         ; if ?? to Rpm loop
        CP      $08
        JR      NC,LB60C                ; (+$06) if ?? to Nrp "some environment restore, then exit"
        LD      A,C
        LD      ($EE8E),A       ; RPD write "RePaint Distance" Byte-Variable in Static RAM
        JR      LB5BF                   ; (-$4d) to Rpm loop

; Nrp label does "some environment restore, then exit"
LB60C:  POP     IY
        POP     IX
        POP     BC
        JP      (IY)            ; indexed RETurn
; end of { GROWL OUT ALREADY DUG FEATURES } !!

; { BLOCK 0080 }
; ( GROWL ALL EXISTING PATHS )
; HEX
; CODE RP&
;  H POP,
;  L A MOV, ( A= DIR )
;  H POP,
;  D POP,
;  L D MOV,
;  B PUSH,
;  X PUSHX,
;  Y PUSHX, ( REJECT GRUNGY VALUES )
;  2 CPI,
;  Nrp JC, ( GET MAX DIST IF IT EXISTS )
;  A C MOV,
;  noded^ CALL,
;  M A MOV,
;  A ANA,
;  Nrp JZ,
;  RPMD STA,
;  rpE JMP,
; NEXT
; -->
;
; RP& does "Determine location and DRAW Tunnel SHAFTS in New Maze ONLY"
; note: ( GROWL ALL EXISTING PATHS )
LB613:  POP     HL
        LD      A,L             ; ( A= DIR )
        POP     HL
        POP     DE
        LD      D,L
        PUSH    BC
        PUSH    IX
        PUSH    IY
        CP      $02             ; ( REJECT GRUNGY VALUES ) again
        JP      C,LB60C                 ; if ?? to Nrp "some environment restore, then exit"
; ( GET MAX DIST IF IT EXISTS )
        LD      C,A
        CALL    L868C           ; noded^ do ??
        LD      A,(HL)
        AND     A
        JP      Z,LB60C                 ; if ?? to Nrp "some environment restore, then exit"
        LD      ($EE8D),A       ; RPMD read "RePaint Max Distance" Byte-Variable in Static RAM
        JP      LB579           ; to rpE entry point

; LB631: not used, would do just exit ??
        JP      (IY)            ; indexed RETurn
; end of { GROWL ALL EXISTING PATHS } !!

; { BLOCK 0165 }
; HEX ( GROWL RETURN )
; XC? IFTRUE
;  CODE K
;   0C X L LDX,
;   0D X H LDX,
;   H PUSH,
;  NEXT
; IFEND
;
; K ?? does "GROWL RETURN" !! NOT "Push Second Previous TERSE Loop COUNTer onto System Stack"
LB633:  LD      L,(IX+$0C)      ; TSCALE offset 12
        LD      H,(IX+$0D)      ; TTBMAX offset 13
        PUSH    HL
        JP      (IY)            ; indexed RETurn

; : G&D NCOLS 0 DO NROWS 0 DO
;  J I G-D? IF
;  J I NODX NODE@ J I NODY NODE@
;  RPCOL @ gr-p WRITEP THEN
;  J I EXIST? IF 2DROP
;  4 0 DO K J I f&
;  LOOP THEN LOOP LOOP ST-X ST-Y RPCOL @ SHFP WRITEP
;  DOR0 DORWR ; ( DRAW CLOSED DOOR )
; DECIMAL
;
; G&D does "CLEAR all TUNNELS"
LB63C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; NCOLS "pushBYTE to System stack"
        DB      $0B             ; constant 11 for "Number of COLumnS"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; TerseDO Loop #1 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L00C5           ; NROWS "pushBYTE to System stack"
        DB      $06             ; constant 6 for "Number of ROWS"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; _TerseDO Loop #2 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L86AE           ; G-D? do "test Grotto Drawn"
        ; __IF False skip to THEN #1
        DW      L03CD,LB673     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; NODX "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L86F4           ; NODE@ do ??
        ;
        DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; NODY "pushBYTE to System stack"
        DB      $02             ; constant 2 for ??
        ;
        DW      L86F4           ; NODE@ do ??
        ;
        DW      L00BC           ; RPCOL "pushWORD to System stack"
        DW      $EE8A           ; for ( RePaint COLur ) Variable in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; gr-p "pushWORD to System stack"
        DW      L81C7           ; unknown color ?? Monochrome RBOX pattern
        ;
        DW      L8B40           ; WRITEP do "Determine location and CLEAR TUNNELS"
        ; __THEN #1
LB673:  DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L9383           ; EXIST? do ??
        ; __IF False to THEN #2
        DW      L03CD,LB68F     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L02FE           ; 2DROP do "Pop HL, Pop HL" to clean up System Stack
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; ___TerseDO Loop #3 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      LB633           ; K ?? do "GROWL RETURN"
        ;
        DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      LB547           ; f& do "Determine location and CLEAR Tunnel SHAFTS"
        ; ___TerseLOOP #3 back to TerseDO #3 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; __THEN #2 and TerseLOOP #2 back to TerseDO #2 (until INCrement COUNTer reaches to END value)
LB68F:  DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; TerseLOOP #1 back to TerseDO #1 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00C5           ; ST-X "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L00C5           ; ST-Y "pushBYTE to System stack"
        DB      $34             ; constant 52 for ??
        ;
        DW      L00BC           ; RPCOL "pushWORD to System stack"
        DW      $EE8A           ; for ( RePaint COLur ) Variable in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L8248           ; unknown color ?? Monochrome ENTRY/EXIT HOLE pattern
        ;
        DW      L8B40           ; WRITEP do "Determine location and COPY HOLE in ENTRY"
        ; ( DRAW CLOSED DOOR )
        DW      L00BC           ; DOR0 "pushWORD to System stack"
        DW      L827C           ; for unknown color Monochrome "DOOR closed" pattern
        ;
        DW      L9E34           ; DORWR do "DOoR WRiter"
        ;
        DW      L00B0           ; ... TerseRETurn

; XC? IFTRUE
;  : INTSCR SCV P1s #PLA B@ IF SFXV P2s THEN ;
; OTHERWISE : INTSCR ;
; IFEND -->
;
; INTSCR does "INITialize SCoRe"
LB6AD:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; SCV "pushWORD to System stack"
        DW      $F285           ; for "?? Vector" base in Static RAM
        ;
        DW      L8B6C           ; P1s do "task to display Player ONEs Score"
        ;
        DW      L00BC           ; #PLA "pushWORD to System stack"
        DW      $E39A           ; for ( # of PLAyers-1 ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; IF False skip to THEN
        DW      L03CD,LB6C4     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; SFXV "pushWORD to System stack"
        DW      $F227           ; for "?? Vector" base in Static RAM
        ;
        DW      L8BC2           ; P2s do "task to display Player TWOs Score"
        ; THEN
LB6C4:  DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0165 } !!

; { BLOCK 0061 }
; HEX ( GROWL EXISTING PATHS )
; : G&E NCOLS 0 DO NROWS 0 DO
;  J I EXIST? IF
;  NODX NODE@ J I NODY NODE@
;  RPCOL @ gr-p WRITEP
;  4 0 DO K J I RP&
;  LOOP THEN LOOP LOOP ;
; DECIMAL
; -->
;
; G&E does "DRAW all TUNNELS"
; note: ( GROWL EXISTING PATHS )
LB6C6:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; NCOLS "pushBYTE to System stack"
        DB      $0B             ; constant 11 for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; TerseDO Loop #1 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L00C5           ; NROWS "pushBYTE to System stack"
        DB      $06             ; constant 6 for "Number of ROWS"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; _TerseDO Loop #2 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L9383           ; EXIST? do ??
        ; __IF False to THEN
        DW      L03CD,LB709     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; NODX "pushBYTE to System stack"
        DB      $00             ; constant 0 for ??
        ;
        DW      L86F4           ; NODE@ do ??
        ;
        DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; NODY "pushBYTE to System stack"
        DB      $02             ; constant 2 for ??
        ;
        DW      L86F4           ; NODE@ do ??
        ;
        DW      L00BC           ; RPCOL "pushWORD to System stack"
        DW      $EE8A           ; for ( RePaint COLur ) Variable in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; gr-p "pushWORD to System stack"
        DW      L81C7           ; unknown color ?? Monochrome RBOX pattern
        ;
        DW      L8B40           ; WRITEP do "Determine location and DRAW TUNNELS"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; ___TerseDO Loop #3 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      LB633           ; K ?? do "GROWL RETURN"
        ;
        DW      L02A0           ; J do "Push Previous TERSE Loop COUNTer onto System Stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      LB613           ; RP& do "Determine location and DRAW Tunnel SHAFTS"
        ; __TerseLOOP #3 back to TerseDO #3 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; _THEN and TerseLOOP #2 back to TerseDO #2 (until INCrement COUNTer reaches to END value)
LB709:  DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; TerseLOOP #1 back to TerseDO #1 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? not included_ ?? past a --> !!
;
; ( GROWL OUT WALLS ROUTINE )
; : G&W NCOLS 0 DO NROWS 0 DO
;  J I G-D? IF J I EXIST? IF WALDO THEN THEN
;  LOOP LOOP ;
; -->
;
; end of { BLOCK 0061 } !!

; { BLOCK 0118 }
; ( ANOTHER SPARSE TRASH GENERATOR )
; HEX
; CODE Sst
;  B PUSH,
;  INVERT LDA,
;  A ANA,
;  0=, IF,
;   8C0 D LXI,
;  ELSE,
;   0 D LXI,
;  THEN,
;  3700 B LXI,
;  D H MOV,
;  E L MOV,
;  6 D SET, ( DE= NON, HL=MAGIC )
;  BEGIN,
;   10 IN,
;   D LDAX,
;   A ANA,
;   0=, IF,
;    M A MOV,
;    3 ANI,
;    MAGIC OUT,
;    33 M MVI,
;   ELSE,
;    A XRA,
;    D STAX,
;   THEN,
;   H INX,
;   D INX,
;   B DCX,
;   B A MOV,
;   C ORA,
;  0=, END,
;  B POP,
; NEXT
;
; start of ( NIFTY NEATO SCREEN GENERATORS ) !!
; Sst does "DRAW Blue DIRT from System ROM" routine #1
; note: ( ANOTHER SPARSE TRASH GENERATOR ) out of order !!
LB70F:  PUSH    BC
        LD      A,($FEFF)       ; read COCKTAIL mode (bit 0 = 1 for draw FLIPped !!)
        AND     A
        JR      NZ,LB71B                ; (+$05) IF 0= False to ELSE #1
        LD      DE,$08C0        ; 2240 for 28 Lines NOT to FILL
        JR      LB71E                   ; (+$03) to THEN #!

; ELSE #1 ??
LB71B:  LD      DE,$0000        ; 0 for Top of Screen
; THEN #1 ??
LB71E:  LD      BC,$3700        ; 14080 for 176 Lines to FILL
        LD      H,D             ; System ROM and/or Magic RAM locations
        LD      L,E
        SET     6,D             ; make Screen RAM locations
; BEGIN loop ( DE= NON, HL=MAGIC )
LB725:  IN      A,(SW0)         ; inport =&(16) Control Port
        LD      A,(DE)
        AND     A               ; is Screen BYTE empty ?
        JR      NZ,LB734                ; (+$09) IF 0= False to ELSE #2 if not
        LD      A,(HL)          ; read System ROM Byte (includes System FONT !!)
        AND     $03             ; mask with 00000011B
        OUT     (MAGIC),A       ; &(12)= 0 thru 3 for SHIFT Only
        LD      (HL),$33        ; write 00110011B PIXELs Shifted 0-3
        JR      LB736                   ; (+$02) to THEN #2

; ELSE #2
LB734:  XOR     A               ; clear it to Blue !!
        LD      (DE),A
LB736:  INC     HL              ; THEN #2
        INC     DE
        DEC     BC
        LD      A,B
        OR      C
        JR      NZ,LB725                ; (-$18) END if 0= False else to BEGIN
        POP     BC
        JP      (IY)            ; indexed RETurn

; : Gst C18 RPCOL ! G&E Sst G&D ; ( 028 WALCO ! G&W )
; DECIMAL
; -->
;
; Gst does "DRAW and CLEAR all TUNNELS with Blue DIRT from System ROM" #1
LB740:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0C18           ; 3096 for ??
        ;
        DW      L00BC           ; RPCOL "pushWORD to System stack"
        DW      $EE8A           ; for ( RePaint COLur ) Variable in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      LB6C6           ; G&E do "DRAW all TUNNELS"
        ;
        DW      LB70F           ; Sst do "DRAW Blue DIRT from System ROM" #1
        ;
        DW      LB63C           ; G&D do "CLEAR all TUNNELS"
        ;
        DW      L00B0           ; ... TerseRETurn

; { BLOCK 0124 }
; ( HARD TRASH GENERATOR )
; HEX
; CODE Sht
;  B PUSH,
;  INVERT LDA,
;  A ANA,
;  0=, IF,
;   8C0 D LXI,
;  ELSE,
;   0 D LXI,
;  THEN,
;  3700 B LXI,
;  D H MOV,
;  E L MOV,
;  6 D SET,
;  XCHG, ( DE= MAGIC HL= NON )
;  18 A MVI,
;  MAGIC OUT,
;  0C A MVI,
;  XPAND OUT,
;  BEGIN,
;   10 IN,
;   D LDAX,
;   D STAX,
;   M A MOV,
;   CMA,
;   A M MOV,
;   H INX,
;   D INX,
;   B DCX,
;   B A MOV,
;   C ORA,
;   0=, END,
;  B POP,
; NEXT
;
; Sht does "DRAW Blue DIRT from System ROM" routine #2
; note: ( HARD TRASH GENERATOR )
LB753:  PUSH    BC
        LD      A,($FEFF)       ; read COCKTAIL mode (bit 0 = 1 for draw FLIPped !!)
        AND     A
        JR      NZ,LB75F                ; (+$05) IF 0= False to ELSE
        LD      DE,$08C0        ; 2240 for 28 Lines NOT to FILL
        JR      LB762                   ; (+$03) to THEN

; ELSE ??
LB75F:  LD      DE,$0000        ; 0 for Top of Screen
; THEN ??
LB762:  LD      BC,$3700        ; 14080 for 176 Lines to FILL
        LD      H,D             ; System ROM and/or Magic RAM locations
        LD      L,E
        SET     6,D             ; make Screen RAM locations
        EX      DE,HL           ; ( DE= MAGIC, HL= NON )
        LD      A,$18           ; 00011000B
        OUT     (MAGIC),A       ; &(12)=24 for OR and eXPaND
        LD      A,$0C
        OUT     (XPAND),A       ; &(25)=12 for Color 3 on Color 0
; BEGIN loop
LB772:  IN      A,(SW0)         ; inport =&(16) Control Port
        LD      A,(DE)          ; read System ROM
        LD      (DE),A          ; MAGIC Write eXPANDed
        LD      A,(HL)
        CPL
        LD      (HL),A          ; invert resulting Byte
        INC     HL
        INC     DE
        DEC     BC
        LD      A,B
        OR      C
        JR      NZ,LB772                ; (-$0e) END if 0= False else to BEGIN
        POP     BC
        JP      (IY)            ; indexed RETurn

; : Ght C18 RPCOL ! G&E Sht G&D ( 028 WALCO ! G&W ) ;
; DECIMAL
; -->
;
; Ght does "DRAW and CLEAR all TUNNELS with Blue DIRT from System ROM" #2
LB783:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0C18           ; 3096 for ??
        ;
        DW      L00BC           ; RPCOL "pushWORD to System stack"
        DW      $EE8A           ; for ( RePaint COLur ) Variable in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      LB6C6           ; G&E do "DRAW all TUNNELS"
        ;
        DW      LB753           ; Sht does "DRAW Blue DIRT from System ROM" #2
        ;
        DW      LB63C           ; G&D do "CLEAR all TUNNELS"
        ;
        DW      L00B0           ; ... TerseRETurn

; { BLOCK 0062 }
; ( SPARSE TRASH ON PATH BACKGROUND GENERATOR )
; HEX ( NIFTY NEATO SCREEN GENERATORS )
; CODE Sn
;  B PUSH,
;  INVERT LDA,
;  A ANA,
;  0=, IF,
;   8C0 D LXI,
;  ELSE,
;   0 D LXI,
;  THEN,
;  3700 B LXI,
;  D H MOV,
;  E L MOV,
;  6 D SET, ( DE= NON, HL=MAGIC )
;  BEGIN,
;   D LDAX,
;   A ANA,
;   0=, IF,
;    M A MOV,
;    3 ANI,
;    MAGIC OUT,
;    3 M MVI,
;   ELSE,
;    A XRA,
;    D STAX,
;   THEN,
;   H INX,
;   D INX,
;   B DCX,
;   B A MOV,
;   C ORA,
;  0=, END,
;  B POP,
; NEXT
;
; Sn does "DRAW Blue DIRT from System ROM" routine #3
; note: ( SPARSE TRASH ON PATH BACKGROUND GENERATOR )
LB796:  PUSH    BC
        LD      A,($FEFF)       ; read COCKTAIL mode (bit 0 = 1 for draw FLIPped !!)
        AND     A
        JR      NZ,LB7A2                ; (+$05) IF 0= False to ELSE #1
        LD      DE,$08C0        ; 2240 for 28 Lines NOT to FILL
        JR      LB7A5                   ; (+$03) to THEN #1

; ELSE #1 ??
LB7A2:  LD      DE,$0000        ; 0 for Top of Screen
; THEN #1 ??
LB7A5:  LD      BC,$3700        ; 14080 for 176 Lines to FILL
        LD      H,D             ; System ROM and/or Magic RAM locations
        LD      L,E
        SET     6,D             ; make Screen RAM locations
; BEGIN loop DE= NON, HL=MAGIC
LB7AC:  LD      A,(DE)
        AND     A               ; is Screen BYTE empty ?
        JR      NZ,LB7B9                ; (+$09) IF 0= False to ELSE #2 if not
        LD      A,(HL)          ; read System ROM Byte (includes System FONT !!)
        AND     $03             ; mask with 00000111B
        OUT     (MAGIC),A       ; &(12)= 0 thru 3 for SHIFT Only
        LD      (HL),$03        ; write 00000011B PIXELs Shifted 0-3
        JR      LB7BB                   ; (+$02) to THEN #2

LB7B9:  XOR     A               ; ELSE #2 clear it to Blue !!
        LD      (DE),A          ; THEN #2
LB7BB:  INC     HL
        INC     DE
        DEC     BC
        LD      A,B
        OR      C
        JR      NZ,LB7AC                ; (-$16) END if 0= False else to BEGIN
        POP     BC
        JP      (IY)            ; indexed RETurn

; : Gn C18 RPCOL ! G&E Sn G&D ;
; DECIMAL
; -->
;
; Gn does "DRAW and CLEAR all TUNNELS with Blue DIRT from System ROM" #3
LB7C5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0C18           ; 3096 for ??
        ;
        DW      L00BC           ; RPCOL "pushWORD to System stack"
        DW      $EE8A           ; for ( RePaint COLur ) Variable in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      LB6C6           ; G&E do "DRAW all TUNNELS"
        ;
        DW      LB796           ; Sn does "DRAW Blue DIRT from System ROM" #3
        ;
        DW      LB63C           ; G&D do "CLEAR all TUNNELS"
        ;
        DW      L00B0           ; ... TerseRETurn

; { BLOCK 0242 }
; ( VERY SPARSE GROWL ROUTINE )
; HEX ( NIFTY NEATO SCREEN GENERATORS )
; CODE So
;  D POP,
;  B PUSH,
;  INVERT LDA,
;  A ANA,
;  0=, IF,
;   48C0 H LXI,
;  ELSE,
;   4000 H LXI,
;  THEN,
;  3700 B LXI,
;  BEGIN,
;   10 IN,
;   6 H SET,
;   M A MOV,
;   A ANA,
;   0=, IF,
;    6 H RES,
;    M A MOV,
;    3 ANI,
;    MAGIC OUT,
;    M A MOV,
;    E ANA,
;    D CMP,
;    0=, IF,
;     0C0 M MVI,
;    ELSE,
;     6 H SET,
;     0 M MVI,
;    THEN,
;   ELSE,
;    6 H SET,
;    0 M MVI,
;   THEN,
;   H INX,
;   B DCX,
;   B A MOV,
;   C ORA,
;  0=, END,
;  B POP,
; NEXT
;
; So does "DRAW Blue DIRT from System ROM" routine #4
LB7D8:  POP     DE
        PUSH    BC
        LD      A,($FEFF)       ; read COCKTAIL mode (bit 0 = 1 for draw FLIPped !!)
        AND     A
        JR      NZ,LB7E5                ; (+$05) IF 0= False to ELSE #1
        LD      HL,$48C0        ; NORMEM + 2240 for 28 Lines NOT to FILL
        JR      LB7E8                   ; (+$03) to THEN #1

; ELSE #1 ??
LB7E5:  LD      HL,$4000        ; NORMEM for Top of Screen
; THEN #1 ??
LB7E8:  LD      BC,$3700        ; 14080 for 176 Lines to FILL
; BEGIN loop
LB7EB:  IN      A,(SW0)         ; inport =&(16) Control Port
        SET     6,H             ; make Screen RAM locations
        LD      A,(HL)
        AND     A               ; is Screen BYTE empty ?
        JR      NZ,LB809                ; (+$16) IF 0= False to ELSE #2 if not
        RES     6,H             ; make MAGIC RAM locations
        LD      A,(HL)          ; System ROM and/or Magic RAM locations
        AND     $03             ; mask with 00000111B
        OUT     (MAGIC),A       ; &(12)= 0 thru 3 for SHIFT Only
        LD      A,(HL)
        AND     E
        CP      D               ; is ??
        JR      NZ,LB803                ; (+$04) IF 0= False to ELSE #3 if not
        LD      (HL),$C0        ; write 11000000B PIXELs Shifted 0-3
        JR      LB807                   ; (+$04) to THEN #3

LB803:  SET     6,H             ; ELSE #3 clear it to Blue !!
        LD      (HL),$00
; THEN #3
LB807:  JR      LB80D                   ; (+$04) to THEN #2

LB809:  SET     6,H             ; ELSE #2 clear it to Blue !!
        LD      (HL),$00
LB80D:  INC     HL              ; THEN #2
        DEC     BC
        LD      A,B
        OR      C
        JR      NZ,LB7EB                ; (-$28) if 0= False END else to BEGIN
        POP     BC
        JP      (IY)            ; indexed RETurn

; TABLE GoTB
;  003C , 101C , 103C ,
;
; GoTB 3-word table ??  (NOT bytes, but definately NOT addresses !!)
LB816:  DW      $003C
        DW      $101C
        DW      $103C

; : Go C18 RPCOL ! G&E GA# B@ 3 - 2 MIN GoTB @ So G&D ;
;
; Go does "DRAW and CLEAR all TUNNELS with Blue DIRT from System ROM" #4
LB81C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0C18           ; 3096 for ??
        ;
        DW      L00BC           ; RPCOL "pushWORD to System stack"
        DW      $EE8A           ; for ( RePaint COLur ) Variable in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      LB6C6           ; G&E do "DRAW all TUNNELS"
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L00D8           ; do "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      LB816           ; 3-word table base GoTB ?? (NOT addresses !!)
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      LB7D8           ; So do "DRAW Blue DIRT from System ROM" #4
        ;
        DW      LB63C           ; G&D do "CLEAR all TUNNELS"
        ;
        DW      L00B0           ; ... TerseRETurn

; : nul C18 RPCOL ! G&D ;
; DECIMAL
; -->
;
; nul does "?? then JUST CLEAR all TUNNELS" #5
LB841:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0C18           ; 3096 for ??
        ;
        DW      L00BC           ; RPCOL "pushWORD to System stack"
        DW      $EE8A           ; for ( RePaint COLur ) Variable in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      LB63C           ; G&D do "CLEAR all TUNNELS"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of ( NIFTY NEATO SCREEN GENERATORS ) !!

; { BLOCK 0060 }
; HEX ( GROWL OUT PLAYER 2 TREASURES, ROTOS, AND MAGICS )
; XC? IFTRUE : P2gr P2FL
;  Tgr2 ( GROWL OUT PLAYER 2 TREASURES )
;  1 ma# B@ 4 MIN -DUP IF 0 DO I MPT2 MAGw LOOP THEN
;  1 rr# B@ 4 MIN -DUP IF 0 DO I RPT2 20 RTw LOOP THEN ;
; OTHERWISE : P2gr ; IFEND
; DECIMAL
; -->
;
; P2gr does "GRowl out Player 2 treasures, rotos, and magics"
; note: ( GROWL OUT PLAYER 2 TREASURES, ROTOS, AND MAGICS )
LB850:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LAAEA           ; P2FL do ??
        ;
        DW      L9833           ; Tgr2 does "GRowl out Player 2 Treasures"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00CD           ; ma# "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E38A           ; for ( MAgics left ) 2-Byte Array base in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L0217           ; -DUP do "DUPlicate Top of System stack IF Not Zero"
        ; IF False to THEN #1
        DW      L03CD,LB873     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; _TerseDO Loop #1 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      LAAA8           ; MPT2 do ??
        ;
        DW      LAABA           ; MAGw do ??
        ; _TerseLOOP #1 back to TerseDO #1 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; THEN #1
LB873:  DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00CD           ; rr# "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E388           ; for ( Robby Rotos left ) base in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L0217           ; -DUP do "DUPlicate Top of System stack IF Not Zero"
        ; IF False to THEN #2
        DW      L03CD,LB894     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; _TerseDO Loop #2 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L8D6D           ; RPT2 do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L8D46           ; RTw do "display Remaining LIVES, and Terminate"
        ; _TerseLOOP #2 back to TerseDO #2 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; THEN #2
LB894:  DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0060 } !!

; { BLOCK 0307 }
; ( BACKGROUND DRAWER )
; TABLE TRST ' Ght , ' Gst , ' Gn , ' Go , ' Go , ' Go , ' nul ,
; HEX DATA
;  CKB 0 B,
;
; TRST select WHICH of "DRAW and CLEAR all TUNNELS" routines to use table
LB896:  DW      LB783           ; index 0 for Ght do "TUNNELS" #2
        DW      LB740           ; index 1 for Gst do "TUNNELS" #1
        DW      LB7C5           ; index 2 for Gn do "TUNNELS" #3
        DW      LB81C           ; index 3 for Go do "TUNNELS" #4
        DW      LB81C           ; index 4 for Go do "TUNNELS" #4 again
        DW      LB81C           ; index 5 for Go do "TUNNELS" #4 again again
        DW      LB841           ; index 6 for nul do "?? then CLEAR TUNNELS" #5

        DB      $33             ; CKB spare Byte ?? not NULL ??

; : M-BG CL -1 INVERT B@ IF 7700 ELSE 4000 THEN 8C0 FILL
;  SETCOL ( SET COLORS ) GA# B@ 6 MIN TRST @ EXX
;  Tgr1 ( GROWL OUT PLAYER 1 TREASURES )
;  FREDH B@ -DUP IF 0 DO I H-DIS LOOP THEN
;  0 ma# B@ 4 MIN -DUP IF 0 DO I MPT1 MAGw LOOP THEN
;  0 rr# B@ 4 MIN -DUP IF 0 DO I RPT1 60 RTw LOOP THEN
;  P1FL
;  #PLA B@ IF P2gr THEN ;
; DECIMAL
; -->
;
; M-BG does "Make Background"
; note: "GRowl out Player 1 treasures, rotos, and magics" then P2gr if needed !!
LB8A5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LB538           ; CL do "CLear screen in 1K increments"
        ;
        DW      L0529           ; -1 (hex $FFFF) "WORD Pusher"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEFF           ; COCKTAIL mode (bit 0 = 1 for P2 FLIPped !!)
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; IF False to ELSE #1
        DW      L03CD,LB8BC     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $7700           ; 30464 for ?? in SCREEN RAM ??
        ; (done so Jump to THEN #1)
        DW      L03C5,LB8C0     ; TerseJUMP to ??
        ; ELSE #1
LB8BC:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $4000           ; NORMEM in SCREEN RAM !!
        ; THEN #1
LB8C0:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $08C0           ; 2240 for ?? (28 * BPLINE)
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ; ( SET COLORS )
        DW      LB456           ; SETCOL does "SET Left COLors and ?? then VERBL and HORCB"
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L00D8           ; do "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      LB896           ; TRST to select WHICH "DRAW all TUNNELS" routines to use table
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      LA071           ; EXX do "NULL routine"
        ; ( GROWL OUT PLAYER 1 TREASURES ) only !!
        DW      L9814           ; Tgr1 do "GRowl out Player 1 Treasures"
        ;
        DW      L843D           ; FREDH do "get FREeD Hostage counter"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0217           ; -DUP do "DUPlicate Top of System stack IF Not Zero"
        ; IF False to THEN #2
        DW      L03CD,LB8EE     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; _TerseDO Loop #1 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L9C91           ; H-DIS do "Hostage DISplay"
        ; _TerseLOOP #1 back to TerseDO #1 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; THEN #2
LB8EE:  DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; ma# "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E38A           ; for ( MAgics left ) 2-Byte Array base in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L0217           ; -DUP do "DUPlicate Top of System stack IF Not Zero"
        ; IF False to THEN #3
        DW      L03CD,LB90C     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; _TerseDO Loop #2 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      LAA95           ; MPT1 do ??
        ;
        DW      LAABA           ; MAGw do ??
        ; _TerseLOOP #2 back to TerseDO #2 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; THEN #3
LB90C:  DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; rr# "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E388           ; for ( Robby Rotos left ) base in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L0217           ; -DUP do "DUPlicate Top of System stack IF Not Zero"
        ; IF False to THEN #4
        DW      L03CD,LB92D     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; _TerseDO Loop #3 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L8D5C           ; RPT1 do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $60             ; 96 for ??
        ;
        DW      L8D46           ; RTw do "display Remaining LIVES, and Terminate"
        ; _TerseLOOP #3 back to TerseDO #3 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; THEN #4
LB92D:  DW      LAAD7           ; P1FL do "draw PLAYER 1 box on the Screen"
        ;
        DW      L00BC           ; #PLA "pushWORD to System stack"
        DW      $E39A           ; for ( # of PLAyers-1 ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; IF False to THEN #5
        DW      L03CD,LB93B     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LB850           ; P2gr do "GRowl out Player 2 treasures, rotos, and magics"
        ; THEN #5
LB93B:  DW      L00B0           ; ... TerseRETurn
; end of ( BACKGROUND DRAWER ) !!

; { BLOCK 0196 }
; ( LINK TO BONUS, CARTOON, AND DISPLAY PLAYER UP )
; XC? IFTRUE
;  HEX 3FFE C= CT^ 3FFC C= BN^ DECIMAL
;  : PATR BN^ @ -1 <> IF ( MAKE SURE THIS CRUD DEFINED )
;  GA# B@ 1+ NERDUP MH# B@
;  TR# B@ BN^ @ EXX DIVG
; ( 0 IS-D SC* WPB! ) ( NEED BONUS ROTY? )
;  RR# B@ 8 < IF
;  GA# B@ 3 MOD 2 = IF CT^ @ EXX DIVG RR# 1+WPB!
;  GA# B@ 5 = IF MA# 1+WPB! THEN
;  THEN THEN THEN ;
; OTHERWISE
;  : PATR GA# B@ 2 = IF RR# 1+WPB! THEN ;
; IFEND
;
; PATR does "link to bonus, cartoon, and display player up PATteRns" ??
; note: ( MAKE SURE THIS CRUD DEFINED )
LB93D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; BN^ "pushWORD to System stack"
        DW      $3FFC           ; constant Word ?? in ROM ??
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L0529           ; -1 (hex $FFFF) "WORD Pusher"
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ; IF False to THEN #1
        DW      L03CD,LB9A0     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ;
        DW      L075D           ; MH# do "get Max Hostages FREED by CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0754           ; TR# do "get TReasure pointer for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00BC           ; BN^ "pushWORD to System stack"
        DW      $3FFC           ; constant Word ?? in ROM ??
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      LA071           ; EXX do "NULL routine"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ; commented out: ( 0 IS-D SC* WPB! )
        DW      L0742           ; RR# do "get Robby Rotos left for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; ( NEED BONUS ROTY? )
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; _IF False to THEN #2
        DW      L03CD,LB9A0     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0417           ; MOD do "MODulo divide (SP+2) by (SP), Push REMAIDER and discard QUOTIENT"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; __IF False to THEN #3
        DW      L03CD,LB9A0     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; CT^ "pushWORD to System stack"
        DW      $3FFE           ; constant Word ?? in ROM ??
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      LA071           ; EXX do "NULL routine"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L0742           ; RR# do "get Robby Rotos left for CURRENT player"
        ;
        DW      L07D3           ; 1+WPB! do "INCREMENT WRITE-protectedBYTE in (SP)"
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; ___IF False to THEN #4
        DW      L03CD,LB9A0     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0739           ; MA# do "get MAgics left for CURRENT player"
        ;
        DW      L07D3           ; 1+WPB! do "INCREMENT WRITE-protectedBYTE in (SP)"
        ; THEN #1, THEN #2, THEN #3 and THEN #4
LB9A0:  DW      L00B0           ; ... TerseRETurn

; : D-PU MYPUP ZAP:VECT CL SFXV PU-T SETCOL TT ;
; -->
;
; D-PU does "display Player Up to play game msg pls"
LB9A2:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LB420           ; MYPUP do ??
        ;
        DW      L837C           ; ZAP:VECT do "more neat VECTor stuff"
        ;
        DW      LB538           ; CL do "CLear screen in 1K increments"
        ;
        DW      L00BC           ; SFXV "pushWORD to System stack"
        DW      $F227           ; for "?? Vector" base in Static RAM
        ;
        DW      L8CE4           ; PU-T does "Player Up display Task"
        ;
        DW      LB456           ; SETCOL does "SET Left COLors and ?? then VERBL and HORCB"
        ;
        DW      L2218           ; TT do "First Interrupt Routine then More of Third"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0196 } !!

; { BLOCK 0148 }
; ( FIRE UP GAME SCREEN ) ." SWV , TRSV , SPIDER STARTER !!"
; BTABLE ISMTB 0 B, 0 B, 0 B, 1 B, 1 B, 2 B, 2 B, 3 B, 3 B,
;
; ISMTB ( FIRE UP GAME SCREEN ) 9-byte table ??
; prints out: ."SWV , TRSV , SPIDER STARTER !!" to console ??
LB9B5:  DB      $00,$00,$00,$01,$01,$02,$02,$03,$03

; : FUGS MYPUP DIVG EI
;  F#A B@ NOT IF 0 0 XVSA vAL FILL
;  TR# WPBZERO ( CLEAR TREASURE COUNTER )
;  FREDH BZERO ( CLEAR HOSTAGES FREED CTR )
;  MH# WPBZERO ( CLEAR MAX HOSTAGES FREED CTR )
;  27 XVSA BZERO ( REHIDE THE KEY!!!!!!!!!!!!!!! )
;  MAKE:MAZE 1 F#A B! THEN MD
;  ZAP:VECT 0 CGFS CGFL FILL STARTEXCITE
;  DIVG GA# B@ 7 MIN SPEEDE B! 375 DIF B@ 25 * - SMTMRV !
;  GA# B@ DUP DIF B@ 1- ISMTB B@ + SMARTS B!
;  IF SMTMRV @ ELSE SMTMRV @ 3 * THEN SMTMR !
;  -1 HORCB OUTP M-BG ( MAKE BACKGROUND )
;  SWV TOTAL-HOSTAGES 0 DO I HOSTAB @ DUP OBJSV OVB@ HSRES
;  <> IF H-T ELSE DROP THEN LOOP ( HOSTAGES )
; -->
;
; { BLOCK 0133 }
;  TRSV TRS-T ( TREASURE )
;  KEY OBJSV OVB@ KYSHOW = IF KEY KEYMAN ELSE
;  GA# B@ NOT IF KEY EXAT THEN
;  THEN
;  PLEM P-S B!
;  INTSCR ( INITIAL SCORE DISPLAY !! )
;  PLYRV R:B M:M ( MONSTER MASH )
;  ARV A-T
;  0 7 OUTP BREAK EIVG TT DIVG
;  GAMEOVER B@ NOT IF F#A B@ IF SWV ELSE
;  MA# B@ 1+ 12 MIN MA# WPB! ( GIVE PLAYER A FREE SPELL )
;  PATR ( CALL PATCO CRUDOLA )
;  GA# 1+WPB! THEN THEN ;
; -->
;
; FUGS does "Fire Up Game Screen"
LB9BE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LB420           ; MYPUP do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L053B           ; EI do "Enable Interrupt"
        ;
        DW      L8405           ; F#A do "get CURRENT ??"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; IF False skip to THEN #1
        DW      L03CD,LB9F5     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L8428           ; XVSA do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ; ( CLEAR TREASURE COUNTER )
        DW      L0754           ; TR# do "get TReasure pointer for CURRENT player"
        ;
        DW      L07C9           ; WPZERO do "WRITE-protectedBYTE 0" into (SP) & (SP)-512d
        ; ( CLEAR HOSTAGES FREED CTR )
        DW      L843D           ; FREDH do "get FREeD Hostage counter"
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ; ( CLEAR MAX HOSTAGES FREED CTR
        DW      L075D           ; MH# do "get Max Hostages FREED by CURRENT player"
        ;
        DW      L07C9           ; WPZERO do "WRITE-protectedBYTE 0" into (SP) & (SP)-512d
        ; ( REHIDE THE KEY!!!!!!!!!!!!!!! )
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1B             ; 27 for ??
        ;
        DW      L8428           ; XVSA do ??
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L8F0B           ; MAKE:MAZE do "MAKE the MAZE looker upper"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L8405           ; F#A do "get CURRENT ??"
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; THEN #1
LB9F5:  DW      L8AD0           ; MD do ??
        ;
        DW      L837C           ; ZAP:VECT do "more neat VECTor stuff"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; CGFS "pushWORD to System stack"
        DW      $EEBD           ; for "Clear Game Frame Start" (aka SOB ??) in Static RAM
        ;
        DW      L00C5           ; CGFL "pushBYTE to System stack"
        DB      $0D             ; 13 for "Clear Game Frame Length"
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L33D9           ; STARTEXCITE do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L00BC           ; SPEEDE "pushWORD to System stack"
        DW      $EEEA           ; for ( non accelerating SPEED valuE ) Byte-Variable in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0177           ; 375 for ??
        ;
        DW      L00BC           ; DIF "pushWORD to System stack"
        DW      $E3EB           ; for ( DIFficulty factor ) 0-9 in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $19             ; 25 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00BC           ; SMTMRV "pushWORD to System stack"
        DW      $EEE4           ; for ( monster Smarts TMmeR resetter ) Variable in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00BC           ; DIF "pushWORD to System stack"
        DW      $E3EB           ; for ( DIFficulty factor ) 0-9 in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0155           ; 1- do "DECrement Top of System stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      LB9B5           ; point to ISMTB 9-Byte table
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00BC           ; SMARTS "pushWORD to System stack"
        DW      $EEE9           ; for ( monster SMARTneSs ) Byte-Variable in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; IF False to ELSE #2
        DW      L03CD,LBA57     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; SMTMRV "pushWORD to System stack"
        DW      $EEE4           ; for ( monster Smarts TMmeR resetter ) Variable in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ; (done so Jump to THEN #2)
        DW      L03C5,LBA61     ; TerseJUMP to ??
        ; ELSE #2
LBA57:  DW      L00BC           ; SMTMRV "pushWORD to System stack"
        DW      $EEE4           ; for ( monster Smarts TMmeR resetter ) Variable in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ; THEN #2
LBA61:  DW      L00BC           ; SMTMR "pushWORD to System stack"
        DW      $EEE7           ; for ( monster SMartness TMmeR ) Variable in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ; ( MAKE BACKGROUND )
        DW      L0529           ; -1 (hex $FFFF) "WORD Pusher" only uses $FF
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $09             ; for &(9)=255 as HORCB (63 + 192 for BC = Color 3)
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      LB8A5           ; M-BG do "Make Background"
        ;
        DW      LB4C7           ; SWV does "SWAP ?? INFOrmation in 5 Locations"
        ; ( HOSTAGES )
        DW      L00C5           ; TOTAL-HOSTAGES "pushBYTE to System stack"
        DB      $03             ; constant 3 for "TOTAL HOSTAGES"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00D8           ; HOSTAB "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      L8374           ; point to 3-word "HOStage vector TABle"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L819D           ; OVB@ does ??
        ;
        DW      L00C5           ; HSRES "pushBYTE to System stack"
        DB      $04             ; constant 4 for ( HoStage completely REScued )
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ; _IF False to ELSE #3
        DW      L03CD,LBA97     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L9CB8           ; H-T does "task for a Test Hostage"
        ; _(done so Jump to THEN #3)
        DW      L03C5,LBA99     ; TerseJUMP to ??
        ; _ELSE #3
LBA97:  DW      L00F6           ; DROP do "Pop HL from System stack"
        ; _THEN #3 and TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
LBA99:  DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; ( TREASURE )
        DW      L00BC           ; TRSV "pushWORD to System stack"
        DW      $F011           ; for "TReasure Vector" base in Static RAM
        ;
        DW      L9852           ; TRS-T do "Task for a hunk of TReaSure in the maze"
        ;
        DW      L00BC           ; KEY "pushWORD to System stack"
        DW      $F06F           ; for "KEY Vector" base in Static RAM
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L819D           ; OVB@ does ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $00             ; 0 for ??
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; IF False to ELSE #4
        DW      L03CD,LBABD     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; KEY "pushWORD to System stack"
        DW      $F06F           ; for "KEY Vector" base in Static RAM
        ;
        DW      L9F22           ; KEYMAN do "KEY MANager"
        ; (done so Jump to THEN #4)
        DW      L03C5,LBACD     ; TerseJUMP to ??
        ; ELSE #4
LBABD:  DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; _IF False to THEN #5
        DW      L03CD,LBACD     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; KEY "pushWORD to System stack"
        DW      $F06F           ; for "KEY Vector" base in Static RAM
        ;
        DW      L9EFB           ; EXAT do ??
        ; _THEN #4 and THEN #5
LBACD:  DW      L00C5           ; PLEM "pushBYTE to System stack"
        DB      $00             ; constant 0 for "PLayer state variable ??"
        ;
        DW      L00BC           ; P-S "pushWORD to System stack"
        DW      $EEE6           ; for ( Player State ) Byte-Variable in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; ( INITIAL SCORE DISPLAY !! )
        DW      LB6AD           ; INTSCR do "INITialize SCoRe"
        ;
        DW      L00BC           ; PLYRV "pushWORD to System stack"
        DW      $F12D           ; for Word "PLaYeR Vector" base in Static RAM
        ;
        DW      LB06B           ; R:B do ??
        ; ( MONSTER MASH )
        DW      LA976           ; M:M do "Monster Mash"
        ;
        DW      L00BC           ; ARV "pushWORD to System stack"
        DW      $F31F           ; for ( ARrow Vector ) base in Static RAM
        ;
        DW      L9768           ; A-T do "Arrow Task fella_"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for BLACK
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for &(7)=0 to set COL3L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L2215           ; BREAK do "null Terse subroutine" ??
        ;
        DW      L199A           ; EIVG do ??
        ;
        DW      L2218           ; TT do "First Interrupt Routine then More of Third"
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L00BC           ; GAMEOVER "pushWORD to System stack"
        DW      $E3FF           ; read "GAME OVER" (disallows ??) in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; IF False to THEN #6
        DW      L03CD,LBB23     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L8405           ; F#A do "get CURRENT ??"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; _IF False to ELSE #7
        DW      L03CD,LBB0E     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LB4C7           ; SWV does "SWAP ?? INFOrmation in 5 Locations"
        ; _(done so Jump to THEN #7)
        DW      L03C5,LBB23     ; TerseJUMP to ??
        ; _ELSE #7 ( GIVE PLAYER A FREE SPELL )
LBB0E:  DW      L0739           ; MA# do "get MAgics left for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L0739           ; MA# do "get MAgics left for CURRENT player"
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ; ( CALL PATCO CRUDOLA )
        DW      LB93D           ; PATR do "link to bonus, cartoon, and display player up PATteRns"
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L07D3           ; 1+WPB! do "INCREMENT WRITE-protectedBYTE in (SP)"
        ; _THEN #6 and THEN #7
LBB23:  DW      L00B0           ; ... TerseRETurn
; end of ( FIRE UP GAME SCREEN ) !!

; { BLOCK 0262 }
; ( GAME PLAYER ) HEX
; : R-CHK RR# B@ DUP 0= SWAP 16 > OR ;
;
; R-CHK does ( GAME PLAYER ) ??
LBB25:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0742           ; RR# do "get Robby Rotos left for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $16             ; 22 for ??
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ;
        DW      L00B0           ; ... TerseRETurn

; : P1PG
;  botha WPBZERO ( CLEAR PREV 2 PLAYER MODE )
;  BEGIN R-CHK IF GO-SET ELSE FUGS THEN
;  GAMEOVER B@ END ;
;
; P1PG does "Play 1 Player Game"
LBB39:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ; ( CLEAR PREV 2 PLAYER MODE )
        DW      L00BC           ; botha "pushWORD to System stack"
        DW      $E398           ; for ( BOTH players Active ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L07C9           ; WPZERO do "WRITE-protectedBYTE 0" into (SP) & (SP)-512d
        ; BEGIN loop
LBB40:  DW      LBB25           ; R-CHK do ( GAME PLAYER )
        ; _IF False to ELSE
        DW      L03CD,LBB4C     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0858           ; GO-SET do "Two pairs of 0's then a pair of 1's in NV-RAM"
        ; _(done so Jump to THEN)
        DW      L03C5,LBB4E     ; TerseJUMP to ??
        ; _ELSE
LBB4C:  DW      LB9BE           ; FUGS do "Fire Up Game Screen"
        ; _THEN
LBB4E:  DW      L00BC           ; GAMEOVER "pushWORD to System stack"
        DW      $E3FF           ; read "GAME OVER" (disallows ??) in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; END or loop to BEGIN if False
        DW      L03CD,LBB40     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn

; XC? IFTRUE : P2PG
;  BEGIN D-PU ( DISPLAY PLAYER UP MSG PLS )
;  BEGIN R-CHK IF F#A BONE RR# WPBZERO ELSE FUGS THEN
;  F#A B@ END ( WAIT FOR DEATH FRAME )
;  RR# B@ ( GET REMAINING LIVES ON STK )
;  SWAPO ( SWITCH TO OTHER JERK )
;  NERDUP 1+ 1 AND plup WPB! ( GO TO OTHER PLAYER )
;  0= END ; ( CONTINUE AS LONG BOTH ARE ALIVE )
; OTHERWISE : P2PG ; IFEND
; DECIMAL
; -->
;
; P2PG does "Play 2 Player Game" (UNTIL ONES DEAD)
LBB5A:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ; BEGIN #1
LBB5B:  DW      LB9A2           ; D-PU do "display Player Up msg pls"
        ; _BEGIN #2
LBB5D:  DW      LBB25           ; R-CHK do ( GAME PLAYER )
        ; __IF False to ELSE
        DW      L03CD,LBB6F     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L8405           ; F#A do "get CURRENT ??"
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      L0742           ; RR# do "get Robby Rotos left for CURRENT player"
        ;
        DW      L07C9           ; WPZERO do "WRITE-protectedBYTE 0" into (SP) & (SP)-512d
        ; __(done so Jump to THEN)
        DW      L03C5,LBB71     ; TerseJUMP to ??
        ; __ELSE
LBB6F:  DW      LB9BE           ; FUGS do "Fire Up Game Screen"
        ; __THEN ( WAIT FOR DEATH FRAME )
LBB71:  DW      L8405           ; F#A do "get CURRENT ??"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; _END #2 or loop to BEGIN #2 if False
        DW      L03CD,LBB5D     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ; ( GET REMAINING LIVES ON STK )
        DW      L0742           ; RR# do "get Robby Rotos left for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; ( SWITCH TO OTHER JERK )
        DW      LB510           ; SWAPO do "SWAP Player 1&2 INFOrmation"
        ; ( GO TO OTHER PLAYER )
        DW      L0725           ; NERDUP do "TEST bit 0 of plup for PLayer-1 UP"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L00BC           ; plup "pushWORD to System stack"
        DW      $E399           ; for ( PLayer-1 UP ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ; ( CONTINUE AS LONG BOTH ARE ALIVE )
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; END #1 or loop to BEGIN #1 if False
        DW      L03CD,LBB5B     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0262 } !!

; { BLOCK 0097 }
; ( HARD NEW GAME INITIALIZATION ) HEX
; : I-GM #PLA B@ botha WPB! plup WPBZERO
;  0 ma# WPBONE 1 ma# WPBONE 0 g#m WPZERO 1 g#m WPZERO
;  0 tr# WPZERO
;  0 sc* WPZERO 303 0 rr# WP!
;  sc1l WPZERO sc1h WPZERO sc2l WPZERO sc2h WPZERO ;
;
; I-GM does "hard new GaMe Initialization"
LBB95:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; #PLA "pushWORD to System stack"
        DW      $E39A           ; for ( # of PLAyers-1 ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00BC           ; botha "pushWORD to System stack"
        DW      $E398           ; for ( BOTH players Active ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ;
        DW      L00BC           ; plup "pushWORD to System stack"
        DW      $E399           ; for ( PLayer-1 UP ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L07C9           ; WPZERO do "WRITE-protectedBYTE 0" into (SP) & (SP)-512d
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; ma# "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E38A           ; for ( MAgics left ) 2-Byte Array base in High WRITE-protected NV RAM
        ;
        DW      L07C4           ; WPBONE do "WRITE-protectedBYTE 1" into (SP) & (SP)-512
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00CD           ; ma# "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E38A           ; for ( MAgics left ) 2-Byte Array base in High WRITE-protected NV RAM
        ;
        DW      L07C4           ; WPBONE do "WRITE-protectedBYTE 1" into (SP) & (SP)-512
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00D8           ; g#m "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E38C           ; for ( GaMe # ) Array base in High WRITE-protected NV RAM
        ;
        DW      L07DF           ; WPZERO do "WRITE-protectedWORD 0" into (SP) & (SP)-513
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00D8           ; g#m "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E38C           ; for ( GaMe # ) Array base in High WRITE-protected NV RAM
        ;
        DW      L07DF           ; WPZERO do "WRITE-protectedWORD 0" into (SP) & (SP)-513
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; tr# "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E384           ; for ( TReasure pointer ) base in High WRITE-protected NV RAM
        ;
        DW      L07DF           ; WPZERO do "WRITE-protectedWORD 0" into (SP) & (SP)-513
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; sc* "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E386           ; for ( SCore MULT ) base in High WRITE-protected NV RAM
        ;
        DW      L07DF           ; WPZERO do "WRITE-protectedWORD 0" into (SP) & (SP)-513
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0303           ; 771 for ?? (or 00000011B,00000011B !!)
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; rr# "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $E388           ; for ( Robby Rotos left ) base in High WRITE-protected NV RAM
        ;
        DW      L07D8           ; WP! do "WRITE-protectedWORD" (SP+2) into (SP) & (SP)-513
        ;
        DW      L00BC           ; sc1l "pushWORD to System stack"
        DW      $E396           ; for Word "SCore p1 Low" in High WRITE-protected NV RAM
        ;
        DW      L07DF           ; WPZERO do "WRITE-protectedWORD 0" into (SP) & (SP)-513
        ;
        DW      L00BC           ; sc1h "pushWORD to System stack"
        DW      $E394           ; for Word ( SCore p1 High ) in High WRITE-protected NV RAM
        ;
        DW      L07DF           ; WPZERO do "WRITE-protectedWORD 0" into (SP) & (SP)-513
        ;
        DW      L00BC           ; sc2l "pushWORD to System stack"
        DW      $E392           ; for Word "SCore p2 Low" in High WRITE-protected NV RAM
        ;
        DW      L07DF           ; WPZERO do "WRITE-protectedWORD 0" into (SP) & (SP)-513
        ;
        DW      L00BC           ; sc2h "pushWORD to System stack"
        DW      $E390           ; for Word ( SCore p2 High ) in High WRITE-protected NV RAM
        ;
        DW      L07DF           ; WPZERO do "WRITE-protectedWORD 0" into (SP) & (SP)-513
        ;
        DW      L00B0           ; ... TerseRETurn

; ( SOFT NEW GAME REINITIALIZATION )
; : RAG MYPUP DIVG
;  8 0 DO 0FA I OUTP LOOP 0 ngS ngL FILL ;
; DECIMAL
; -->
;
; RAG does "soft new game reinitialization"
LBBFE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LB420           ; MYPUP do ??
        ;
        DW      L199F           ; DIVG do "clear ?? word"
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for LOOPS ?? for all Color OUTports
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" starting with COL0R ??
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $FA             ; note: for setting &(0) thru &(7)=250 as Dark BLUE
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ; TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; ngS "pushWORD to System stack"
        DW      $EECA           ; constant "Start of m? (a 20-Byte Array ??)" in Static RAM
        ;
        DW      L00C5           ; ngL "pushBYTE to System stack"
        DB      $16             ; constant 22 for "Length of m? (a 20-Byte Array ??)"
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of { BLOCK 0097 } !!

; { BLOCK 0231 }
; ( MORE GAME PLAYER )
; HEX XC? IFTRUE
;  : ROTO
;  RESTART? B@ 0= IF I-GM THEN RAG
;  #PLA B@ IF P2PG THEN ( PLAY 2 UNTIL ONES DEAD )
;  D-PU P1PG INVERT-OFF ; ( PLAY 1 PLAYER GAME )
;
; LBC1F: ROTO does "MORE GAME PLAYER" not used ??
        RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; RESTART? "pushWORD to System stack"
        DW      $E3FC           ; point to "0, 1, 2 counter for RESTART" in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; IF False skip to THEN #1
        DW      L03CD,LBC2E     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LBB95           ; I-GM do "hard new GaMe Initialization"
        ; THEN #1
LBC2E:  DW      LBBFE           ; RAG do "soft new game reinitialization"
        ; ( PLAY 2 UNTIL ONES DEAD )
        DW      L00BC           ; #PLA "pushWORD to System stack"
        DW      $E39A           ; for ( # of PLAyers-1 ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; IF False skip to THEN #2
        DW      L03CD,LBC3C     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LBB5A           ; P2PG do "Play 2 Player Game"
        ; THEN #2
LBC3C:  DW      LB9A2           ; D-PU do "display Player Up msg pls"
        ; ( PLAY 1 PLAYER GAME )
        DW      LBB39           ; P1PG do "Play 1 Player Game"
        ;
        DW      L1F34           ; INVERT-OFF do "clear COCKTAIL mode for UPRIGHTs"
        ;
        DW      L00B0           ; ... TerseRETurn

; ( : SX 0 E000 1F00 FILL PUP WPCLEAR
;  BEGIN GAMEOVER WPBZERO 2 RND #PLA WPB!
;  ROTO 0 END ; )
;  ' PATTY 3FF8 U! ' ROTO 3FFA U!
; ( LINK TO FLASHER ) ' FLSHT 3FF6 U!
; OTHERWISE : ROTO #PLA WPBZERO I-GM RAG P1PG ;
; IFEND
; DECIMAL
; -->
;
; LBC44: ?? table ?? (ChecKsum Byte ??)
        DB      $FF,$FF
; end of ( MORE GAME PLAYER ) !!

;
;*****************************************************************************
;
; Three additional monochrome FONT Patterns, in this order:  = . !
;
;*****************************************************************************
; note: hot-spot(s) marked with _._ or (X) on upper-right corner(s)
;
; AlphaNumeric character #38
        DB      $05             ; 5 = significant Pixels (NOT Labeled !!)
LBC47:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $3D for Symbol '='
        DB      $00             ;_._. . . . . . .
        DB      $00             ; . . . . . . . .
        DB      $00             ; . . . . . . . .
        DB      $F8             ; X X X X X . . .
        DB      $00             ; . . . . . . . .
        DB      $F8             ; X X X X X . . .
        DB      $00             ; . . . . . . . .
        DB      $00             ; . . . . . . . .
        DB      $00             ; . . . . . . . .
        DB      $00             ; . . . . . . . .

; AlphaNumeric character #39
        DB      $02             ; 2 = significant Pixels
LBC56:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $02             ; 2 = Height in rows
        ; ASCII $2E for Symbol '.'
        DB      $C0             ;(X)X . . . . . .
        DB      $C0             ; X X . . . . . .

; AlphaNumeric character #40
        DB      $02             ; 2 = significant Pixels
LBC5D:  DB      $00             ; 0 = X offset
        DB      $00             ; 0 = Y offset
        DB      $01             ; 1 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ; ASCII $21 for Symbol '!'
        DB      $C0             ;(X)X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $00             ; . . . . . . . .
        DB      $C0             ; X X . . . . . .
        DB      $C0             ; X X . . . . . .

; start of stuff for displaying DEMO Screen (twice each ATTRACT Mode)
;
; Switch to a 4-color RED BALL pattern, with just 4 bytes header
LBC6B:  DB      $07             ; 7 = X offset
        DB      $06             ; 6 = Y offset
        DB      $04             ; 4 = Width in bytes
        DB      $0E             ; 14 = Height in rows
        ;
        DB      $00,$0A,$00,$00 ; . . . . . . 2 2 . . . . . . . .
        DB      $00,$AA,$A0,$00 ; . . . . 2 2 2 2 2 2 . . . . . .
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .
        DB      $2A,$AA,$AA,$80 ; . 2 2 2 2 2 2 2 2 2 2 2 2 . . .
        DB      $2A,$AA,$AA,$80 ; . 2 2 2 2 2 2 2 2 2 2 2 2 . . .
        DB      $AA,$AA,$AA,$A0 ; 2 2 2 2 2 2 2(2)2 2 2 2 2 2 . .
        DB      $AA,$AA,$AA,$A0 ; 2 2 2 2 2 2 2 2 2 2 2 2 2 2 . .
        DB      $2A,$AA,$AA,$80 ; . 2 2 2 2 2 2 2 2 2 2 2 2 . . .
        DB      $2A,$AA,$AA,$80 ; . 2 2 2 2 2 2 2 2 2 2 2 2 . . .
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .
        DB      $0A,$AA,$AA,$00 ; . . 2 2 2 2 2 2 2 2 2 2 . . . .
        DB      $00,$AA,$A0,$00 ; . . . . 2 2 2 2 2 2 . . . . . .
        DB      $00,$0A,$00,$00 ; . . . . . . 2 2 . . . . . . . .
; end of RED BALL pattern for drawing "ROTO" in DEMO Screen

; ?? Word table ?? (form ROTO letters !!)
LBCA7:  DW      $001E           ; index 0 = 30 for ??
        DW      $0000           ; index 1 = 0 for ??
        DW      $FF84           ; index 2 = -124 for ??
        DW      $001E           ; index 3 = 30 for ??
        DW      $FF86           ; index 4 = -122 for ??
        DW      $002E           ; index 5 = 45 for ??
        DW      $FF8B           ; index 6 = -117 for ??
        DW      $0037           ; index 7 = 55 for ??
        DW      $FF92           ; index 8 = -110 for ??
        DW      $003B           ; index 9 = 59 for ??
        DW      $FF9C           ; index 10 = -100 for ??
        DW      $003C           ; index 11 = 60 for ??
        DW      $FFA8           ; index 12 = -88 for ??
        DW      $003A           ; index 13 = 58 for ??
        DW      $FFB0           ; index 14 = -80 for ??
        DW      $0037           ; index 15 = 55 for ??
        DW      $FFB3           ; index 16 = -77 for ??
        DW      $0032           ; index 17 = 50 for ??
        DW      $FFB5           ; index 18 = -75 for ??
        DW      $002C           ; index 19 = 44 for ??
        DW      $FFB3           ; index 20 = -77 for ??
        DW      $0025           ; index 21 = 37 for ??
        DW      $FFAC           ; index 22 = -84 for ??
        DW      $0020           ; index 23 = 32 for ??
        DW      $FFA4           ; index 24 = -92 for ??
        DW      $001C           ; index 25 = 28 for ??
        DW      $FFA9           ; index 26 = -87 for ??
        DW      $0011           ; index 27 = 17 for ??
        DW      $FFB4           ; index 28 = -76 for ??
        DW      $0006           ; index 29 = 6 for ??

; ?? table ?? (used TWICE !!)
LBCE3:  DW      $0022           ; index 0 = 34 for ??
        DW      $0000           ; index 1 = 0 for ??
        DW      $FFE7           ; index 2 = -25 for ??
        DW      $0006           ; index 3 = 6 for ??
        DW      $FFEF           ; index 4 = -17 for ??
        DW      $000A           ; index 5 = 10 for ??
        DW      $FFF7           ; index 6 = -9 for ??
        DW      $0014           ; index 7 = 20 for ??
        DW      $FFF9           ; index 8 = -7 for ??
        DW      $0021           ; index 9 = 33 for ??
        DW      $FFF7           ; index 10 = -9 for ??
        DW      $002F           ; index 11 = 47 for ??
        DW      $FFEF           ; index 12 = -17 for ??
        DW      $0037           ; index 13 = 55 for ??
        DW      $FFE7           ; index 14 = -25 for ??
        DW      $003B           ; index 15 = 59 for ??
        DW      $FFDE           ; index 16 = -34 for ??
        DW      $003C           ; index 17 = 60 for ??
        DW      $FFD5           ; index 18 = -43 for ??
        DW      $003B           ; index 19 = 59 for ??
        DW      $FFCE           ; index 20 = -50 for ??
        DW      $0037           ; index 21 = 55 for ??
        DW      $FFC6           ; index 22 = -58 for ??
        DW      $002F           ; index 23 = 47 for ??
        DW      $FFC4           ; index 24 = -60 for ??
        DW      $0021           ; index 25 = 33 for ??
        DW      $FFC6           ; index 26 = -58 for ??
        DW      $0014           ; index 27 = 20 for ??
        DW      $FFCE           ; index 28 = -50 for ??
        DW      $000A           ; index 29 = 10 for ??
        DW      $FFD5           ; index 30 = -43 for ??
        DW      $0006           ; index 31 = 6 for ??
        DW      $FFDE           ; index 32 = -34 for ??
        DW      $0005           ; index 33 = 5 for ??

; ?? table ??
LBD27:  DW      $0008           ; index 0 = 8 for ??
        DW      $0000           ; index 1 = 0 for ??
        DW      $0020           ; index 2 = 32 for ??
        DW      $003C           ; index 3 = 60 for ??
        DW      $0008           ; index 4 = 8 for ??
        DW      $003C           ; index 5 = 60 for ??
        DW      $0038           ; index 6 = 56 for ??
        DW      $003C           ; index 7 = 60 for ??

; end of Word (form ROTO letters !!) tables

; Five TEXT Strings (byte CHARACTERS; bytes ASCII non-terminated)
LBD37:  DB      $06,"TO THE"
LBD3E:  DB      $08,"RESCUE !"
        ;
LBD47:  DB      $06,"INSERT"
LBD4E:  DB      $04,"COIN"
        ;
LBD53:  DB      $1E,"MCMLXXXI BALLY/MIDWAY MFG. CO."

; DEMO Screen COPYRIGHT pattern
LBD72:  DB      $04             ; 4 = X offset
        DB      $05             ; 5 = Y offset
        DB      $02             ; 2 = Width in bytes
        DB      $0A             ; 10 = Height in rows
        ;
        DB      $0A,$A0         ; . . 2 2 2 2 . .
        DB      $20,$08         ; . 2 . . . . 2 .
        DB      $82,$82         ; 2 . . 2 2 . . 2
        DB      $88,$22         ; 2 . 2 . . 2 . 2
        DB      $88,$02         ; 2 . 2 . . . . 2
        DB      $88,$02         ; 2 . 2 . . . . 2
        DB      $88,$22         ; 2 . 2 . . 2 . 2
        DB      $82,$82         ; 2 . . 2 2 . . 2
        DB      $20,$08         ; . 2 . . . . 2 . .
        DB      $0A,$A0         ; . . 2 2 2 2 . .

; begin DEMO SCREEN routines !! (uses ?? Vector offsets as Variables ??)
; and $01B0 bytes from $FB8B through $FD3A in Static RAM (NONE named !!)
;
; ?? does "get CURRENT BASEYH" in DEMO Screen
LBD8A:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L00C5           ; BASEYH "pushBYTE to System stack"
        DB      $44             ; offset 68 for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "get CURRENT DELTAXH"
LBD94:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L00C5           ; DELTAXH do "pushBYTE to System stack"
        DB      $46             ; offset 70 for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "get CURRENT BASEXH"
LBD9E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L00C5           ; BASEXH "pushBYTE to System stack"
        DB      $42             ; offset 66 for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "get CURRENT NOWD"
LBDA8:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L00C5           ; NOWD "pushBYTE to System stack"
        DB      $40             ; offset 64 for ( CURRENT Direction )
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "get CURRENT NOWR"
LBDB2:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L00C5           ; NOWR "pushBYTE to System stack"
        DB      $3E             ; offset 62 for ( CURRENT Row )
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "CLEAR $01B0 bytes from $FB8B through $FD3A" in Static RAM
LBDBC:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB8B           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01B0           ; 432 for ??
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L00B0           ; ... TerseRETurn

; LBDCB: (not used) ?? does "RaNDom 0 or -1"
        RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for Range ??
        ;
        DW      L1A5B           ; RND does "SHIFT and limit RANGE for Next Pseudo-RANDOM Number"
        ; IF False to THEN
        DW      L03CD,LBDD6     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0149           ; MINUS do "00 - (SP)" for TWO's complement Top of System stack
        ; THEN
LBDD6:  DW      L00B0           ; ... TerseRETurn

; ?? does "TEST (SP) EQUAL 1"
LBDD8:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "TEST (SP) GREATER Than 1"
LBDDF:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "TerseCALL to Word in BASEXH (AND BASEY low ??)"
LBDE6:  LD      HL,($FEE6)      ; vaddr read "Vector ADDRess" base in Static RAM
        LD      DE,$0042        ; BASEXH offset 66 for ??
        ADD     HL,DE
        LD      A,(HL)
        LD      (HL),C          ; store OLD Terse Program Counter
        LD      C,A
        INC     HL
        LD      A,(HL)
        LD      (HL),B
        LD      B,A
        JP      (IY)            ; indexed RETurn to NEW Terse Program Counter

; ?? does "SET Starting ANGLE = 128 (NorthWest !!)"
LBDF6:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $80             ; 128 for ??
        ;
        DW      L1AF9           ; ANGLE! do "SET ANGLE"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "SET Starting ANGLE = 0 (North !!)"
LBDFE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L1AF9           ; ANGLE! do "SET ANGLE"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "SET Starting ANGLE by VDX"
LBE05:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L1D9F           ; DX@ do "get ( vector address --- Delta X )"
        ;
        DW      L01FC           ; do "TEST (SP) Greater Than ZERO return in (SP)"
        ; IF False to ELSE
        DW      L03CD,LBE16     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LBDF6           ; ?? do "SET Starting ANGLE = 128 (NorthWest !!)"
        ; (done so Jump to THEN)
        DW      L03C5,LBE18     ; TerseJUMP to ??
        ; ELSE
LBE16:  DW      LBDFE           ; ?? do "SET Starting ANGLE = 0 (North !!)"
        ; THEN
LBE18:  DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBE1A:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FD4F           ; for Word ?? for ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBE23:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FD4F           ; for Word ?? for ?? in Static RAM
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBE2C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1D28
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBE33:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBE40:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L015F           ; 2+ do "ADD 2 to Top of System stack"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBE4D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      LBD8A           ; ?? do "get CURRENT BASEYH"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      LBDA8           ; ?? do "get CURRENT NOWD"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      LBD94           ; ?? do "get CURRENT DELTAXH"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ; BEGIN loop
LBE60:  DW      LBD94           ; ?? do "get CURRENT DELTAXH"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L016B           ; 2* do "Double Top of System stack"
        ;
        DW      LBDA8           ; ?? do "get CURRENT NOWD"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      LBDB2           ; ?? do "get CURRENT NOWR"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L015F           ; 2+ do "ADD 2 to Top of System stack"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      LBE05           ; ?? do "SET Starting ANGLE by VDX"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      LBD94           ; ?? do "get CURRENT DELTAXH"
        ;
        DW      LBE40
        ;
        DW      LBD94           ; ?? do "get CURRENT DELTAXH"
        ;
        DW      LBD8A           ; ?? do "get CURRENT BASEYH"
        ;
        DW      LBE33
        ; END or loop to BEGIN if False
        DW      L03CD,LBE60     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LBDE6           ; ?? do "TerseCALL to Word in BASEXH (AND BASEY low ??)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBE98:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $BE4E           ; point to LBE4D + 1 ??
        ;
        DW      LBD9E           ; ?? do "get CURRENT BASEXH"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBEA3:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for Color 0 on Color 0
        ;
        DW      L1E24           ; XPAND! ?? do "Load eXPAND value ?? but DON'T turn it ON yet"
        ;
        DW      L1E3A           ; XPAND!-OFF do "Turn eXPAND ?? OFF"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBEAC:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBEB3:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3C             ; 60 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does "FILL Screen with Color 1 Bytes"
LBEBB:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $55             ; 85 for pattern 01010101B !!
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $4000           ; NORMEM for start of Screen RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $3FFF           ; NORMEM - 1 for SIZE of Screen RAM - 1
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBECB:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1A             ; 26 for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3F             ; 63 for ??
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBEE2:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LBDF6           ; ?? do "SET Starting ANGLE = 128 (NorthWest !!)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEC
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEC
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0226           ; 550 for ??
        ;
        DW      L1CD3
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBEF5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LBDF6           ; ?? do "SET Starting ANGLE = 128 (NorthWest !!)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB1
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0226           ; 550 for ??
        ;
        DW      L1CD3
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBF08:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LBDFE           ; ?? do "SET Starting ANGLE = 0 (North !!)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC4
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0226           ; 550 for ??
        ;
        DW      L1CD3
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBF1A:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LBDF6           ; ?? do "SET Starting ANGLE = 128 (NorthWest !!)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEC
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $028A           ; 650 for ??
        ;
        DW      L1CD3
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBF2C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LBDFE           ; ?? do "SET Starting ANGLE = 0 (North !!)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $6E             ; 110 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFDD
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0226           ; 550 for ??
        ;
        DW      L1CD3
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBF3E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LBDF6           ; ?? do "SET Starting ANGLE = 128 (NorthWest !!)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEF
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFBC
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBF51:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LBDF6           ; ?? do "SET Starting ANGLE = 128 (NorthWest !!)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC4
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFE2
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $028A           ; 650 for ??
        ;
        DW      L1CD3
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBF64:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      LBEA3
        ;
        DW      L1EDC           ; ZEROTIMEB do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $12             ; 18 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEC
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEC
        ;
        DW      L1D28
        ;
        DW      L00BC           ; JHOS-F "pushWORD to System stack"
        DW      L2851           ; for SAD-captured-HOSTAGE-in-box pattern
        ;
        DW      L1BE2           ; ANIM! do Set up Captured HOSTAGE Animation Loop for ??
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L1DD4
        ;
        DW      L00BC           ; JHOS-S "pushWORD to System stack"
        DW      L288D           ; fur HAPPY-freed-HOSTAGE pattern
        ;
        DW      L1BE2           ; ANIM! do Set up Freed HOSTAGE Animation Loop for ??
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L3646           ; CAPT-S do ??
        ;
        DW      LBEF5
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC1
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $69             ; 105 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      LBF2C
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L37D0
        ;
        DW      L1DBB
        ;
        DW      L00BC           ; JHOS-S "pushWORD to System stack"
        DW      L288D           ; for HAPPY-freed-HOSTAGE pattern
        ;
        DW      L1BE2           ; ANIM! do Set up Freed HOSTAGE Animation Loop for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $64             ; 100 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $28             ; 40 for ??
        ;
        DW      L1D28
        ;
        DW      L1DD4
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LBFC5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      LBEA3
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $64             ; 100 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEC
        ;
        DW      L1D28
        ;
        DW      L00BC           ; JHOS-F "pushWORD to System stack"
        DW      L2851           ; for SAD-captured-HOSTAGE-in-box pattern
        ;
        DW      L1BE2           ; ANIM! do Set up Captured HOSTAGE Animation Loop for ??
        ;
        DW      L1DD4
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L00BC           ; JHOS-S "pushWORD to System stack"
        DW      L288D           ; for HAPPY-freed-HOSTAGE pattern
        ;
        DW      L1BE2           ; ANIM! do Set up Freed HOSTAGE Animation Loop for ??
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L3646           ; CAPT-S do ??
        ;
        DW      LBEE2
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      LBEF5
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC2
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $37             ; 55 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L35E7           ; DRUG-S do ??
        ;
        DW      L00BC           ; JHOS-F "pushWORD to System stack"
        DW      L2851           ; for SAD-captured-HOSTAGE-in-box pattern
        ;
        DW      L1BE2           ; ANIM! do Set up Captured HOSTAGE Animation Loop for ??
        ;
        DW      LBF1A
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFD1
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFE4
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $02BC           ; 700 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LC02E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      LBEA3
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $55             ; 85 for pattern 01010101B !!
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $77A0           ; 30624 in Screen RAM (near the Bottom !!)
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $085F           ; 2143 for Count up to End of Screen RAM -1
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L00BC           ; KEY1 "pushWORD to System stack"
        DW      L25FA           ; for single buried KEY pattern
        ;
        DW      L1BE2           ; ANIM! do Set up KEY pattern for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFAB
        ;
        DW      L1D28
        ;
        DW      L1DD4
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L29C7           ; for SPIDERS animation table
        ;
        DW      L1BE2           ; ANIM! do Set up SPIDERS Animation Loop for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5A             ; 90 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFD8
        ;
        DW      L1D28
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L1D2F           ; ZERODXDYAXAY do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $6E             ; 110 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L1DD4
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFAB
        ;
        DW      L1D28
        ;
        DW      L00BC           ; KEY1 "pushWORD to System stack"
        DW      L25FA           ; for single buried KEY pattern
        ;
        DW      L1BE2           ; ANIM! do Set up KEY Pattern for ??
        ;
        DW      L1DD4
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $08             ; 8 for Color 2 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L8201           ; unknown color ?? Monochrome EXIT SIGN pattern
        ;
        DW      L1BE2           ; ANIM! do Set up EXIT SIGN Pattern for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $6E             ; 110 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFDD
        ;
        DW      L1D28
        ;
        DW      L1DD4
        ;
        DW      L1E3A           ; XPAND!-OFF do "Turn eXPAND ?? OFF"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L29C7           ; for SPIDERS animation table
        ;
        DW      L1BE2           ; ANIM! do Set up SPIDERS Animation Loop for ??
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5A             ; 90 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFD8
        ;
        DW      L1D28
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC4
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $FA             ; 250 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      LBF1A
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC4
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFE2
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $028A           ; 650 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ?? DISPLAY one DEMO SCREEN (with SOUND on either Player input)
LC0D1:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      LBE98
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      LBDB2           ; ?? do "get CURRENT NOWR"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LBD72           ; for COPYRIGHT pattern
        ;
        DW      L1BE2           ; ANIM! do Set up COPYRIGHT Pattern for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF7E
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFAB
        ;
        DW      L1D28
        ;
        DW      L1DD4
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for Color 2 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF8D
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFA6
        ;
        DW      L1D28
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LBD53           ; for 30,"MCMLXXXI BALLY/MIDWAY MFG. CO." string
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $4A             ; note: for setting &(COL3L)=74 to Dark RED
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for &(7)=74 as COL3L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      LBE1A
        ;
        DW      LBEA3
        ;
        DW      L00BC           ; ROTROTY "pushWORD to System stack"
        DW      L2DC4           ; for "PAUSE then DIG ROTOS" animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGING ROTOS Animation Loop for ??
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0
        ;
        DW      L1D28
        ;
        DW      L33D9           ; STARTEXCITE do ??
        ;
        DW      L3403
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFCE
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      LBDF6           ; ?? do "SET Starting ANGLE = 128 (NorthWest !!)"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF83
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0258           ; 600 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L25F1           ; for NO PAUSE then DIGGERS animation table
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGERS Animation Loop for ??
        ;
        DW      L1D2F           ; ZERODXDYAXAY do ??
        ;
        DW      LBEB3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      LBDFE           ; ?? do "SET Starting ANGLE = 0 (North !!)"
        ;
        DW      LBE23
        ;
        DW      L348E
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00D8           ; do "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      LBCA7           ; ?? table ?? to form ROTO letter "R"
        ;
        DW      LBDE6           ; ?? do "TerseCALL to Word in BASEXH (AND BASEY low ??)"
        ;
        DW      LBE1A
        ;
        DW      L00BC           ; ROTROTY "pushWORD to System stack"
        DW      L2DC4           ; for "PAUSE then DIG ROTOS" animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGING ROTOS Animation Loop for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFDE
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L3403
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      LBE98
        ;
        DW      LBE23
        ;
        DW      L348E
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00D8           ; do "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      LBCE3           ; ?? table ?? to form ROTO letter "O"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L25F1           ; for NO PAUSE then DIGGERS animation table
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGERS Animation Loop for ??
        ;
        DW      LBDE6           ; ?? do "TerseCALL to Word in BASEXH (AND BASEY low ??)"
        ;
        DW      LBE98
        ;
        DW      L00BC           ; ROTROTY "pushWORD to System stack"
        DW      L2DC4           ; for "PAUSE then DIG ROTOS" animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGING ROTOS Animation Loop for ??
        ;
        DW      LBDFE           ; ?? do "SET Starting ANGLE = 0 (North !!)"
        ;
        DW      LBE1A
        ;
        DW      L3403
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      LBE23
        ;
        DW      L348E
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L25F1           ; for NO PAUSE then DIGGERS animation table
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGERS Animation Loop for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00D8           ; do "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      LBD27           ; ?? table ?? to form ROTO letter "T"
        ;
        DW      LBDE6           ; ?? do "TerseCALL to Word in BASEXH (AND BASEY low ??)"
        ;
        DW      L00BC           ; ROTROTY "pushWORD to System stack"
        DW      L2DC4           ; for "PAUSE then DIG ROTOS" animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGING ROTOS Animation Loop for ??
        ;
        DW      LBE1A
        ;
        DW      L3403
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $64             ; 100 for ??
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L25F1           ; for NO PAUSE then DIGGERS animation table
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGERS Animation Loop for ??
        ;
        DW      LBE98
        ;
        DW      LBE23
        ;
        DW      L348E
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00D8           ; do "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      LBCE3           ; ?? table ?? to form ROTO letter "O" twice
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $86             ; 134 for ??
        ;
        DW      LBDB2           ; ?? do "get CURRENT NOWR"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      LBDE6           ; ?? do "TerseCALL to Word in BASEXH (AND BASEY low ??)"
        ;
        DW      LBE1A
        ;
        DW      L3403
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      LBDB2           ; ?? do "get CURRENT NOWR"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00BC           ; ROTROTY "pushWORD to System stack"
        DW      L2DC4           ; for "PAUSE then DIG ROTOS" animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGING ROTOS Animation Loop for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FBD3           ; for Word ?? in Static RAM
        ;
        DW      LC02E
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $64             ; 100 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF1
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      LBEE2
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FC1B           ; for Word ?? in Static RAM
        ;
        DW      LBFC5
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      LBEF5
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FC63           ; for Word ?? in Static RAM
        ;
        DW      LBF64
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L36C6
        ;
        DW      LBF08
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L3403
        ;
        DW      LBF3E
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L1D2F           ; ZERODXDYAXAY do ??
        ;
        DW      LBDFE           ; ?? do "SET Starting ANGLE = 0 (North !!)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $4B             ; 75 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      LBF2C
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L1DBB
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L00BC           ; ROTROTY "pushWORD to System stack"
        DW      L2DC4           ; for "PAUSE then DIG ROTOS" animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGING ROTOS Animation Loop for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFDD
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $23             ; 35 for ??
        ;
        DW      L1D28
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1D2F           ; ZERODXDYAXAY do ??
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEC
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFE2
        ;
        DW      L1D28
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for Color 1 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      LBECB
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LBD37           ; for 6,"TO THE" text string
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEC
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFCE
        ;
        DW      L1D28
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LBD3E           ; for 8,"RESCUE !" text string
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L32F3           ; SHUTUP does "SHUT UP all sounds"
        ;
        DW      L1EDC           ; ZEROTIMEB do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $F0             ; 240 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L221F           ; VGER-OUT do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LC292:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      LBDB2           ; ?? do "get CURRENT NOWR"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L1E63           ; OR-ON do "Turn OR writes ON in Magic ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LBC6B           ; for RED BALL pattern to Draw with
        ;
        DW      L1BE2           ; ANIM! do Set up RED BALL Pattern for DEMO Screen
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FD4E           ; for Word ?? for ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ; BEGIN loop #1
LC2AB:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FD4E           ; for Word ?? for ?? in Static RAM
        ;
        DW      L0442           ; 1+B! do "Pop HL, ADD 1 to (HL)"
        ; BEGIN loop #2
LC2B1:  DW      LBEAC
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FD4F           ; for Word ?? for ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; END #2 or loop to BEGIN #2 if False
        DW      L03CD,LC2B1     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      LBE98
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FD4E           ; for Word ?? for ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; CASE "TEST State = 1 and Skip Over if False ?? or Continue if True"
        DW      L0427,LC2E8     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF83
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for ??
        ;
        DW      L1D28
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00D8           ; do "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      LBCA7           ; ?? table ?? to form ROTO letter "R" again
        ;
        DW      LBDE6           ; ?? do "TerseCALL to Word in BASEXH (AND BASEY low ??)"
        ; (end of CASE = 1 so ...)
        DW      L03C5,LC33D     ; TerseJUMP to THENs
        ; (Case = 1 ELSE label)
LC2E8:  DW      L04ED           ; 2 "BYTE Pusher" for ??
        ; CASE "TEST State = 2 and Skip Over if False ?? or Continue if True"
        DW      L0427,LC302     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00D8           ; do "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      LBCE3           ; ?? table ?? to form ROTO letter "O" again
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFDE
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L1D28
        ;
        DW      LBDE6           ; ?? do "TerseCALL to Word in BASEXH (AND BASEY low ??)"
        ; (end of CASE = 2 so ...)
        DW      L03C5,LC33D     ; TerseJUMP to THENs
        ; (Case = 2 ELSE label)
LC302:  DW      L04EF           ; 3 "BYTE Pusher" for ??
        ; CASE "TEST State = 3 and Skip Over if False ?? or Continue if True"
        DW      L0427,LC31B     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00D8           ; do "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      LBD27           ; ?? table ?? to form ROTO letter "T" again
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L1D28
        ;
        DW      LBDE6           ; ?? do "TerseCALL to Word in BASEXH (AND BASEY low ??)"
        ; (end of CASE = 3 so ...)
        DW      L03C5,LC33D     ; TerseJUMP to THENs
        ; (Case = 3 ELSE label)
LC31B:  DW      L04F1           ; 4 "BYTE Pusher" for ??
        ; CASE "TEST State = 4 and Skip Over if False ?? or Continue if True"
        DW      L0427,LC33B     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00D8           ; do "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      LBCE3           ; ?? table ?? to form ROTO letter "O" twice again
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $86             ; 134 for ??
        ;
        DW      LBDB2           ; ?? do "get CURRENT NOWR"
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $64             ; 100 for ??
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L1D28
        ;
        DW      LBDE6           ; ?? do "TerseCALL to Word in BASEXH (AND BASEY low ??)"
        ; (end of CASE = 4 so ...)
        DW      L03C5,LC33D     ; TerseJUMP to THENs
        ; (Case = 4 ELSE label) !! no CASE found so Take a NAP !!
LC33B:  DW      L1670           ; SLEEP do ??
        ; THENs for 4 CASEs
LC33D:  DW      L1DBB
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; END #1 or loop to BEGIN #1 if False
        DW      L03CD,LC2AB     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LC349:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $7F             ; note: for setting &(COL0L)=127 to Bright YELLOW
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for &(4)=127 as COL0L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $F1             ; note: for setting &(COL1L)=225 to Dim BLUE
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for &(5)=225 as COL1L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L1E3A           ; XPAND!-OFF do "Turn eXPAND ?? OFF"
        ;
        DW      L00BC           ; JHOS-F "pushWORD to System stack"
        DW      L2851           ; for SAD-captured-HOSTAGE-in-box pattern
        ;
        DW      L1BE2           ; ANIM! do Set up CAPTURED HOSTAGE Pattern for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $64             ; 100 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEC
        ;
        DW      L1D28
        ;
        DW      L1DD4
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEC
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEC
        ;
        DW      L1D28
        ;
        DW      L1DD4
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCAB           ; for Word ?? in Static RAM
        ;
        DW      LC292
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" set to BLACK
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for &(6)=0 as COL2L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does COLorSET with 4 Colors PUSHed on the System stack beforehand
LC389:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04F7           ; 7 "BYTE Pusher" to set &(COL3L)=??
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L04F5           ; 6 "BYTE Pusher" to set &(COL2L)=??
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" to set &(COL1L)=??
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" to set &(COL0L)=??
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $6B             ; note: for setting &(HORCB)=64 + 43 words
        ;
        DW      L04FB           ; 8 "BYTE Pusher" for &(9)=107 with Border as Color 1
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ?? to Initalize DEMO Screen
LC3A3:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L333D           ; PUP do ??
        ;
        DW      L2215           ; BREAK do "null Terse subroutine" ??
        ;
        DW      LBDBC           ; ?? do "CLEAR $01B0 bytes from $FB8B through $FD3A"
        ;
        DW      LBEBB           ; ?? do "FILL Screen with Color 1 Bytes" for B:UE Screen !!
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE3A           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $4A             ; note: for setting &(COL0L)=74 (ATTRACT screen)
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for &(COL1L)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $FA             ; note: for setting &(COL2L)=250
        ;
        DW      L0513           ; 126 "BYTE Pusher" for &(COL3L)=126 (hex $7E)
        ;
        DW      LC389           ; ?? do "COLorSET with 4 Colors above"
        ;
        DW      L00BC           ; VSEN "pushWORD to System stack"
        DW      $FDB1           ; for Word ?? for ?? in Static RAM
        ;
        DW      L3C04           ; TRY-PA do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCF3           ; for Word ?? in Static RAM
        ;
        DW      LC0D1
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCAB           ; for Word ?? in Static RAM
        ;
        DW      LC349
        ;
        DW      L2218           ; TT do "First Interrupt Routine then More of Third"
        ;
        DW      L00B0           ; ... TerseRETurn

; junk ?? at end of DEMO Screeen code
        ADC     A,L             ; ?? $8C


; Fifteen MORE Text strings (CHARACTERS, ASCII non-terminate)
LC3D5:  DB      $10,"MAXIMUM HOSTAGES"
LC3E6:  DB      $13,"SAVED IN ONE TRIP ="
        ;
LC3FA:  DB      $13,"TREASURES RECOVERED"
        ;
LC40E:  DB      $0C,"DOUBLE SCORE"
LC41B:  DB      $09,"NEXT MAZE"
LC425:  DB      $0C,"TRIPLE SCORE"
        ;
LC432:  DB      $0B,"BONUS TOTAL"
        ;
LC43E:  DB      $01,"X"         ; (used twice)
LC440:  DB      $01,"1"
LC442:  DB      $01,"2"
LC444:  DB      $01,"3"
LC446:  DB      $01,"4"
LC448:  DB      $1C,"RESCUE MISSION     COMPLETED"
        ;
LC465:  DB      $0A,"3 HOSTAGES"
LC470:  DB      $0E,"SAVED TOGETHER"

; ?? does ?? start of code for END of LEVEL Scren
LC47F:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB6C           ; for Word ?? in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LC488:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB6C           ; for Word ?? in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LC491:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB5E           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      LBDD8           ; ?? do "TEST (SP) EQUAL 1"
        ; IF False to ELSE
        DW      L03CD,LC4A6     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; $E401 "pushWORD to System stack"
        DW      $E401           ; for "TOP Half of x21 + 1" in NON-protected NV RAM
        ; (done so Jump to THEN)
        DW      L03C5,LC4AA     ; TerseJUMP to ??
        ; ELSE
LC4A6:  DW      L00BC           ; $E400 do "pushWORD to System stack" (could use WORD Pusher !!)
        DW      $E400           ; for "TOP Half of x21" base (in NON-protected NV RAM)
        ; THEN
LC4AA:  DW      L00B0           ; ... TerseRETurn

; ?? does ??
LC4AC:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB87           ; for Word ?? in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB89           ; for Word ?? in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LC4BB:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB87           ; for Word ?? in Static RAM
        ;
        DW      L0133           ; ZERO do "Pop HL, word 00->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB89           ; for Word ?? in Static RAM
        ;
        DW      L0133           ; ZERO do "Pop HL, word 00->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LC4CA:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB7F           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB6F           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00B0           ; ... TerseRETurn

; NULL routine
LC4E5:  RET

; LC4E6: would do "Terse exit"
        JP      (IY)            ; indexed RETurn
; end of ?? SCREEN code ??

; ?? does ??
LC4E8:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; ' PATTY "pushWORD to System stack"
        DW      $3FF8           ; point to ?? in ROM ?? NOT Terse code ??
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      LC4E5           ; do "NULL routine"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LC4F3:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L1F52           ; EVEN-SPACE-NUMS do "load $FE3C with Byte 6 for ??"
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFD8           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC4           ; for Word ?? in Static RAM
        ;
        DW      L1D28
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $48             ; 72 for Double-sized Color 2 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      LC4BB
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB6E           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; IF False skip to THEN
        DW      L03CD,LC521     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB6F           ; for Word ?? in Static RAM
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ; THEN
LC521:  DW      LC47F
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB87           ; for Word ?? in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFD8           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC4           ; for Word ?? in Static RAM
        ;
        DW      L1D28
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $48             ; 72 for Double-sized Color 2 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      LC4AC
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB7F           ; for Word ?? in Static RAM
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for ??
        ;
        DW      L2125           ; BIN->ASC do "CONVERT BINary Number to ASCII Text String"
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB7F           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB7F           ; for Word ?? in Static RAM
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L213E           ; 0SUPR do "REPLACE Leading Zeroes with SPACEs in Text String"
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      LC4CA
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB6E           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for Light GRAY
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for &(7)=6 as COL3L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for BLACK
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for &(7)=0 as COL3L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L1F49           ; NORMAL-SPACING do "load $FE3C with Byte 0 for ??"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LC57A:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L051D           ; 255 (or -1) "BYTE Pusher" for 11111111B pattern
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $48C0           ; 18624 for ?? in Screen RAM (near the Top !!)
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $373F           ; 14143 for ?? Count up to End of Screen RAM !!
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LC589:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L051D           ; 255 (or -1) "BYTE Pusher" for 11111111B pattern
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $4000           ; 16384 NORMEM for Start of Screen RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $373F           ; 14143 for Count up to End of Screen RAM - 2240 !!
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LC598:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEFF           ; COCKTAIL mode (bit 0 = 1 for P2 FLIPped !!)
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; IF False to ELSE
        DW      L03CD,LC5A9     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LC589
        ; (done so Jump to THEN)
        DW      L03C5,LC5AB     ; TerseJUMP to ??
        ; ELSE
LC5A9:  DW      LC57A
        ; THEN
LC5AB:  DW      L00B0           ; ... TerseRETurn

; ?? does ?? [item table overflow!!]
LC5AD:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      LC598
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB6E           ; for Word ?? in Static RAM
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB6C           ; for Word ?? in Static RAM
        ;
        DW      L0133           ; ZERO do "Pop HL, word 00->(HL)"
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB67           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; IF False to THEN #1
        DW      L03CD,LC653     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $48             ; 72 for Double-sized Color 2 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L1D28
        ;
        DW      LC491
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      LBDDF           ; ?? do "TEST (SP) GREATER Than 1"
        ; _IF False to ELSE #2
        DW      L03CD,LC5F1     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC425           ; for 12,"TRIPLE SCORE" string (spaced out)
        ; _(done so Jump to THEN #2)
        DW      L03C5,LC5F5     ; TerseJUMP to ??
        ; _ELSE #2
LC5F1:  DW      L00BC           ; do "pushWORD to System stack"
        DW      LC40E           ; for 12,"DOUBLE SCORE" string (spaced out)
        ; _THEN #2
LC5F5:  DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC41B           ; for 9,"NEXT MAZE" string (spaced out)
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFBF           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFD8           ; for Word ?? in Static RAM
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      LBD8A           ; ?? do "get CURRENT BASEYH"
        ;
        DW      L0133           ; ZERO do "Pop HL, word 00->(HL)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for Color 3 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC465           ; for 10,"3 HOSTAGES" string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFD8           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3C             ; 60 for ??
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC470           ; for 14,"SAVED TOGETHER" string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC4           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $28             ; 40 for ??
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L1EDC           ; ZEROTIMEB do ??
        ;
        DW      L3B88           ; SUCK-S do ??
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for Light GRAY
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for &(7)=6 as COL3L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      LBEAC
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for BLACK
        ;
        DW      L04F7           ; 7 "BYTE Pusher" for &(7)=0 as COL3L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      LBEB3
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      LC598
        ;
        DW      L32F3           ; SHUTUP does "SHUT UP all sounds"
        ; THEN #1
LC653:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for Color 3 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC448           ; for 28,"RESCUE MISSION     COMPLETED" string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF92           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3C             ; 60 for ??
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      LC4BB
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB5F           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB87           ; for Word ?? in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for Color 1 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      LC4AC
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB77           ; for Word ?? in Static RAM
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L2125           ; BIN->ASC do "CONVERT BINary Number to ASCII Text String"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB77           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB77           ; for Word ?? in Static RAM
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L213E           ; 0SUPR do "REPLACE Leading Zeroes with SPACEs in Text String"
        ;
        DW      L00BC           ; MSPDF "pushWORD to System stack" MINUS ??
        DW      $FFFB           ; offset -5 for ( Monster Fast SPeeD ) Variable
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3C             ; 60 for ??
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB64           ; for Word ?? in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      LC488
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCAB           ; for Word ?? in Static RAM
        ;
        DW      LC4F3
        ;
        DW      L3B88           ; SUCK-S do ??
        ;
        DW      LBEB3
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB67           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; CASE "TEST State = 1 and Skip Over if False ?? or Continue if True"
        DW      L0427,LC6CE     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC440           ; for 1,"1" string
        ; (end of CASE = 1 so ...)
        DW      L03C5,LC6EE     ; TerseJUMP to THENs
        ; (Case = 1 ELSE label)
LC6CE:  DW      L04ED           ; 2 "BYTE Pusher" for ??
        ; CASE "TEST State = 2 and Skip Over if False ?? or Continue if True"
        DW      L0427,LC6DC     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC442           ; for 1,"2" string
        ; (end of CASE = 2 so ...)
        DW      L03C5,LC6EE     ; TerseJUMP to THENs
        ; (Case = 2 ELSE label)
LC6DC:  DW      L04EF           ; 3 "BYTE Pusher" for ??
        ; CASE "TEST State = 3 and Skip Over if False ?? or Continue if True"
        DW      L0427,LC6EA     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC444           ; for 1,"3" string
        ; (end of CASE = 3 so ...)
        DW      L03C5,LC6EE     ; TerseJUMP to THENs
        ; (Case = 3 ELSE label) !! no CASE found so use this Text string !!
LC6EA:  DW      L00BC           ; do "pushWORD to System stack"
        DW      LC446           ; for 1,"4" string
        ; THENs for 3 CASEs
LC6EE:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB62           ; for Word ?? in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $48             ; 72 for Double-sized Color 2 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC432           ; for 11,"BONUS TOTAL" string (spaced out)
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC4           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFE2           ; for Word ?? in Static RAM
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB60           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; IF False to THEN #3
        DW      L03CD,LC81E     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for Color 2 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      LC4BB
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB64           ; for Word ?? in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      LC491
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB87           ; for Word ?? in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      LC4AC
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB77           ; for Word ?? in Static RAM
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L2125           ; BIN->ASC do "CONVERT BINary Number to ASCII Text String"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB77           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB77           ; for Word ?? in Static RAM
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L213E           ; 0SUPR do "REPLACE Leading Zeroes with SPACEs in Text String"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5A             ; 90 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $19             ; 25 for ??
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      LBEA3
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB60           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ; _IF False to ELSE #4
        DW      L03CD,LC7CD     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0208           ; do "TEST ZERO Greater Than (SP) return in (SP)"
        ; __IF False skip to THEN #5
        DW      L03CD,LC77F     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L281D           ; for TREASURE CLOVER #3 pattern
        ;
        DW      L1BE2           ; ANIM! do Set up TREASURE CLOVER Pattern for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $19             ; 25 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ;
        DW      L1D28
        ;
        DW      L1DD4
        ; __THEN #5
LC77F:  DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      LBDDF           ; ?? do "TEST (SP) GREATER Than 1"
        ; __IF False skip to THEN #6
        DW      L03CD,LC797     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L2740           ; for TREASURE FLOWER pattern #3
        ;
        DW      L1BE2           ; ANIM! do Set up TREASURE FLOWER Pattern for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $27             ; 39 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ;
        DW      L1D28
        ;
        DW      L1DD4
        ; __THEN #6
LC797:  DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ; __IF False to THEN #7
        DW      L03CD,LC7B1     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L27B8           ; for TREASURE DIAMOND pattern #3
        ;
        DW      L1BE2           ; ANIM! do Set up TREASURE DIAMOND Pattern for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $31             ; 49 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ;
        DW      L1D28
        ;
        DW      L1DD4
        ; __THEN #7
LC7B1:  DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ; __IF False to THEN #8
        DW      L03CD,LC7C9     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L26BB           ; for TREASURE WEB pattern #3
        ;
        DW      L1BE2           ; ANIM! do Set up TREASURE WEB Pattern for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3D             ; 61 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ;
        DW      L1D28
        ;
        DW      L1DD4
        ; __THEN #8 and (done so Jump to THEN #4)
LC7C9:  DW      L03C5,LC7CF     ; TerseJUMP to ??
        ; _ELSE #4
LC7CD:  DW      L00F6           ; DROP do "Pop HL from System stack"
        ; _THEN #4
LC7CF:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB64           ; for Word ?? in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB60           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      LC491
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      LC47F
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      LC488
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB60           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L3BC6
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCAB           ; for Word ?? in Static RAM
        ;
        DW      LC4F3
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for Color 1 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC3FA           ; for 19,"TREASURES RECOVERED" string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF74           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $19             ; 25 for ??
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC43E           ; for 1,"X" string
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 for BYTEPL ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $19             ; 25 for ??
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      LBEB3
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ; THEN #3
LC81E:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB67           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB61           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB64           ; for Word ?? in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB60           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB64           ; for Word ?? in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      LC491
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB67           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      LC488
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $44             ; 68 for Double-sized Color 1 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB62           ; for Word ?? in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $28             ; 40 for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC43E           ; for 1,"X" string
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3C             ; 60 for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for Color 1 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC3D5           ; for 16,"MAXIMUM HOSTAGES" string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF74           ; for Word ?? in Static RAM
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC3E6           ; for 19,"SAVED IN ONE TRIP =" string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF74           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF6           ; MYFLAG - ASSMSV (84 - 94) = -10 MINUS !!
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB67           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L3BBB
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCAB           ; for Word ?? in Static RAM
        ;
        DW      LC4F3
        ;
        DW      LBEB3
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      LC491
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      LBDDF           ; ?? do "TEST (SP) GREATER Than 1"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB67           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ; IF False to ELSE #9
        DW      L03CD,LC8C9     ; [last here !!] ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      LC491
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; (done so Jump to THEN #9)
        DW      L03C5,LC8E3     ; TerseJUMP to ??
        ; ELSE #9
LC8C9:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB67           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; _IF False to ELSE #10
        DW      L03CD,LC8DF     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LC491
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ; _(done so Jump to THEN #10)
        DW      L03C5,LC8E3     ; TerseJUMP to ??
        ; _ELSE #10
LC8DF:  DW      LC491
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ; THEN #9 and THEN #10
LC8E3:  DW      L1EDC           ; ZEROTIMEB do ??
        ;
        DW      LC47F
        ;
        DW      LC4E8
        ;
        DW      LBEB3
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0417           ; MOD do "MODulo divide (SP+2) by (SP), Push REMAIDER and discard QUOTIENT"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; IF False skip to THEN #11
        DW      L03CD,LC904     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $78             ; 120 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ; THEN #11
LC904:  DW      L221F           ; VGER-OUT do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LC908:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L333D           ; PUP do ??
        ;
        DW      LBDBC           ; ?? do "CLEAR $01B0 bytes from $FB8B through $FD3A"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE3A           ; for Word ?? in Static RAM
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $FA             ; note: for setting &(COL0L)=250 (unknown screen)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $4A             ; note: for setting &(COL1L)=74
        ;
        DW      L0513           ; 126 "BYTE Pusher" for &(COL2L)=126 (hex $7E)
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for &(COL3L)
        ;
        DW      LC389           ; ?? do "COLorSET with 4 Colors above"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $EC             ; 236 for HORCB (44 + 192 for BC = COLOR 3)
        ;
        DW      L04FB           ; 9 "BYTE Pusher" for &(9)=236 as HORCB
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L0178           ; ABS do "ABSolute Value Top of System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB60           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L0178           ; ABS do "ABSolute Value Top of System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB67           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB5E           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L0155           ; 1- do "DECrement Top of System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB5F           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L0217           ; -DUP do "DUPlicate Top of System stack IF Not Zero"
        ;  IF False to ELSE
        DW      L03CD,LC961     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $C8             ; 200 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ; (done so Jump to THEN)
        DW      L03C5,LC964     ; TerseJUMP to ??
        ; ELSE
LC961:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $64             ; 100 for ??
        ; THEN
LC964:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB64           ; for Word ?? in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCF3           ; for Word ?? in Static RAM
        ;
        DW      LC5AD
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB8B           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; ' FLSHT "pushWORD to System stack"
        DW      $3FF6           ; 16374 for ?? in ROM ?? NOT Terse code ??
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      LC4E5           ; do "NULL routine"
        ;
        DW      L2218           ; TT do "First Interrupt Routine then More of Third"
        ;
        DW      LC491
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L074B           ; SC* do "get SCore MULT for CURRENT player"
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? GAMEPLAY Screen text strings ??
LC988:  DB      $0A,"MAGIC ROTO"
LC993:  DB      $18,"1. RUNS THROUGH MONSTERS"
LC9AC:  DB      $1D,"2. GOES THROUGH A LOCKED DOOR"
LC9CA:  DB      $1E,"3. TOUCHES THE DREADED     AND"
LC9E9:  DB      $1B,"   REMOVES IT FROM THE MAZE"
LCA05:  DB      $12,"ONE MAGIC PER MAZE"
LCA18:  DB      $1F,"MAGIC CAN BE SAVED UNTIL NEEDED"
        ;
; LCA38: Not used ?? (see LC3D5 and LC3E6 !!)
        DB      $24,"MAXIMUM HOSTAGES REMOVED IN 1 TRIP ="
        ;
LCA5D:  DB      $15,"PRESS 1 PLAYER BUTTON"
LCA73:  DB      $02,"OR"
LCA76:  DB      $15,"PRESS 2 PLAYER BUTTON"
LCA8C:  DB      $1F,"DEPOSIT COINS FOR 2 PLAYER GAME"
        ;
LCAAC:  DB      $09,"FREE PLAY"
        ;
LCAB6:  DB      $07,"CREDITS"

; ?? does ?? start of ?? code for GAMEPLAY Screen
LCABE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $55             ; 85 for Search pattern 01010101B
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $4000           ; 16384 NORMEM for Start of Screen RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $3FFF           ; 16383 NORMEM - 1 for Count to End of Screen RAM
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCACE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ?? TEST for FREE PLAY if returns True
LCAD5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $13             ; for =&(19) aka OPTIONS SW3 read
        ;
        DW      L02E3           ; INP do "Pop BC, INPort L,(C) byte, Push 0,L word"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" to MASK bit 2 not FREEPlay
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCAE3:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" to Clear
        ;
        DW      L1EBE           ; MAGIC! do "Load MAGIC value ??"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for Color 1 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LCA5D           ; point to 21,"PRESS 1 PLAYER BUTTON"
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFD8           ; for Word ?? in Static RAM
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L1D10           ; Y! do ??
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCB06:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      LCAE3
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ?? for Color 1 on Color 0
        ;
        DW      L1E24           ; XPAND! ?? do "Load eXPAND value ?? but DON'T turn it ON yet"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LCA73           ; point to 2,"OR" text string
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF8           ; for Word ?? in Static RAM
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC9           ; for Word ?? in Static RAM
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L1D10           ; Y! do ??
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ?? for Color 1 on Color 0
        ;
        DW      L1E24           ; XPAND! ?? do "Load eXPAND value ?? but DON'T turn it ON yet"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LCA76           ; point to 21,"PRESS 2 PLAYER BUTTON"
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFBA           ; for Word ?? in Static RAM
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L1D10           ; Y! do ??
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCB43:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LCAD5           ; do TEST for FREE PLAY (returns True)
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; IF False to ELSE
        DW      L03CD,LCB9F     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for Color 3 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LCAB6           ; point to 7,"CREDITS"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF7E           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFA1           ; for Word ?? in Static RAM
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      LC4BB
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FA           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB87           ; for Word ?? in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      LC4AC
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB77           ; for Word ?? in Static RAM
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L2125           ; BIN->ASC do "CONVERT BINary Number to ASCII Text String"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB77           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00CD           ; do "Pop HL, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FB77           ; for Word ?? in Static RAM
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L213E           ; 0SUPR do "REPLACE Leading Zeroes with SPACEs in Text String"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFBA           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFA1           ; for Word ?? in Static RAM
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ; (done so Jump to THEN)
        DW      L03C5,LCBB4     ; TerseJUMP to ??
        ; ELSE
LCB9F:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for Color 3 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LCAAC           ; point to 9,"FREE PLAY"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF7E           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFA1           ; for Word ?? in Static RAM
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ; THEN
LCBB4:  DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCBB6:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $55             ; 85 for 01010101B pattern
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $6530           ; 25904 for Start near Bottom of Screen RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $1ACF           ; 6863 for Count to End of Screen RAM
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCBC6:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      LBD8A           ; ?? do "get CURRENT BASEYH"
        ;
        DW      L0133           ; ZERO do "Pop HL, word 00->(HL)"
        ; BEGIN loop
LCBCD:  DW      LBD8A           ; ?? do "get CURRENT BASEYH"
        ;
        DW      L02C6           ; do "Pop HL, INCrement (HL) word"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FA           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB5B           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ; _IF False to THEN #1
        DW      L03CD,LCBF9     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FA           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB5B           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      LCBB6
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      LCB06
        ;
        DW      LCB43
        ; _THEN #1
LCBF9:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      LBD8A           ; ?? do "get CURRENT BASEYH"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; _IF False to THEN #2
        DW      L03CD,LCC26     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FA           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ;
        DW      LCAD5           ; do TEST for FREE PLAY (returns True)
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ; __IF False to THEN #3
        DW      L03CD,LCC26     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for Top LINE of Screen
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; for setting &(10)=0 as VERBL to HIDE entire Screen !!
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L221F           ; VGER-OUT do ??
        ; _THEN #2 and THEN #3
LCC26:  DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; END or loop to BEGIN if False
        DW      L03CD,LCBCD     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCC2E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L2C02           ; HOLLOW-facing-LEFT animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up HOLLOW Animation Loop for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF7E           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5A             ; 90 for ??
        ;
        DW      L1D28
        ; BEGIN loop
LCC44:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFD8           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5A             ; 90 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0190           ; 400 for ??
        ;
        DW      L1CD3
        ;
        DW      LBE05           ; ?? do "SET Starting ANGLE by VDX"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF7E           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5A             ; 90 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0190           ; 400 for ??
        ;
        DW      L1CD3
        ;
        DW      LBE05           ; ?? do "SET Starting ANGLE by VDX"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; END or loop to BEGIN if False
        DW      L03CD,LCC44     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCC6E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      LBEA3
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $2D             ; 45 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $2D             ; 45 for ??
        ;
        DW      L1D28
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3E21           ; for DIE animation table
        ;
        DW      L1BE2           ; ANIM! do Set up DIE Animation Loop for ??
        ;
        DW      L1D2F           ; ZERODXDYAXAY do ??
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCC8B:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L0538           ; DI do "Disable Interrupt"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FA           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB5B           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L053B           ; EI do "Enable Interrupt"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" to Clear
        ;
        DW      L1EBE           ; MAGIC! do "Load MAGIC value ??"
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for Color 2 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; CASE "TEST State = 0 and Skip Over if False ?? or Continue if True"
        DW      L0427,LCCE0     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $44             ; 68 for Double-sized Color 1 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LBD47           ; for 6,"INSERT" string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFDA           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFD8           ; for Word ?? in Static RAM
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $44             ; 68 for Double-sized X-OR Color 2 on Color 0
        ;
        DW      L1E24           ; XPAND! ?? do "Load eXPAND value ?? but DON'T turn it ON yet"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LBD4E           ; for 4,"COIN" string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFE2           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC4           ; for Word ?? in Static RAM
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L1E3A           ; XPAND!-OFF do "Turn eXPAND ?? OFF"
        ; (end of CASE = 0 so ...)
        DW      L03C5,LCD18     ; TerseJUMP to THENs
        ; (Case = 0 ELSE label)
LCCE0:  DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; CASE "TEST State = 1 and Skip Over if False ?? or Continue if True"
        DW      L0427,LCD14     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      LCAE3
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for Color 1 on Color 0
        ;
        DW      L1E24           ; XPAND! ?? do "Load eXPAND value ?? but DON'T turn it ON yet"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LCA73           ; point to 2,"OR" text string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF8           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC9           ; for Word ?? in Static RAM
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LCA8C           ; point to 31,"DEPOSIT COINS FOR 2 PLAYER GAME"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF88           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFBA           ; for Word ?? in Static RAM
        ;
        DW      LBE2C
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L1E3A           ; XPAND!-OFF do "Turn eXPAND ?? OFF"
        ; (end of CASE = 1 so ...)
        DW      L03C5,LCD18     ; TerseJUMP to THENs
        ; (Case = 1 ELSE label) !! no CASE found so do 0 then ??
LCD14:  DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      LCB06
        ; THENs for 2 CASEs
LCD18:  DW      LCB43
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FC1B           ; for Word ?? in Static RAM
        ;
        DW      LCBC6
        ;
        DW      L1670           ; SLEEP do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCD24:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for Top LINE of Screen
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; for setting &(10)=0 as VERBL to HIDE entire Screen !!
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for Color 1 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC988           ; point to 10,"MAGIC ROTO" text string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFE2           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $55             ; 85 for ??
        ;
        DW      LCACE
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for Color 2 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC993           ; point to 24,"1. RUNS THROUGH MONSTERS"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF7E           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $46             ; 70 for ??
        ;
        DW      LCACE
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC9AC           ; point to 29,"2. GOES THROUGH A LOCKED DOOR"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF7E           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $37             ; 55 for ??
        ;
        DW      LCACE
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC9CA           ; point to 30,"3. TOUCHES THE DREADED     AND"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF7E           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $28             ; 40 for ??
        ;
        DW      LCACE
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LC9E9           ; point to 27,"   REMOVES IT FROM THE MAZE"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF7E           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $19             ; 25 for ??
        ;
        DW      LCACE
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for Color 3 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LCA05           ; point to 18,"ONE MAGIC PER MAZE"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF9C           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      LCACE
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LCA18           ; point to 31,"MAGIC CAN BE SAVED UNTIL NEEDED"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF9C           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; MSPDF "pushWORD to System stack" MINUS ??
        DW      $FFFB           ; offset -5 for ( Monster Fast SPeeD ) Variable
        ;
        DW      LCACE
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L1E3A           ; XPAND!-OFF do "Turn eXPAND ?? OFF"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF88           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L1D28
        ;
        DW      L00BC           ; MAGM "pushWORD to System stack"
        DW      L82BE           ; 4-color "Remaining MAGIC Spells" (facing left) pattern
        ;
        DW      L1BE2           ; ANIM! do Set up MAGIC Spells Pattern for ??
        ;
        DW      L1DD4
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; OBJSV "pushBYTE to System stack"
        DB      $5D             ; offset 93 for ( OBJect State Variable )
        ;
        DW      L1D28
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L2947           ; for SPIDER pattern #3
        ;
        DW      L1BE2           ; ANIM! do Set up SPIDER Pattern for ??
        ;
        DW      L1DD4
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FC63           ; for Word ?? in Static RAM
        ;
        DW      LCC2E
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FBD3           ; for Word ?? in Static RAM
        ;
        DW      LCC6E
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $CB             ; for 203 as Bottom LINE of Screen
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; for setting &(10)=203 as VERBL to SHOW Screen
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCAB           ; for Word ?? in Static RAM
        ;
        DW      LCC8B
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ?? to Initalize GAMEPLAY Screen
LCDDB:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L333D           ; PUP do ??
        ;
        DW      LCABE
        ;
        DW      LBDBC           ; ?? do "CLEAR $01B0 bytes from $FB8B through $FD3A"
        ;
        DW      L0513           ; 126 "BYTE Pusher" for &(COL0L)=126 (hex $7E)
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for &(COL1L)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $FA             ; note: for setting &(COL2L)=250
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $52             ; note: for setting &(COL3L)=82
        ;
        DW      LC389           ; ?? do "COLorSET with 4 Colors above"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCF3           ; for Word ?? in Static RAM
        ;
        DW      LCD24
        ;
        DW      L00BC           ; VSEN "pushWORD to System stack"
        DW      $FDB1           ; for Word ?? for ?? in Static RAM
        ;
        DW      L3C04           ; TRY-PA do ??
        ;
        DW      L2218           ; TT do "First Interrupt Routine then More of Third"
        ;
        DW      L00B0           ; ... TerseRETurn

; end of GAMEPLAY code

; ?? BONUS Robby Roto text strings ??
LCDFE:  DB      $05,"BONUS"
LCE04:  DB      $04,"ROTO"
LCE09:  DB      $07,"MACHINE"

; ?? does ?? routine
LCE11:  LD      A,$57           ; 87 for ??
        AND     A
        LD      DE,$0050        ; 80 for BYTEs Per Line
        LD      B,$04
LCE19:  LD      (HL),A
        RLC     A
        RLC     A
LCE1E:  AND     A
        SBC     HL,DE
        DJNZ    LCE19                   ; (-$0a)
        RET

; ?? does ?? routine
LCE24:  LD      B,$14
LCE26:  LD      (HL),A
        ADD     HL,DE
        DJNZ    LCE26                   ; (-$04)
        RET

; ?? does ?? routine
LCE2B:  LD      A,$D5
        AND     A
        LD      DE,$0050        ; 80 for BYTEs Per Line
        LD      B,$04
LCE33:  LD      (HL),A
        RRC     A
        RRC     A
        AND     A
        SBC     HL,DE
        DJNZ    LCE33                   ; (-$0a)
        RET

; ?? does ?? routine
LCE3E:  LD      B,$06
LCE40:  LD      (HL),A
        INC     HL
        DJNZ    LCE40                   ; (-$04)
        RET

; ?? does ??
LCE45:  EXX
        LD      HL,$55FD        ; 22013 for ??
        LD      A,$D5
        LD      DE,$0050        ; 80 for BYTEs Per Line
        LD      B,$3C
LCE50:  LD      (HL),A
        ADD     HL,DE
        DJNZ    LCE50                   ; (-$04)
        LD      HL,$5612        ; 22034 for ??
        LD      B,$3C
LCE59:  LD      (HL),A
        ADD     HL,DE
        DJNZ    LCE59                   ; (-$04)
        LD      HL,$68C6        ; 26822 for ??
        CALL    LCE24
        LD      HL,$68CA        ; 26826 for ??
        CALL    LCE24
        LD      HL,$4FC6        ; 20422 for ??
        CALL    LCE24
        LD      HL,$4FCA        ; 20426 for ??
        CALL    LCE24
        LD      A,$FF
        LD      HL,$4E85        ; 20101 for ??
        CALL    LCE3E
        LD      HL,$6FF5        ; 28661 for ??
        CALL    LCE3E
        LD      HL,$55FD        ; 22013 for ??
        LD      B,$15
LCE88:  LD      (HL),A
        INC     HL
        DJNZ    LCE88                   ; (-$04)
        LD      HL,$68BD        ; 26813 for ??
        LD      B,$15
LCE91:  LD      (HL),A
        INC     HL
        DJNZ    LCE91                   ; (-$04)
        LD      HL,$4FC5        ; 20421 for ??
        CALL    LCE11
        LD      HL,$6FAA        ; 28586 for ??
        CALL    LCE11
        LD      HL,$6FA5        ; 28581 for ??
        CALL    LCE2B
        LD      HL,$4FCA        ; 20426 for ??
        CALL    LCE2B
LCEAD:  EXX
        JP      (IY)            ; indexed RETurn

; ?? does ??
LCEB0:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LCE45
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCEB5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB5A           ; for Word ?? in Static RAM
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCEBE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB59           ; for Word ?? in Static RAM
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCEC7:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LCDFE           ; point to 5,"BONUS" text string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEC           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      LBE2C
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for Color 3 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LCE04           ; point to 4,"ROTO" text string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFF2           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; MSPDF "pushWORD to System stack" MINUS ??
        DW      $FFFB           ; offset -5 for ( Monster Fast SPeeD ) Variable
        ;
        DW      LBE2C
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for Color 1 on Color 0
        ;
        DW      L1E24           ; XPAND! ?? do "Load eXPAND value ?? but DON'T turn it ON yet"
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LCE09           ; point to 7,"MACHINE" text string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFE7           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFEC           ; for Word ?? in Static RAM
        ;
        DW      LBE2C
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for Color 3 on Color 0
        ;
        DW      L1E24           ; XPAND! ?? do "Load eXPAND value ?? but DON'T turn it ON yet"
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      LBEA3
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCF0D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ; BEGIN loop #1
LCF10:  DW      LBEAC
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB59           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; END #1 or loop to BEGIN #1 if False
        DW      L03CD,LCF10     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L3A91
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB59           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ; BEGIN loop #2
LCF26:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $53             ; 83 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE41           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L04FD           ; 10 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $F6             ; 246 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE41           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L04FD           ; 10 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for BLACK
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for &(5)=0 as COL1L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L04FD           ; 10 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB5A           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; END #2 or loop to BEGIN #2 if False
        DW      L03CD,LCF26     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L32F3           ; SHUTUP does "SHUT UP all sounds"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB59           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCF64:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $C8             ; 200 for ??
        ;
        DW      L1CD3
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCF6C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0190           ; 400 for ??'
        ;
        DW      L1CD3
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCF75:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCF7C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      LCF75
        ;
        DW      L00BC           ; ROTROTY "pushWORD to System stack"
        DW      L2DC4           ; for "PAUSE then DIG ROTOS" animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGING ROTOS Animation Loop for ??
        ;
        DW      LBDF6           ; ?? do "SET Starting ANGLE = 128 (NorthWest !!)"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $23             ; 35 for ??
        ;
        DW      L1D28
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $32             ; 50 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L382C
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 for BYTEPL ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $03E8           ; 1000 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 for BYTEPL ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L1DBB
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LCFBF:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      LCF75
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3EE1           ; for 4 TEETH ?? DYING animation table
        ;
        DW      L1BE2           ; ANIM! do Set up TEETH ?? DYING Animation Loop for ??
        ;
        DW      L354D           ; JAW-S do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF9C           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      L1D28
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L1D2F           ; ZERODXDYAXAY do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $B4             ; 180 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L354D           ; JAW-S do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF9C           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L1DBB
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD003:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L1EDC           ; ZEROTIMEB do ??
        ;
        DW      LBDFE           ; ?? do "SET Starting ANGLE = 0 (North !!)"
        ;
        DW      LCF75
        ;
        DW      L00BC           ; ROTROTY "pushWORD to System stack"
        DW      L2DC4           ; for "PAUSE then DIG ROTOS" animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGING ROTOS Animation Loop for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFDD           ; for Word ?? in Static RAM
        ;
        DW      L1D28
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFCE           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $012C           ; 300 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L382C
        ;
        DW      L00BC           ; ROTROTY "pushWORD to System stack"
        DW      L2DC4           ; for "PAUSE then DIG ROTOS" animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGING ROTOS Animation Loop for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $03E8           ; 1000 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 for BYTEPL ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L1DBB
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD051:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      LBDF6           ; ?? do "SET Starting ANGLE = 128 (NorthWest !!)"
        ;
        DW      LCF75
        ;
        DW      L00BC           ; ROTROTY "pushWORD to System stack"
        DW      L2DC4           ; for "PAUSE then DIG ROTOS" animation loop
        ;
        DW      L1BE2           ; ANIM! do Set up DIGGING ROTOS Animation Loop for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 for BYTEPL ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 for BYTEPL ?? again
        ;
        DW      L1D28
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 for BYTEPL ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L3B88           ; SUCK-S do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $32             ; 50 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $03E8           ; 1000 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $23             ; 35 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      LCEBE
        ;
        DW      L1DBB
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $78             ; 120 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      LCEB5
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB58           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; IF False to ELSE
        DW      L03CD,LD0C4     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FBD3           ; for Word ?? in Static RAM
        ;
        DW      LCF7C
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB8B           ; for Word ?? in Static RAM
        ;
        DW      LCF7C
        ; (done so Jump to THEN)
        DW      L03C5,LD0D7     ; TerseJUMP to ??
        ; ELSE
LD0C4:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FBD3           ; for Word ?? in Static RAM
        ;
        DW      LD003
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB8B           ; for Word ?? in Static RAM
        ;
        DW      LD003
        ; THEN
LD0D7:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $A0             ; 160 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L221F           ; VGER-OUT do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD0E2:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      LCF75
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3EE1           ; for 4 TEETH ?? DYING animation table
        ;
        DW      L1BE2           ; ANIM! do Set up TEETH ?? DYING Animation Loop for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $23             ; 35 for ??
        ;
        DW      L1D28
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $32             ; 50 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $012C           ; 300 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      LBEAC
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L3B88           ; SUCK-S do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5A             ; 90 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $05DC           ; 1500 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L1DBB
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $B4             ; 180 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L221F           ; VGER-OUT do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD128:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      LCF75
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L3EE1           ; for 4 TEETH ?? DYING animation table
        ;
        DW      L1BE2           ; ANIM! do Set up TEETH ?? DYING Animation Loop for ??
        ;
        DW      L354D           ; JAW-S do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 for BYTEPL ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 for BYTEPL ?? again
        ;
        DW      L1D28
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 for BYTEPL ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $01F4           ; 500 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $32             ; 50 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $03E8           ; 1000 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $23             ; 35 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $012C           ; 300 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L1DBB
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $AA             ; for 170 (or 10101010B 4-pixels of Color 2 ??)
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCAB           ; for Word ?? in Static RAM
        ;
        DW      LD0E2
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD17C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L1E8A           ; FLOP-ON does "Turn FLOPped writes ON in Magic ??"
        ;
        DW      LCF75
        ;
        DW      L00BC           ; MAGM "pushWORD to System stack"
        DW      L82BE           ; 4-color "Remaining MAGIC Spells" (facing left) pattern
        ;
        DW      L1BE2           ; ANIM! do Set up MAGIC Spells pattern for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFDD           ; for Word ?? in Static RAM
        ;
        DW      L1D28
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFCE           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $012C           ; 300 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L382C
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $03E8           ; 1000 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L382C
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFBA           ; for Word ?? in Static RAM
        ;
        DW      LCF64
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      LCF6C
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L382C
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFBA           ; for Word ?? in Static RAM
        ;
        DW      LCF64
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $28             ; 40 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      LCF6C
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L382C
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $32             ; 50 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFBA           ; for Word ?? in Static RAM
        ;
        DW      LCF64
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3C             ; 60 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      LCF6C
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L382C
        ;
        DW      L1DBB
        ;
        DW      LBECB
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD1FF:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L1EDC           ; ZEROTIMEB do ??
        ;
        DW      LCF75
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L8000           ; for TROLL Pattern #1
        ;
        DW      L1BE2           ; ANIM! do Set up TROLL pattern for ??
        ;
        DW      L1E7D           ; FLIP-ON do "Turn FLIPped writes ON in Magic ??"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFDD           ; for Word ?? in Static RAM
        ;
        DW      L1D28
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFCE           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $012C           ; 300 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L3B88           ; SUCK-S do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB0           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0258           ; 600 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $78             ; 120 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L1DBB
        ;
        DW      L221F           ; VGER-OUT do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD241:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      LCF75
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L8078           ; for TROLL animation table
        ;
        DW      L1BE2           ; ANIM! do Set up TROLL Animation Loop for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $32             ; 50 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 for BYTEPL ??
        ;
        DW      L1D28
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $50             ; 80 for BYTEPL ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $FA             ; 250 for ??
        ;
        DW      L1CD3
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L35E7           ; DRUG-S do ??
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L3B88           ; SUCK-S do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $32             ; 50 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $03E8           ; 1000 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $23             ; 35 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $012C           ; 300 for ??
        ;
        DW      L1CD3
        ;
        DW      L1901           ; ZGO do "load master VMR routine and special SUR ??"
        ;
        DW      LCEBE
        ;
        DW      L1DBB
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5A             ; 90 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      LCEB5
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FBD3           ; for Word ?? in Static RAM
        ;
        DW      LD003
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB8B           ; for Word ?? in Static RAM
        ;
        DW      LD003
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $28             ; 40 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCAB           ; for Word ?? in Static RAM
        ;
        DW      LD17C
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $78             ; 120 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FC1B           ; for Word ?? in Static RAM
        ;
        DW      LD1FF
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD2C3:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $55             ; 85 for 01010101B pattern
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $4000           ; NORMEM for Start of Screen RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $3FFF           ; NORMEM - 1 to Count to End of Screen RAM
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD2D3:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L333D           ; PUP do ??
        ;
        DW      LBDBC           ; ?? do "CLEAR $01B0 bytes from $FB8B through $FD3A"
        ;
        DW      L0513           ; 126 "BYTE Pusher" for &(COL0L)=126 (hex $7E)
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for &(COL1L)
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $FA             ; note: for setting &(COL2L)=250
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $4A             ; note: for setting &(COL3L)=74
        ;
        DW      LC389           ; ?? do "COLorSET with 4 Colors above"
        ;
        DW      LD2C3
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB59           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L32F3           ; SHUTUP does "SHUT UP all sounds"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE3A           ; for Word ?? in Static RAM
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB59           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB5A           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB58           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      LCEB0
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB8B           ; for Word ?? in Static RAM
        ;
        DW      LCEC7
        ;
        DW      L0730           ; GA# do "get GAme # for CURRENT player"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for ??
        ;
        DW      L0408           ; MIN does "keep only MINimum of Top 2 on System Stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for ??
        ; CASE "TEST State = 12 and Skip Over if False ?? or Continue if True"
        DW      L0427,LD33C     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCF3           ; for Word ?? in Static RAM
        ;
        DW      LD051
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCAB           ; for Word ?? in Static RAM
        ;
        DW      LCFBF
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FC63           ; for Word ?? in Static RAM
        ;
        DW      LCF0D
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB58           ; for Word ?? in Static RAM
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ; (end of CASE = 12 so ...)
        DW      L03C5,LD386     ; TerseJUMP to THENs
        ; (Case = 12 ELSE label)
LD33C:  DW      L04FB           ; 9 "BYTE Pusher" for ??
        ; CASE "TEST State = 9 and Skip Over if False ?? or Continue if True"
        DW      L0427,LD358     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCF3           ; for Word ?? in Static RAM
        ;
        DW      LD051
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCAB           ; for Word ?? in Static RAM
        ;
        DW      LD128
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FC63           ; for Word ?? in Static RAM
        ;
        DW      LCF0D
        ; (end of CASE = 9 so ...)
        DW      L03C5,LD386     ; TerseJUMP to THENs
        ; (Case = 9 ELSE label)
LD358:  DW      L04F5           ; 6 "BYTE Pusher" for ??
        ; CASE "TEST State = 6 and Skip Over if False ?? or Continue if True"
        DW      L0427,LD36E     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCF3           ; for Word ?? in Static RAM
        ;
        DW      LD241
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FC63           ; for Word ?? in Static RAM
        ;
        DW      LCF0D
        ; (end of CASE = 6 so ...)
        DW      L03C5,LD386     ; TerseJUMP to THENs
        ; (Case = 6 ELSE label)
LD36E:  DW      L04EF           ; 3 "BYTE Pusher" for ??
        ; CASE "TEST State = 3 and Skip Over if False ?? or Continue if True"
        DW      L0427,LD384     ; ConditionalPUSH (SP+2) and JUMP only IF "(SP) <> (SP+2)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCF3           ; for Word ?? in Static RAM
        ;
        DW      LD051
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FC63           ; for Word ?? in Static RAM
        ;
        DW      LCF0D
        ; (end of CASE = 3 so ...)
        DW      L03C5,LD386     ; TerseJUMP to THENs
        ; (Case = 3 ELSE label) !! no CASE found so do VGER-OUT !!
LD384:  DW      L221F           ; VGER-OUT do ??
        ; THENs for 4 CASEs
LD386:  DW      L2218           ; TT do "First Interrupt Routine then More of Third"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does TEST (SP) > (SP+2) from FORTH, or ...
LD38A:  POP     DE
        POP     HL
LD38C:  XOR     A
        SBC     HL,DE
        LD      HL,$0000        ; 0 for FALSE
        JR      NC,LD395                ; (+$01)
        INC     HL              ; 1 for TRUE
LD395:  PUSH    HL
        JP      (IY)            ; indexed RETurn

; ... does TEST (SP) < (SP+2) from FORTH
LD398:  POP     HL
        POP     DE
        JP      LD38C

; HIGH SCORE Text strings
LD39D:  DB      $0C,"HALL OF FAME"
LD3AA:  DB      $14,"PROUDLY PRESENTS ITS"

; ?? does "set Left colors then HORCB"
LD3BF:
        LD      A,$4A
        OUT     (COL0L),A       ; &(4)=74 for RED COLor 0 Left background
        XOR     A
        OUT     (COL1L),A       ; &(5)=0 for BLACK COLor 1 Left and BORDER Color
        LD      A,$7E
        OUT     (COL2L),A       ; &(6)=126 for YELLOW COLor 2 Left
        LD      A,$FB
        OUT     (COL3L),A       ; &(7)=251 for BLUE COLor 3 Left
        LD      A,$6C
        OUT     (HORCB),A       ; &(9)=108 for HORCB at Right and Border Color = Color 1
        JP      (IY)            ; indexed RETurn

; ?? does ?? start of ?? code for HIGH SCORE Screen
LD3D4:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; MONV2 "pushWORD to System stack"
        DW      $FB47           ; for "MONster Vector" #2 base in Static RAM
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? a text string for Top of HIGH SCORE screen
LD3DF:  DB      $15,"BALLY/MIDWAY MFG. CO."

; ?? does ??
LD3F5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L203B           ; STRING do "READ then DRAW CHARacter(s)"
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD405:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD40A:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ; BEGIN loop
LD40D:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $3C             ; 60 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB49           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; _IF False to THEN
        DW      L03CD,LD428     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB49           ; for Word ?? in Static RAM
        ;
        DW      L0448           ; 1-B! do "Pop HL, SUBtract 1 from (HL)"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; _THEN and END or loop to BEGIN if False
LD428:  DW      L03CD,LD40D     ; ConditionalJUMP to Loop until ??
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD436:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $2A30           ; 10800 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCAB           ; for Word ?? in Static RAM
        ;
        DW      LD405
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD451:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L02ED           ; ROT do "Pop DE, Pop HL, EX (SP),HL then Push DE, Push (Old SP) to New System stack"
        ;
        DW      L00EE           ; 2DUP do "duplicate top 2 Words of System stack"
        ;
        DW      LD38A           ; do "TEST (SP) > (SP+2)"
        ; IF False to ELSE #1
        DW      L03CD,LD466     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L02FE           ; 2DROP do "Pop HL, Pop HL" to clean up System Stack
        ;
        DW      L02FE           ; 2DROP do "Pop HL, Pop HL" to clean up System Stack
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; (done so Jump to THEN #1)
        DW      L03C5,LD482     ; TerseJUMP to ??
        ; ELSE #1
LD466:  DW      LD398           ; do "TEST (SP) < (SP+2)"
        ; IF False to ELSE #2
        DW      L03CD,LD474     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L02FE           ; 2DROP do "Pop HL, Pop HL" to clean up System Stack
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; (done so Jump to THEN #2)
        DW      L03C5,LD482     ; TerseJUMP to ??
        ; ELSE #2
LD474:  DW      LD398           ; do "TEST (SP) < (SP+2)
        ; IF False to ELSE #3
        DW      L03CD,LD480     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ; (done so Jump to THEN #3)
        DW      L03C5,LD482     ; TerseJUMP to ??
        ; ELSE #3
LD480:  DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; THEN #1, THEN #2 and THEN #3
LD482:  DW      L00B0           ; ... TerseRETurn

; ?? does LOOK UP High Score INITIALS by (SP) = #1 to #21
LD484:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for WHICH column of High Scores to use
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; IF False to ELSE
        DW      L03CD,LD49A     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0155           ; 1- do "DECrement Top of System stack" #1 to #11 shifted down
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3C7           ; for Word base of HIGH SCORE INITials Text in NV RAM
        ; (done so Jump to THEN)
        DW      L03C5,LD4A3     ; TerseJUMP to ??
        ; ELSE
LD49A:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for #12 to #21 shifted down
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E361           ; for Word base HIGH SCORES+12 INITials Text in NV RAM
        ; THEN
LD4A3:  DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for quantum trio of initials
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM" for CHARs
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does COPY trio of INITIALS into ??
LD4AD:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LD484           ; do LOOKUP High Score INITIALS by (SP)
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack" ??+1
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for INITials
        ;
        DW      L07E5           ; do COPY Bytes count (SP+4) in (SP+2) into (SP) WRITE-protected
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ?? Initalize PRINT of trio of INITIALS
LD4BE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LD484           ; do LOOKUP High Score INITIALS by (SP)
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack" ??+1
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for Bytes to COPY from ?? to ??
        ;
        DW      L0241           ; BMOVE do "Pop BC, Pop DE, Pop HL, LDIR IF BC Not Zero"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for Text Length
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does LOOK UP High Score VALUES by (SP) = #1 to #21
LD4D5:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for WHICH column of High Scores to use
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; IF False to ELSE
        DW      L03CD,LD4EB     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0155           ; 1- do "DECrement Top of System stack" #1 to #11 shifted down
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E39B           ; for Word base of HIGH SCORE Numbers in NV RAM
        ; (done so Jump to THEN)
        DW      L03C5,LD4F4     ; TerseJUMP to ??
        ; ELSE
LD4EB:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for #12 to #21 shifted down
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E339           ; for Word base of HIGH SCORE+12 Numbers in NV RAM
        ; THEN
LD4F4:  DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for quantum 4 Bytes of Values
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does PUSH 2 Words of High Score VALUE by (SP) = #1 to #21
LD4FE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LD4D5           ; do LOOKUP High Score VALUES by (SP)
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L015F           ; 2+ do "ADD 2 to Top of System stack"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00B0           ; ... TerseRETurn with 2 HIGH SCORE Words on Top of Stack

; ?? does COPY 2 words of High Score VALUE into ?? WRITE-protected
LD50D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      LD4D5           ; do LOOKUP High Score VALUES by (SP)
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L02ED           ; ROT do "Pop DE, Pop HL, EX (SP),HL then Push DE, Push (Old SP) to New System stack"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L07D8           ; WP! do "WRITE-protectedWORD" (SP+2) into (SP) & (SP)-513
        ;
        DW      L015F           ; 2+ do "ADD 2 to Top of System stack"
        ;
        DW      L07D8           ; WP! do "WRITE-protectedWORD" (SP+2) into (SP) & (SP)-513
        ;
        DW      L00B0           ; ... TerseRETurn

; P1@ does PUSH 2 Words in (SCore p1 Low nad High) for "SCORE P1" into Top of Stack
LD51E:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; sc1l "pushWORD to System stack"
        DW      $E396           ; for Word "SCore p1 Low" in High WRITE-protected NV RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; sc1h "pushWORD to System stack"
        DW      $E394           ; for Word ( SCore p1 High ) in High WRITE-protected NV RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; P2@ does PUSH 2 Words in (SCore p2 Low nad High) for "SCORE P2" into Top of Stack
LD52D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; sc2l "pushWORD to System stack"
        DW      $E392           ; for Word "SCore p2 Low" in High WRITE-protected NV RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; sc2h "pushWORD to System stack"
        DW      $E390           ; for Word ( SCore p2 High ) in High WRITE-protected NV RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD53C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; "TerseDO Loop begin" from 0 to 30 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1A             ; 26 for Number of LETTERS in the Alphabet
        ;
        DW      L1A5B           ; RND does "SHIFT and limit RANGE" for Next Letter in High Score INITIALS
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $41             ; 65 for base ASCII "A" to Offset
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L02B4           ; do "Push a copy of Second from Top word of System stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ; TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD55C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0155           ; 1- do "DECrement Top of System stack"
        ;
        DW      LD4FE           ; do PUSH 2 Words High Score VALUE by (SP)
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $02EE           ; 750 for ?? Range ??
        ;
        DW      L1A5B           ; RND does "SHIFT and limit RANGE for Next Pseudo-RANDOM Number"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L01FC           ; do "TEST (SP) Greater Than ZERO return in (SP)"
        ; IF False skip to THEN
        DW      L03CD,LD579     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; THEN
LD579:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ?? (note: High Score VALUES all end in 0 !!)
        ;
        DW      L041E           ; / do "word (SP) DIVide by (SP+2), Push QUOTIENT, Discard REMAINDER"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L0113           ; SWAP do "ex hl,de on System stack"
        ;
        DW      L02ED           ; ROT do "Pop DE, Pop HL, EX (SP),HL then Push DE, Push (Old SP) to New System stack"
        ;
        DW      LD50D           ; do COPY 2 words of High Score VALUE into ?? WRITE-protected
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD58B:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E361           ; for Word HIGH SCORES+1 ?? in High WRITE-protected NV RAM
        ;
        DW      LD53C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $2710           ; 10000 for ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00EE           ; 2DUP do "duplicate top 2 Words of System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0B             ; 11 for ??
        ;
        DW      LD4FE           ; do PUSH 2 Words High Score VALUE by (SP)
        ;
        DW      LD451
        ; IF False skip to THEN
        DW      L03CD,LD5AC     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L02FE           ; 2DROP do "Pop HL, Pop HL" to clean up System Stack
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0B             ; 11 for ??
        ;
        DW      LD4FE           ; do PUSH 2 Words High Score VALUE by (SP)
        ; THEN
LD5AC:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for ??
        ;
        DW      LD50D           ; do COPY 2 words of High Score VALUE into ?? WRITE-protected
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $16             ; 22 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0D             ; 13 for ??
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      LD55C
        ; TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD5C1:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L03E7           ; A" do Terse SKIP RELative by next Byte (counts
        DB      $03,"JAY"       ; over) embedded HIGHest SCORER" Text String
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3C7           ; for Word base of HIGH SCORE Text ?? in NV RAM
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for LETTERS in name
        ;
        DW      L07E5           ; do COPY Bytes count (SP+4) in (SP+2) into (SP) WRITE-protected
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3C7           ; for Word base of HIGH SCORE Text ?? in NV RAM
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for HIGH SCORE+3
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      LD53C
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $579E           ; for 22430 POINTS default HIGH SCORE to beat
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      LD50D           ; do COPY 2 words of High Score VALUE into ?? WRITE-protected
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0D             ; 13 for ??
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ; TerseDO Loop begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      LD55C
        ; TerseLOOP back to TerseDO (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      LD58B
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD5F7:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for Color 1 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD5FE:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for Color 2 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD605:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for Color 3 on Color 0
        ;
        DW      L1E45           ; XPAND!-ON do "Load eXPAND value ?? and turn it ON"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD60D:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB57           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD616:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L2125           ; BIN->ASC do "CONVERT BINary Number to ASCII Text String"
        ;
        DW      L04F9           ; 8 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L213E           ; 0SUPR do "REPLACE Leading Zeroes with SPACEs in Text String"
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD633:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4B           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      LD60D
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4A           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      LD60D
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD64C:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L1D81           ; X@ do "get ( vector address --- X )"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD657:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $15             ; 21 for ??
        ; TerseDO Loop #1 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L00EE           ; 2DUP do "duplicate top 2 Words of System stack"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      LD4FE           ; do PUSH 2 Words High Score VALUE by (SP)
        ;
        DW      LD451
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ; _IF False to THEN #1
        DW      L03CD,LD6C6     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ; __IF False to THEN #2
        DW      L03CD,LD69F     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ; ___TerseDO Loop #2 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      LD4FE           ; do PUSH 2 Words High Score VALUE by (SP)
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      LD50D           ; do COPY 2 words of High Score VALUE into ?? WRITE-protected
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      LD4BE           ; do "Initalize PRINT of trio of INITIALS"
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      LD4AD           ; do "COPY trio of INITIALS into ??"
        ;
        DW      L0529           ; -1 (hex $FFFF) "WORD Pusher"
        ; ___(?? DECrements TerseDO Loop #2 COUNTer ??) for Restore pass ??
        DW      L037A           ; do "Pop HL, ADD as Offset to TERSE Loop COUNT, check END limit"
        ; __THEN #2
LD69F:  DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4C           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      LD484           ; do LOOKUP High Score INITIALS by (SP)
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $2020           ; 8224 for ??
        ;
        DW      L02B4           ; do "Push a copy of Second from Top word of System stack"
        ;
        DW      L07D8           ; WP! do "WRITE-protectedWORD" (SP+2) into (SP) & (SP)-513
        ;
        DW      L015F           ; 2+ do "ADD 2 to Top of System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L0113
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ;
        DW      L0297           ; I do "Push TERSE Loop COUNTer onto System Stack"
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      LD50D           ; do COPY 2 words of High Score VALUE into ?? WRITE-protected
        ; _(?? Skip ONE pass of TerseDO Loop ??)
        DW      L03D9           ; do "Change TERSE Loop TO Value to current COUNTer"
        ; _THEN #1
LD6C6:  DW      L0529           ; -1 (hex $FFFF) "WORD Pusher"
        ; (?? DECrements TerseDO Loop #1 COUNTer ??) for ONE more pass ??
        DW      L037A           ; do "Pop HL, ADD as Offset to TERSE Loop COUNT, check END limit"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD6CC:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FC1B           ; for Word ?? in Static RAM
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      LD3BF           ; do "set Left colors then HORCB"
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      LD2C3
        ;
        DW      L1F49           ; NORMAL-SPACING do "load $FE3C with Byte 0 for ??"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE3B           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      LD605
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LD3DF           ; point to 21,"BALLY/MIDWAY MFG. CO." string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB1           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; BEHIND "pushBYTE to System stack"
        DB      $59             ; offset 89 for ( fellow BEHIND me )
        ;
        DW      LBE2C
        ;
        DW      LD3F5
        ;
        DW      LD5FE
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LD3AA           ; point to 20,"PROUDLY PRESENTS ITS" string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFB5           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $4D             ; 77 for ??
        ;
        DW      LBE2C
        ;
        DW      LD3F5
        ;
        DW      LD5F7
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      LD39D           ; point to 12,"HALL OF FAME" text string
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFCE           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $41             ; 65 for ??
        ;
        DW      LBE2C
        ;
        DW      LD3F5
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB57           ; for Word ?? in Static RAM
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $3101           ; 12545 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      LD5FE
        ;
        DW      LD633
        ; IF False skip to THEN #1
        DW      L03CD,LD732     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LD605
        ; THEN #1
LD732:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFCE           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $2D             ; 45 for ??
        ;
        DW      LBE2C
        ;
        DW      LD3F5
        ;
        DW      LD605
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      LD4BE           ; do "Initalize PRINT of trio of INITIALS"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFE2           ; for Word ?? in Static RAM
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      LD3F5
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      LD4FE           ; do PUSH 2 Words High Score VALUE by (SP)
        ;
        DW      LD616
        ;
        DW      LD5F7
        ;
        DW      LD633
        ; IF False skip to THEN #2
        DW      L03CD,LD75F     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LD605
        ; THEN #2
LD75F:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0F             ; 15 for ??
        ;
        DW      L1CF8           ; X! do ??
        ;
        DW      LD3F5
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1A             ; 26 for ??
        ;
        DW      L1D10           ; Y! do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB57           ; for Word ?? in Static RAM
        ;
        DW      L0442           ; 1+B! do "Pop HL, ADD 1 to (HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L1E56           ; PATTERN! do "Load Word PATTERN ?? address"
        ; Start a Fake "BEGIN WHILE REPEAT" loop
LD777:  DW      LD60D
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $16             ; 22 for ??
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ; IF False to THEN #3 (makes a Fake WHILE False to loop Exit) so Not INDENTed !!
        DW      L03CD,LD81D     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for ??
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; _IF False to ELSE #4
        DW      L03CD,LD797     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF7C           ; for Word ?? in Static RAM
        ; _(done so Jump to THEN #4)
        DW      L03C5,LD79A     ; TerseJUMP to ??
        ; _ELSE #4
LD797:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $16             ; 22 for ??
        ; _THEN #4
LD79A:  DW      L1CF8           ; X! do ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for ??
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; _IF False skip to THEN #5
        DW      L03CD,LD7AA     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1A             ; 26 for ??
        ;
        DW      L1D10           ; Y! do ??
        ; _THEN #5
LD7AA:  DW      LD60D
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L2125           ; BIN->ASC do "CONVERT BINary Number to ASCII Text String"
        ;
        DW      L1F49           ; NORMAL-SPACING do "load $FE3C with Byte 0 for ??"
        ;
        DW      LD5FE
        ;
        DW      LD633
        ; _IF False skip to THEN #6
        DW      L03CD,LD7C2     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LD605
        ; _THEN #6
LD7C2:  DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L213E           ; 0SUPR do "REPLACE Leading Zeroes with SPACEs in Text String"
        ;
        DW      LD3F5
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $16             ; 22 for ??
        ;
        DW      LD64C
        ;
        DW      LD60D
        ;
        DW      LD4BE           ; do "Initalize PRINT of trio of INITIALS"
        ;
        DW      LD605
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE3B           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      LD3F5
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FE3B           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $30             ; 48 for ??
        ;
        DW      LD64C
        ;
        DW      LD60D
        ;
        DW      LD4FE           ; do PUSH 2 Words High Score VALUE by (SP)
        ;
        DW      LD616
        ;
        DW      L1F52           ; EVEN-SPACE-NUMS do "load $FE3C with Byte 6 for ??"
        ;
        DW      LD5F7
        ;
        DW      LD633
        ; _IF False skip to THEN #7
        DW      L03CD,LD806     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LD605
        ; _THEN #7
LD806:  DW      LD3F5
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB57           ; for Word ?? in Static RAM
        ;
        DW      L0442           ; 1+B! do "Pop HL, ADD 1 to (HL)"
        ;
        DW      L1EC9           ; SELF do "Push CURRENT Vector Address"
        ;
        DW      L1D90           ; Y@ do "get ( vector address --- Y )"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0E             ; 14 for ??
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L1D10           ; Y! do ??
        ; Fake a "REPEAT loop to BEGIN always"
        DW      L03C5,LD777     ; TerseJUMP to ??
        ; THEN #3 (as Fake loop Exit !!)
LD81D:  DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L1F49           ; NORMAL-SPACING do "load $FE3C with Byte 0 for ??"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCF3           ; for Word ?? in Static RAM
        ;
        DW      L1681
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD829:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $13             ; for =&(19) aka OPTIONS SW3 read
        ;
        DW      L02E3           ; INP do "Pop BC, INPort L,(C) byte, Push 0,L word"
        ;
        DW      L04F9           ; 8 "BYTE Pusher" to MASK bit 3 CABINet = COCKTAIL
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB42           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ; IF False to ELSE
        DW      L03CD,LD84C     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $11             ; 17 for ??
        ; (done so Jump to THEN)
        DW      L03C5,LD84F     ; TerseJUMP to ??
        ; ELSE
LD84C:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $12             ; for =&(18) aka SW2 read for PLAYER 1 joystick
        ; THEN
LD84F:  DW      L02E3           ; INP do "Pop BC, INPort L,(C) byte, Push 0,L word"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LD853:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCF3           ; for Word ?? in Static RAM
        ;
        DW      L1615           ; commented out ;TASK: do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4B           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4A           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00BC           ; MONV2 "pushWORD to System stack"
        DW      $FB47           ; for "MONster Vector" #2 base in Static RAM
        ;
        DW      L0453           ; BONE do "store BYTE 1 into ((SP))"
        ;
        DW      LD51E           ; P1@ does PUSH 2 Words in (SCore p1 Low nad High) for "SCORE P1"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $15             ; 21 for ??
        ;
        DW      LD4FE           ; do PUSH 2 Words High Score VALUE by (SP)
        ;
        DW      LD451
        ; IF False skip to THEN #1
        DW      L03CD,LD889     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LD51E           ; P1@ does PUSH 2 Words in (SCore p1 Low nad High) for "SCORE P1"
        ;
        DW      LD657
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4C           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4B           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; THEN #1
LD889:  DW      LD52D           ; P2@ does PUSH 2 Words in (SCore p2 Low nad High) for "SCORE P2"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $15             ; 21 for ??
        ;
        DW      LD4FE           ; do PUSH 2 Words High Score VALUE by (SP)
        ;
        DW      LD451
        ;
        DW      L00BC           ; #PLA "pushWORD to System stack"
        DW      $E39A           ; for ( # of PLAyers-1 ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ; IF False to THEN #2
        DW      L03CD,LD8D5     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LD52D           ; P2@ does PUSH 2 Words in (SCore p2 Low nad High) for "SCORE P2"
        ;
        DW      LD657
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4C           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4A           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4B           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01EB           ; do "TEST (SP+2) Less or Equal (SP) return in (SP)"
        ; _IF False to THEN #3
        DW      L03CD,LD8D5     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4B           ; for Word ?? in Static RAM
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $15             ; 21 for ??
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ; __IF False to ELSE #4
        DW      L03CD,LD8D3     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L0442           ; 1+B! do "Pop HL, ADD 1 to (HL)"
        ; __(done so Jump to THEN #4)
        DW      L03C5,LD8D5     ; TerseJUMP to ??
        ; __ELSE #4
LD8D3:  DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ; _THEN #2, THEN #3 and THEN #4
LD8D5:  DW      L1E70           ; XOR-ON do "Turn X-OR writes ON in Magic ??"
        ;
        DW      L1ECF           ; 1STWRITE do ??
        ;
        DW      L1F34           ; INVERT-OFF do "clear COCKTAIL mode for UPRIGHTs"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB42           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L82E3           ; Player ONE UP pattern
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4B           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4C           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; BEGIN loop #1
LD8F5:  DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L01F6           ; 0<> do "Pop HL, Push F on Zero or T on Not Zero"
        ; _IF False to ELSE #5
        DW      L03CD,LDADB     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB42           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; __IF False skip to THEN #6
        DW      L03CD,LD919     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LD6CC
        ;
        DW      L1670           ; SLEEP do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      L82E3           ; Player ONE UP pattern
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4C           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; __THEN #6
LD919:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1E             ; 30 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB49           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FCAB           ; for Word ?? in Static RAM
        ;
        DW      LD40A
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FC63           ; for Word ?? in Static RAM
        ;
        DW      LD436
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00E3           ; 1 do "Push WORD 1 to System stack"
        ;
        DW      L0194           ; = do "Pop DE, Pop HL, Push T on EQUAL or F on Not Equal"
        ; __IF False to ELSE #7
        DW      L03CD,LD94F     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00F6           ; DROP do "Pop HL from System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFC2           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $2D             ; 45 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FFE2           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB43           ; for Word ?? in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ; __(done so Jump to THEN #7)
        DW      L03C5,LD987     ; TerseJUMP to ??
        ; __ELSE #7
LD94F:  DW      L04ED           ; 2 "BYTE Pusher" for ??
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; ___IF False to ELSE #8
        DW      L03CD,LD96A     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF72           ; for Word ?? in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FF92           ; for Word ?? in Static RAM
        ; ___(done so Jump to THEN #8)
        DW      L03C5,LD975     ; TerseJUMP to ??
        ; ___ELSE #8
LD96A:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0C             ; 12 for ??
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $2C             ; 44 for ??
        ; ___THEN #8
LD975:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB43           ; for Word ?? in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $1A             ; 26 for ??
        ;
        DW      L02ED           ; ROT do "Pop DE, Pop HL, EX (SP),HL then Push DE, Push (Old SP) to New System stack"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0E             ; 14 for ??
        ;
        DW      L0302           ; * do "word (SP+2) MULTiply (SP), push PRODUCT"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ; __THEN #7
LD987:  DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB45           ; for Word ?? in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      LBE2C
        ;
        DW      LD5F7
        ;
        DW      L1E3A           ; XPAND!-OFF do "Turn eXPAND ?? OFF"
        ;
        DW      L1DD4
        ;
        DW      L1E2F           ; XPAND-ON do "Turn eXPAND back ON without Loading it !!"
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for Light GRAY
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for &(5)=6 as COL1L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L3B88           ; SUCK-S do ??
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for BLACK
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for &(5)=0 as COL1L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $41             ; 65 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB57           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      LD5FE
        ;
        DW      LD60D
        ;
        DW      LD3D4
        ;
        DW      L00BC           ; MONV2 "pushWORD to System stack"
        DW      $FB47           ; for "MONster Vector" #2 base in Static RAM
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB43           ; for Word ?? in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB45           ; for Word ?? in Static RAM
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      LBE2C
        ;
        DW      LD3F5
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ; _BEGIN loop #2
LD9E7:  DW      LD829
        ;
        DW      L051D           ; 255 (or -1) "BYTE Pusher" for ??
        ;
        DW      L0236           ; XOR do "word (SP) XOR (SP+2)"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04FB           ; 9 "BYTE Pusher" for ??
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ; __IF False to THEN #9
        DW      L03CD,LDA15     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LD60D
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5A             ; 90 for ??
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; ___IF False to ELSE #10
        DW      L03CD,LDA0C     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB57           ; for Word ?? in Static RAM
        ;
        DW      L0442           ; 1+B! do "Pop HL, ADD 1 to (HL)"
        ; ___(done so Jump to THEN #10)
        DW      L03C5,LDA15     ; TerseJUMP to ??
        ; ___ELSE #10
LDA0C:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $41             ; 65 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB57           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; __THEN #9 and THEN #10
LDA15:  DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for ??
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ; _IF False to THEN #11
        DW      L03CD,LDA3D     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LD60D
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $41             ; 65 for ??
        ;
        DW      L01E6           ; > do "TEST (SP+2) GREATER Than (SP) return in (SP)"
        ; __IF False to ELSE #12
        DW      L03CD,LDA34     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB57           ; for Word ?? in Static RAM
        ;
        DW      L0448           ; 1-B! do "Pop HL, SUBtract 1 from (HL)"
        ; __(done so Jump to THEN #12)
        DW      L03C5,LDA3D     ; TerseJUMP to ??
        ; __ELSE #12
LDA34:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $5A             ; 90 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB57           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ; _THEN #11 and THEN #12
LDA3D:  DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ; _IF False to THEN #13
        DW      L03CD,LDA94     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LD60D
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L0442           ; 1+B! do "Pop HL, ADD 1 to (HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $14             ; 20 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB49           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L01BE           ; < do "TEST (SP) LESS Than (SP+2) return in (SP)"
        ; __IF False skip to THEN #14
        DW      L03CD,LDA87     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L37D0
        ;
        DW      LD60D
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      LD3D4
        ;
        DW      L06C5
        ;
        DW      L0155           ; 1- do "DECrement Top of System stack"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04F1           ; 4 "BYTE Pusher" for ??
        ;
        DW      L013B           ; + do "ADD (SP) to (SP+2), Push SUM"
        ;
        DW      LD64C
        ;
        DW      LD3F5
        ; __THEN #14 and BEGIN loop #3
LDA87:  DW      L1660           ; SYNC do ??
        ;
        DW      LD829
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $20             ; 32 for ??
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ; _END #3 or loop to BEGIN #3 if False
        DW      L03CD,LDA87     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ; _THEN #13
LDA94:  DW      LD60D
        ;
        DW      L00BC           ; MONV2 "pushWORD to System stack"
        DW      $FB47           ; for "MONster Vector" #2 base in Static RAM
        ;
        DW      L015A           ; 1+ do "INCrement Top of System stack"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01A2           ; <> do "Pop DE, Pop HL, T on NOT EQUAL or Push F on Equal"
        ; __IF False to THEN #15
        DW      L03CD,LDABF     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $0A             ; 10 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB49           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      LD3F5
        ;
        DW      LD60D
        ;
        DW      LD3D4
        ;
        DW      LD3F5
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $03E8           ; 1000 Loops for medium DELAY
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; ___TerseDO Loop #4 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; "TerseDO Loop begin" 0 to 1000
        ; ___TerseLOOP #4 back to TerseDO #4 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ; __THEN #15
LDABF:  DW      L1660           ; SYNC do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4D           ; for Word ?? (temporary storage ??) in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L04EF           ; 3 "BYTE Pusher" for ??
        ;
        DW      L01D2           ; do "TEST (SP) Less or Equal (SP+2) return in (SP)"
        ; _END #2 or loop to BEGIN #2 if False
        DW      L03CD,LD9E7     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4C           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      LD4AD           ; do "COPY trio of INITIALS into ??"
        ; _(done so Jump to THEN #5)
        DW      L03C5,LDADD     ; TerseJUMP to ??
        ; _ELSE #5
LDADB:  DW      L02FE           ; 2DROP do "Pop HL, Pop HL" to clean up System Stack
        ; _THEN #5
LDADD:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB42           ; for Word ?? in Static RAM
        ;
        DW      L0448           ; 1-B! do "Pop HL, SUBtract 1 from (HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4A           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F6           ; 0<> do "Pop HL, Push F on Zero or T on Not Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB42           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ; _IF False to THEN #16
        DW      L03CD,LDB2A     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0FA0           ; 4000 for ?? crude delay
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ; __TerseDO Loop #5 begin (for Pop START Count up to Pop END Value)
        DW      L024E           ; DO loop "(SP) = START, (SP+2) = END limit"
        ; __TerseLOOP #5 back to TerseDO #5 (until INCrement COUNTer reaches to END value)
        DW      L0269           ; LOOP "back to DO or continue" with BC = next location
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $13             ; for =&(19) aka OPTIONS SW3 read
        ;
        DW      L02E3           ; INP do "Pop BC, INPort L,(C) byte, Push 0,L word"
        ;
        DW      L04F9           ; 8 "BYTE Pusher" to MASK bit 3 CABINet = COCKTAIL
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; __IF False to ELSE #17
        DW      L03CD,LDB1A     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L1F2D           ; INVERT-ON does "set COCKTAIL mode for P2 ONLY" !!
        ;
        DW      LD6CC
        ;
        DW      L1670           ; SLEEP do ??
        ; __(done so Jump to THEN #17)
        DW      L03C5,LDB2A     ; TerseJUMP to ??
        ; __ELSE #17
LDB1A:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4B           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; ___IF False to THEN #18
        DW      L03CD,LDB2A     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LD6CC
        ;
        DW      L1670           ; SLEEP do ??
        ; _THEN #16, THEN #17 and THEN #18
LDB2A:  DW      L00BC           ; do "pushWORD to System stack"
        DW      L82FF           ; Player TWO UP pattern
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4A           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00E9           ; DUP do "Duplicate Top of System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4C           ; for Word ?? in Static RAM
        ;
        DW      L012E           ; B! do "Pop HL, Pop DE, Only byte E->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB42           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L01F0           ; 0= do "Pop HL, Push T on Zero or F on Not Zero"
        ; END #1 or loop to BEGIN #1 if False
        DW      L03CD,LD8F5     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L1F34           ; INVERT-OFF do "clear COCKTAIL mode for UPRIGHTs"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4B           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB4A           ; for Word ?? in Static RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ; IF False to ELSE #19
        DW      L03CD,LDB74     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L04F5           ; 6 "BYTE Pusher" for Light GRAY
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for &(5)=6 as COL1L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ;
        DW      L3B88           ; SUCK-S do ??
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack" for BLACK
        ;
        DW      L04F3           ; 5 "BYTE Pusher" for &(5)=0 as COL1L
        ;
        DW      L02DB           ; OUTP do "Pop BC, Pop HL, OUTport (C),L byte"
        ; (done so Jump to THEN #19)
        DW      L03C5,LDB78     ; TerseJUMP to ??
        ; ELSE #19
LDB74:  DW      LD6CC
        ;
        DW      L1670           ; SLEEP do ??
        ; THEN #19
LDB78:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $01C2           ; 450 for ??
        ;
        DW      L1B04           ; TIMER!-ON do "save TTIMER and START TIMER"
        ;
        DW      L1949           ; WAIT do "ZGO but ... with TBNOVECT of TVMROPT set"
        ;
        DW      L32F3           ; SHUTUP does "SHUT UP all sounds"
        ;
        DW      L221F           ; VGER-OUT do ??
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ??
LDB86:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; sc1l "pushWORD to System stack"
        DW      $E396           ; for Word "SCore p1 Low" in High WRITE-protected NV RAM
        ;
        DW      L07DF           ; WPZERO do "WRITE-protectedWORD 0" into (SP) & (SP)-513
        ;
        DW      L00BC           ; sc1h "pushWORD to System stack"
        DW      $E394           ; for Word ( SCore p1 High ) in High WRITE-protected NV RAM
        ;
        DW      L07DF           ; WPZERO do "WRITE-protectedWORD 0" into (SP) & (SP)-513
        ;
        DW      L00BC           ; sc2l "pushWORD to System stack"
        DW      $E392           ; for Word "SCore p2 Low" in High WRITE-protected NV RAM
        ;
        DW      L07DF           ; WPZERO do "WRITE-protectedWORD 0" into (SP) & (SP)-513
        ;
        DW      L00BC           ; sc2h "pushWORD to System stack"
        DW      $E390           ; for Word ( SCore p2 High ) in High WRITE-protected NV RAM
        ;
        DW      L07DF           ; WPZERO do "WRITE-protectedWORD 0" into (SP) & (SP)-513
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ?? to Initalize HIGH SCORES Screen
LDBA1:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L333D           ; PUP do ??
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FB42           ; for Word ?? in Static RAM
        ;
        DW      L00C5           ; do "pushBYTE to System stack"
        DB      $16             ; 22 for ??
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"
        ;
        DW      LBDBC           ; ?? do "CLEAR $01B0 bytes from $FB8B through $FD3A"
        ;
        DW      L00BC           ; VSEN "pushWORD to System stack"
        DW      $FDB1           ; for Word ?? for ?? in Static RAM
        ;
        DW      L3C04           ; TRY-PA do ??
        ;
        DW      LD853
        ;
        DW      L2218           ; TT do "First Interrupt Routine then More of Third"
        ;
        DW      LDB86
        ;
        DW      L00B0           ; ... TerseRETurn

; LDBBF: loose byte CKB ?? at end of Display High Scores code
        DB      $6D             ; ChecKsum Byte ??

; ?? does ?? Initialize All ?? ATTRACT Mode Screens
LDBC0:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FA           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ;
        DW      LCAD5           ; do TEST for FREE PLAY (returns True)
        ;
        DW      L022B           ; OR do "word (SP) OR (SP+2)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FE           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does ?? De-initialize ATTRACT Mode Screens
LDBD9:  RST     $08             ; begin ASSEMBLED TerseCODE ...
        ;
        DW      L00BC           ; ' ROTO "pushWORD to System stack"
        DW      $3FFA           ; 16378 for ?? in ROM ?? NOT Pattern ??
        ;
        DW      L0119           ; @ do "Pop HL from System stack, Push (HL) word to System stack"
        ;
        DW      LC4E5           ; do "NULL routine"
        ;
        DW      LDBA1           ; do Initalize HIGH SCORES Screen
        ;
        DW      L00B0           ; ... TerseRETurn

; ?? does READ R register for ?? TERSE
LDBE6:  LD      A,R
        PUSH    AF
        JP      (IY)            ; indexed RETurn

; ?? does READ =&(16) Control Port (but NOT stored ??)
LDBEB:  IN      A,(SW0)         ; inport =&(16) Control Port
        JP      (IY)            ; indexed RETurn

; LDBEF: would start Robby Roto again subroutine
        RST     $08             ; begin ASSEMBLED TerseCODE ...
; continued below ...
;*****************************************************************************
;
; Service switch was OFF, so Start Robby Roto here
;
; LDBF0: TerseRoutine already EQUated
;*****************************************************************************
; ?? does ??
        DW      LDBEB           ; word to READ =&(16) Control Port
        ;
        DW      LDBE6           ; READ R register for ??
        ;
        DW      L085D           ; do test Option switches here
        ;
        DW      LDBEB           ; READ =&(16) Control Port again
        ;
        DW      L00DD           ; 0 do "Push WORD 0 to System stack"
        ;
        DW      L00BC           ; $E400 do "pushWORD to System stack" (could use WORD Pusher !!)
        DW      $E400           ; for "TOP Half of x21" base (in NON-protected NV RAM)
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $1B00           ; 6912 for Count to near End of Static RAM
        ;
        DW      L055C           ; FILL do "FILL byte (SP+4) from (SP+2) while (SP)"

        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3D1           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L00D8           ; do "Pop HL, times 2, read (BC) word to DE, add HL,DE and Push HL"
        DW      $FE3D           ; for Word Low RANdom SHifT register in Static RAM
        ;
        DW      L0127           ; ! do "Pop HL, Pop DE, word DE->(HL)"
        ;
        DW      L333D           ; PUP do ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FB           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; IF False to ELSE #1
        DW      L03CD,LDC26     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LD5C1
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FB           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L07C9           ; WPZERO do "WRITE-protectedBYTE 0" into (SP) & (SP)-512d
        ; (done so Jump to THEN #1)
        DW      L03C5,LDC34     ; TerseJUMP to ??
        ; ELSE #1
LDC26:  DW      LD58B
        ;
        DW      L00BC           ; RESTART? "pushWORD to System stack"
        DW      $E3FC           ; point to "0, 1, 2 counter for RESTART"
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; _IF False skip to THEN #2
        DW      L03CD,LDC34     ; ConditionalJUMP if ?? on Second word ??
        ;
        DW      LDBD9           ; do De-initialize ATTRACT Mode Screens ??
        ; THEN #1, THEN #2 and BEGIN loop
LDC34:  DW      LCAD5           ; do TEST for FREE PLAY (returns True)
        ; _IF False skip to THEN #3
        DW      L03CD,LDC44     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $0900           ; 2304 for ??
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3F9           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L07D8           ; WP! do "WRITE-protectedWORD" (SP+2) into (SP) & (SP)-513
        ; _THEN #3
LDC44:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FE           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ; _IF False to ELSE #4
        DW      L03CD,LDC96     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; GAMEOVER "pushWORD to System stack"
        DW      $E3FF           ; read "GAME OVER" (disallows ??) in High WRITE-protected NV RAM
        ;
        DW      L07C9           ; WPZERO do "WRITE-protectedBYTE 0" into (SP) & (SP)-512d
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $FEEB           ; for Word ?? in Static RAM
        ;
        DW      L0458           ; BZERO do "store BYTE 0 into ((SP))"
        ;
        DW      LCAD5           ; do TEST for FREE PLAY (returns True)
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ; __IF False skip to THEN #5
        DW      L03CD,LDC76     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FA           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FE           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0141           ; - do "SUBtract word (SP) from (SP+2), Push DIFFERENCE"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FA           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ; __THEN #5
LDC76:  DW      L00BC           ; $E400 do "pushWORD to System stack" (could use WORD Pusher !!)
        DW      $E400           ; for "TOP Half of x21" base (in NON-protected NV RAM)
        ;
        DW      L0133           ; ZERO do "Pop HL, word 00->(HL)"
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FE           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0155           ; 1- do "DECrement Top of System stack"
        ;
        DW      L00BC           ; #PLA "pushWORD to System stack"
        DW      $E39A           ; for ( # of PLAyers-1 ) Byte-Variable in High WRITE-protected NV RAM
        ;
        DW      L07BD           ; WPB! do "WRITE-protectedBYTE" in (SP+2) into (SP) & (SP)-512
        ;
        DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FE           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L07C9           ; WPZERO do "WRITE-protectedBYTE 0" into (SP) & (SP)-512d
        ;
        DW      LDBD9           ; do De-initialize ATTRACT Mode Screens ??
        ; _(done so Jump to THEN #4)
        DW      L03C5,LDCD2     ; TerseJUMP to ??
        ; _ELSE #4
LDC96:  DW      L00BC           ; do "pushWORD to System stack"
        DW      $E3FA           ; for Word ?? in High WRITE-protected NV RAM
        ;
        DW      L0120           ; B@ do "Pop word, Push 0,(HL) byte to System stack"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ;
        DW      LCAD5           ; do TEST for FREE PLAY (returns True)
        ;
        DW      L0214           ; NOT do JumP to "TEST (SP) Equal ZERO return in (SP)"
        ;
        DW      L0220           ; AND do "word (SP) AND (SP+2)"
        ; __IF False to ELSE #6
        DW      L03CD,LDCB0     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LCDDB
        ; __(done so Jump to THEN #6)
        DW      L03C5,LDCD2     ; TerseJUMP to ??
        ; __ELSE #6
LDCB0:  DW      LDB86
        ;
        DW      LDBC0
        ; ___IF False skip to THEN #7
        DW      L03CD,LDCBA     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LC3A3
        ; ___THEN #7
LDCBA:  DW      LDBC0
        ; ___IF False skip to THEN #8
        DW      L03CD,LDCC2     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LDBA1           ; do Initalize HIGH SCORES Screen (at END of GAME !!)
        ; ___THEN #8
LDCC2:  DW      LDBC0
        ; ___IF False skip to THEN #9
        DW      L03CD,LDCCA     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LC3A3
        ; ___THEN #9
LDCCA:  DW      LDBC0
        ; ___IF False to THEN #10
        DW      L03CD,LDCD2     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      LCDDB
        ; _THEN #4, THEN #6 and THEN #10
LDCD2:  DW      L00DD           ; 0 do "Push WORD 0 to System stack" for ALWAYS Loop !!
        ; END   if False
        DW      L03CD,LDC34     ; ConditionalJUMP "only IF Top of System stack is Zero"
        ;
        DW      L00B0           ; ... TerseRETurn
; end of "Service switch was OFF, so Start Robby Roto here" TerseCODE !!

; more MAZE Data and ??
LDCDA:  DB      $04,$33,$41,$83,$03,$60,$22,$50
        DB      $82,$52,$00,$00,$00,$01,$23,$33
        DB      $00,$00,$01,$22,$30,$30,$00,$00
        DB      $13,$32,$71,$30,$00,$01,$21,$05
        DB      $31,$00,$00,$11,$2F,$A1,$20,$00
        DB      $00,$22,$22,$20,$00,$12,$A3,$52
        DB      $03,$03,$51,$A2,$02,$A2,$00,$00
        DB      $00,$00,$00,$00,$00,$01,$32,$32
        DB      $30,$12,$33,$12,$13,$12,$23,$12
        DB      $30,$33,$12,$30,$12,$22,$00,$31
        DB      $05,$FA,$00,$00,$00,$22,$22,$00
        DB      $00,$21,$63,$92,$03,$61,$31,$60
        DB      $91,$62,$00,$00,$01,$30,$05,$BF
        DB      $00,$00,$03,$33,$73,$73,$30,$00
        DB      $10,$30,$BB,$03,$00,$01,$33,$22
        DB      $33,$20,$00,$57,$F7,$F7,$20,$00
        DB      $00,$A0,$A0,$A0,$00,$22,$71,$85
        DB      $03,$91,$11,$14,$84,$51,$00,$00
        DB      $00,$00,$00,$5F,$00,$00,$5F,$13
        DB      $23,$A7,$F0,$00,$B3,$17,$13,$3A
        DB      $00,$12,$33,$72,$13,$00,$00,$7F
        DB      $17,$23,$10,$00,$00,$A2,$20,$02
        DB      $00

LDD8B:  DB          $0E,$22,$61,$83,$03,$90,$05
        DB      $52,$A5,$52,$00,$00,$13,$23,$00
        DB      $01,$23,$30,$30,$5F,$05,$F0,$12
        DB      $01,$37,$12,$35,$33,$00,$12,$53
        DB      $31,$70,$30,$13,$27,$12,$35,$23
        DB      $30,$20,$0A,$AA,$A0,$02,$12,$51
        DB      $A2,$03,$05,$02,$70,$A5,$52,$00
        DB      $00,$05,$F3,$5F,$5F,$5F,$00,$12
        DB      $13,$23,$33,$23,$13,$12,$23,$20
        DB      $30,$10,$23,$13,$22,$33,$33,$13
        DB      $33,$5F,$F1,$31,$30,$22,$2A,$00
        DB      $A0,$22,$22,$62,$A4,$03,$51,$02
        DB      $50,$A2,$52,$00,$00,$13,$23,$12
        DB      $31,$23,$31,$35,$F2,$17,$F0,$13
        DB      $03,$0A,$13,$0A,$23,$31,$25,$BF
        DB      $13,$23,$31,$13,$71,$5F,$02,$35
        DB      $F0,$20,$AA,$0A,$AA,$0A,$11,$51
        DB      $52,$03,$60,$10,$05,$A0,$42,$00
        DB      $00,$05,$F1,$37,$F3,$5F,$31,$2A
        DB      $21,$2A,$12,$A3,$03,$33,$35,$31
        DB      $33,$11,$23,$32,$53,$03,$31,$55
        DB      $31,$37,$33,$17,$70,$A2,$22,$00
        DB      $22,$0A,$11,$51,$91,$03,$A2,$05
        DB      $30,$A5,$52,$00,$00,$5B,$F3,$5A
        DB      $F3,$5B,$F5,$07,$35,$35,$35,$27
        DB      $03,$12,$31,$31,$23,$21,$31,$13
        DB      $03,$23,$13,$13,$13,$0F,$A0,$13
        DB      $10,$22,$02,$20,$00,$22,$22,$51
        DB      $A2,$03,$50,$03,$60,$A4,$52,$00
        DB      $00,$05,$33,$73,$32,$73,$31,$73
        DB      $07,$03,$27,$23,$12,$53,$02,$73
        DB      $20,$11,$35,$31,$75,$13,$53,$13
        DB      $21,$17,$13,$07,$30,$22,$22,$22
        DB      $20,$02,$01,$50,$92,$03,$51,$05
        DB      $70,$A4,$52,$00,$00,$13,$37,$12
        DB      $37,$33,$01,$31,$2A,$BA,$A0,$30
        DB      $03,$03,$AA,$AB,$32,$31,$23,$13
        DB      $BB,$12,$33,$13,$23,$0B,$A1,$33
        DB      $10,$20,$02,$AA,$22,$02,$02,$51
        DB      $93,$03,$40,$01,$60,$A4,$52,$00
        DB      $00,$13,$33,$5B,$F3,$23,$31,$21
        DB      $27,$37,$03,$03,$03,$27,$0A,$B5
        DB      $33,$31,$32,$70,$12,$52,$13,$03
        DB      $17,$12,$27,$31,$30,$02,$2A,$AA
        DB      $A2,$02,$11,$61,$91,$03,$30,$03
        DB      $50,$A0,$81,$00,$00,$5B,$F1,$77
        DB      $F3,$5B,$F5,$27,$35,$25,$37,$07
        DB      $1B,$A1,$0A,$A2,$1B,$B1,$03,$23
        DB      $33,$23,$22,$11,$33,$03,$31,$33
        DB      $30,$22,$22,$20,$22,$22,$11,$72
        DB      $80,$03,$50,$05,$40,$A0,$52,$00
        DB      $00,$13,$13,$13,$13,$22,$31,$23
        DB      $13,$13,$23,$33,$13,$02,$32,$13
        DB      $03,$31,$32,$32,$00,$22,$33,$17
        DB      $F7,$F5,$F7,$F7,$A0,$A0,$A2,$A0
        DB      $A0,$A0,$33,$50,$92,$03,$60,$03
        DB      $30,$A2,$42,$00,$00,$13,$33,$22
        DB      $33,$30,$01,$31,$7A,$F0,$33,$30
        DB      $13,$10,$35,$31,$30,$31,$03,$22
        DB      $53,$03,$33,$13,$03,$35,$23,$31
        DB      $30,$22,$22,$20,$02,$02,$00,$40
        DB      $A0,$03,$60,$40,$05,$A2,$52,$00
        DB      $00,$53,$23,$31,$33,$33,$71,$F1
        DB      $23,$12,$02,$7B,$12,$F2,$22,$23
        DB      $5A,$11,$01,$F3,$33,$7A,$33,$13
        DB      $31,$A5,$0B,$13,$30,$22,$02,$22
        DB      $20,$22,$01,$42,$91,$03,$05,$02
        DB      $41,$A3,$62,$00,$00,$5F,$33,$13
        DB      $13,$37,$F1,$A2,$17,$F3,$02,$2B
        DB      $11,$33,$0A,$03,$33,$21,$10,$27
        DB      $27,$33,$13,$13,$33,$1F,$B0,$32
        DB      $20,$22,$22,$00,$22,$00,$11,$52
        DB      $81,$03,$10,$01,$A1,$50,$72,$00
        DB      $00,$17,$23,$31,$31,$37,$01,$A3
        DB      $33,$03,$22,$3B,$03,$70,$22,$21
        DB      $F0,$31,$30,$B1,$73,$03,$33,$0F
        DB      $23,$17,$31,$37,$B0,$02,$22,$00
        DB      $22,$02

; ?? pointed to by MAZELST then looked up by MAKE:MAZE for ??
LDFF4:  DW      L3F67           ; points to "?? MAZE Data somehow !!" at end of Low ROM !!
        DW      LDCDA           ; points to "more MAZE Data and ??" !! at end of High ROM !!
        DW      LDD8B           ; points to ?? at end of High ROM !!
        DW      LDD8B           ; points to SAME !!
        DW      $05FF           ; odd, points to a "RST $30" which leads to "re-start Robby Roto here" code ??
        DW      L8201 + 2       ; ex-p Monochrome EXIT SIGN pattern offset to Width in Bytes !!

        END

; BELOW END !! Game Play:
Make Robby Roto lead the Hostages to the door at the Top of the Screen.
Avoid the Spiders, the Teeth and Voltar, who becomes the Troll and digs.
They will steal back the Rescuees, but their touch is most deadly to you.

All you have is your skill, plus one Magic per Maze to become invisible,
but only for 5 to 7 seconds.  Unused Magics can be accumulated for later.

Note: the prototype Robby Roto allowed you to tunnel Diagonally, that was
deemed too difficult to maneuver so travel is now limited to 4 directions.


Scoring:
No points for picking up the Key, after all you need that to get out...

Connect to a Hostage for 100 Points (each and every time that you do!)
Save Hostage(s) out the door: One = 200, Two = 250, Three = 300, etc.

Treasure values: (Maze - 1) times 200 Points (none in First maze ??)
All Rooms Entered bonus: (Maze - 1) times 10 Points per Room on screen.
OK, for the First maze a 5 Point bonus each Room if you visit them all.

Save Three hostages together and the Points will be Doubled next maze!
Do that for Two mazes in a row and the Point values will all be Tripled!!

Bonus Roto awarded at the end of the Third maze, and occasionally after.

Motto: Robby Roto digs his way into the hearts of game players everywhere.